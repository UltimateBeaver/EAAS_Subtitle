1
00:00:00,000 --> 00:00:03,000
关于行为驱动开发与测试驱动开发，大家觉得哪种说法正确，

2
00:00:03,003 --> 00:00:05,003
是需求推动执行，只有敏捷的开发流程

3
00:00:05,005 --> 00:00:09,005
才使用BDD（行为驱动开发）与TDD（测试驱动开发），

4
00:00:09,009 --> 00:00:13,009
还是他们只是用来涵盖并处理改动的？

5
00:00:13,013 --> 00:00:19,013
来个初步投票？好吧，我们在场的大多数人都选红色选项，

6
00:00:19,019 --> 00:00:22,019
不过意见并不一致。再考虑30秒。

7
00:00:22,022 --> 00:00:29,022
我们再来投票，我们选红色的意见一致了。

8
00:00:29,029 --> 00:00:33,029
红色选项是正确的。当然，需求推动执行

9
00:00:33,033 --> 00:00:35,033
具备两个特征：你希望实现的功能和你

10
00:00:35,035 --> 00:00:37,035
希望写出的代码，这才是你的出发点。从这两方面看

11
00:00:37,037 --> 00:00:41,037
好像确实是第一种情况：只能在敏捷开发里使用它们。

12
00:00:41,041 --> 00:00:43,041
这可就不对了。他们是从这儿来的，因为

13
00:00:43,043 --> 00:00:46,043
这样可以方便、快速地迭代新功能，

14
00:00:46,046 --> 00:00:48,046
不过你也可以先去见客户，

15
00:00:48,048 --> 00:00:52,048
拿回一整摞功能表，然后花上六个月

16
00:00:52,052 --> 00:00:54,052
实现这些功能，等回来，客户却告诉你他们改主意了。

17
00:00:54,054 --> 00:00:57,054
你完全可以这样做。B不对。

18
00:00:57,057 --> 00:01:00,057
你们可以在敏捷开发范畴外运用他们，只不过他们很适合敏捷开发。

19
00:01:00,000 --> 00:01:03,060
这是他们的出处。最后是选项c，

20
00:01:03,063 --> 00:01:06,063
他们可以接受并应对变化。他们当然行，

21
00:01:06,066 --> 00:01:08,066
因为要是你正在实现一个特性，

22
00:01:08,068 --> 00:01:11,068
或你正在处理一组功能，BDD和TDD方法让你

23
00:01:11,071 --> 00:01:14,071
能小步前进取得进展，

24
00:01:14,074 --> 00:01:17,074
而不必冒险编写一大堆客户可能根

25
00:01:17,077 --> 00:01:19,077
本不买账的代码。
