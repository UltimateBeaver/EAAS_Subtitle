1
00:00:00,000 --> 00:00:03,000
继续讲课。我们已经讲过模型了。也讲过

2
00:00:03,003 --> 00:00:07,003
控制器，现在就只剩下视图。和模型与控制器一样，

3
00:00:07,007 --> 00:00:09,007
要处理视图有多个方法，

4
00:00:09,009 --> 00:00:12,009
同时和讲解模型与控制器时一样，我会介绍Rails处理视图的方法。

5
00:00:12,012 --> 00:00:14,012
还会向你们讲解至少一个替代方法，

6
00:00:14,014 --> 00:00:17,014
之后我们会讲大家为什么要视情况不同做不同的选择。

7
00:00:17,017 --> 00:00:19,017
接下来，我们要讲的是模板视图，

8
00:00:19,019 --> 00:00:22,019
这是我们在MVC应用程序中处理视图的指定方法。

9
00:00:22,022 --> 00:00:27,022
所以我们基本上要在这里解决什么问题呢？

10
00:00:27,027 --> 00:00:30,027
我们知道浏览器显示HTML，这就是他们做的事。所以无论我们

11
00:00:30,030 --> 00:00:33,030
何时返还信息，都会面向用户。

12
00:00:33,033 --> 00:00:36,033
这是我们要使用的格式。问题是我们在应用程序内存储的

13
00:00:36,036 --> 00:00:40,036
数据是怎样变成HTML的。和以前一样，如果你曾在其他结构下

14
00:00:40,040 --> 00:00:43,040
做过任何类型的网络编程，你可能

15
00:00:43,043 --> 00:00:46,043
会对人们所说的模板视图做一些不同的变化，

16
00:00:46,046 --> 00:00:49,046
而模板视图正是我们接下来要研究的对象。

17
00:00:49,049 --> 00:00:52,049
无论请求是什么，在模板视图模式内， 

18
00:00:52,052 --> 00:00:56,052
基本上你的视图由一定量的固定标记， 

19
00:00:56,056 --> 00:00:59,056
即不变化的内容构成，然后操作时，你可

20
00:00:59,059 --> 00:01:04,059
在该视图模板内有选择的插入数据。例如，

21
00:01:04,064 --> 00:01:06,064
这儿也许有显示电影信息的通用模板，

22
00:01:06,066 --> 00:01:10,066
然后在操作时，无论选定哪个具体的电影，

23
00:01:10,070 --> 00:01:14,070
都会取代或插入到该信息内。

24
00:01:14,074 --> 00:01:16,074
所以有个例子就是，你将一堆变量与

25
00:01:16,076 --> 00:01:20,076
这些变量值实例化成代码或

26
00:01:20,080 --> 00:01:23,080
运行模板。你也许会将

27
00:01:23,083 --> 00:01:30,083
少量短代码嵌入模板，过去

28
00:01:30,090 --> 00:01:33,090
这几乎遍布整个应用程序。如果你特别关注

29
00:01:33,093 --> 00:01:36,093
一些早期的PHP应用程序，就会发现它们开始都是HTML，

30
00:01:36,096 --> 00:01:39,096
然后有少量符号，之后

31
00:01:39,099 --> 00:01:43,099
有一些代码，再然后出现更多的HTML。随着时间的推移， HTML越来越小

32
00:01:43,103 --> 00:01:45,103
，而嵌入的代码变得越来越庞大，

33
00:01:45,105 --> 00:01:50,105
所以，要想你的应用程序便于掌控，这可不是个好办法。

34
00:01:50,110 --> 00:01:54,110
所以我们要按照模型视图控制器的处理方法实现这一点。

35
00:01:54,114 --> 00:01:57,114
我们要使用名为HAML的模板系统，

36
00:01:57,117 --> 00:02:00,117
我马上就会向大家介绍这个系统，此外如果你遵循MVC， 

37
00:02:00,000 --> 00:02:04,120
这些模板视图会怎样工作呢。

38
00:02:04,124 --> 00:02:08,124
你可采用表达HTML的模板语言，抑或者

39
00:02:08,128 --> 00:02:11,128
无论你想要什么模板，你都可以使用一个闭包。

40
00:02:11,131 --> 00:02:13,131
我们讲过闭包。现在这又再次出现了。

41
00:02:13,133 --> 00:02:16,133
闭包是大家的朋友。为什么这么说呢，因为闭包

42
00:02:16,136 --> 00:02:19,136
是含有多个状态的环境，包括

43
00:02:19,139 --> 00:02:22,139
你随后插入视图的变量值等等。

44
00:02:22,142 --> 00:02:26,142
在Rails的例子中，有一个Rails模块叫做

45
00:02:26,146 --> 00:02:29,146
动作视图模块。它含有可实现这一点的渲染逻辑。

46
00:02:29,149 --> 00:02:33,149
在你插入其他数据与固定标记时，它可以结合固定标记。

47
00:02:33,153 --> 00:02:35,153
基本上你要做的就是在闭包时传递它，

48
00:02:35,155 --> 00:02:39,155
我一会儿就向你们证明这一点，

49
00:02:39,159 --> 00:02:42,159
渲染输出是准备好向终端客户提供的最终HTML页面。

50
00:02:42,162 --> 00:02:46,162
还有另一个模板系统，这实际上就是真正的Rails标配，

51
00:02:46,166 --> 00:02:48,166
称为ERB或嵌入式Ruby。

52
00:02:48,168 --> 00:02:51,168
我们不会使用它，因为大家都知道，

53
00:02:51,171 --> 00:02:53,171
我有强迫症，一定要在页面上用最少的标记完成操作，

54
00:02:53,173 --> 00:02:57,173
同时我要证明

55
00:02:57,177 --> 00:03:00,177
HAML在这方面效果更好，不过ERB可携带Ruby，

56
00:03:00,000 --> 00:03:04,180
从本质上看，它很像PHP， 

57
00:03:04,184 --> 00:03:07,184
你可以默认把HTML内容放在那儿，不过你可以使用一个方法，说明

58
00:03:07,187 --> 00:03:11,187
这部分内容会替代某个Ruby代码

59
00:03:11,191 --> 00:03:13,191
的运行结果或插入Ruby的变量值。

60
00:03:13,193 --> 00:03:18,193
同样，无论你是否做出架构选择，

61
00:03:18,198 --> 00:03:21,198
你都会选择排除其他某个选项。

62
00:03:21,201 --> 00:03:24,201
如果不做模板视图，你要做什么？

63
00:03:24,204 --> 00:03:26,204
另一个方法是你得到只是更为基础的变换视图。

64
00:03:26,206 --> 00:03:29,206
在变换视图中，你有说明闭包的信息

65
00:03:29,209 --> 00:03:32,209
集合，而闭包可表示你们想要向用户显示的内容，

66
00:03:32,212 --> 00:03:38,212
同时你还有一堆数据项，

67
00:03:38,218 --> 00:03:42,218
事实上没有填入其中的中间模板。

68
00:03:42,222 --> 00:03:45,222
{例如，你可以使用这个方法。}

69
00:03:45,225 --> 00:03:47,225
假定你实际做的是生成Jsigner或XML，

70
00:03:47,227 --> 00:03:50,227
这两者都是我们课上稍后要讲的内容，

71
00:03:50,230 --> 00:03:52,230
但是应用程序与网络上存在

72
00:03:52,232 --> 00:03:56,232
可移动的其他数据表示。

73
00:03:56,236 --> 00:03:58,236
此时，设一个填空型模板其实没有什么意义，

74
00:03:58,238 --> 00:04:00,238
大家实际做的是把数据填入一个表格

75
00:04:00,000 --> 00:04:04,240
，也就是数据在数据库内存储的方式， 

76
00:04:04,244 --> 00:04:07,244
然后将其转换或序列化成不同的表格，像XML，

77
00:04:07,247 --> 00:04:10,247
之后你会将表格传输至其他服务。所以模板的想法

78
00:04:10,250 --> 00:04:12,250
在这个例子里其实没什么实际意义。

79
00:04:12,252 --> 00:04:15,252
这不过是从一种格式向另一种格式的转换而已，因此名为转换视图。

80
00:04:15,255 --> 00:04:18,255
所以，事实上，这两者我们都可使用。

81
00:04:18,258 --> 00:04:21,258
我们创建应用程序，把应用程序想成服务集合，

82
00:04:21,261 --> 00:04:25,261
在用户与该服务集合互动时，使用模板视图，

83
00:04:25,265 --> 00:04:28,265
这是因为我们想向用户提供HTML页面， 

84
00:04:28,268 --> 00:04:32,268
除其他程序访问同一服务组时外， 

85
00:04:32,272 --> 00:04:34,272
人们可与该页面互动。换言之，

86
00:04:34,274 --> 00:04:37,274
我们参与面向服务的架构时，实际上我们不会

87
00:04:37,277 --> 00:04:40,277
使用变换视图之类的东西，这样我们就可以

88
00:04:40,280 --> 00:04:43,280
向其他服务反馈原始数据的变换版本，

89
00:04:43,283 --> 00:04:45,283
我们会举例说明

90
00:04:45,285 --> 00:04:48,285
你如何只改一行就让控制器方法

91
00:04:48,288 --> 00:04:56,288
完成双重任务。我们建议大家

92
00:04:56,296 --> 00:05:00,296
使用的标记系统称为HAML，在本课练习

93
00:05:00,000 --> 00:05:04,300
中会用到这个系统。我觉得它代表HTML

94
00:05:04,304 --> 00:05:09,304
抽象标记语言，不过创造程序的名称

95
00:05:09,309 --> 00:05:11,309
实在很像缩写词HAML，所以大家要仔细看看。

96
00:05:11,311 --> 00:05:16,311
这真的很有趣。我想这就是节食的HTML。

97
00:05:16,316 --> 00:05:20,316
相比于常规的HTML，HAML有哪些突出功能呢？

98
00:05:20,320 --> 00:05:24,320
替代使用尖括号的HTML标签， 我们使用百分号

99
00:05:24,324 --> 00:05:27,324
表示标签，此外我们使用缩排代替嵌套标签。

100
00:05:27,327 --> 00:05:30,327
如果你使用Python编过程序，对此应该非常熟悉。

101
00:05:30,330 --> 00:05:33,330
缩排等级会告诉你每个标签的范围有多大。

102
00:05:33,333 --> 00:05:38,333
在此举个例子，我有个表格。

103
00:05:38,338 --> 00:05:41,338
Thead元素的范围是什么。基本上所有都归结于这一点，因为

104
00:05:41,341 --> 00:05:44,341
这就是缩排等级继续的所在，

105
00:05:44,344 --> 00:05:47,344
整个表格一直写下去直写到说明链接的最后一行前。

106
00:05:47,347 --> 00:05:50,347
所以缩排是用来表现范围的。

107
00:05:50,350 --> 00:05:55,350
我们还看到页面样式大量运用CSS属性

108
00:05:55,355 --> 00:05:58,355
或HTML属性类与ID，所以

109
00:05:58,358 --> 00:06:02,358
HAML提供一个不错的捷径，借助它，你可以

110
00:06:02,362 --> 00:06:06,362
在元素上加入一点与CSS类，又或者你可以

111
00:06:06,366 --> 00:06:11,366
在元素上加入散列标记与CSS ID。

112
00:06:11,371 --> 00:06:16,371
在此例子中，你可以将代码插入HTML或HAML内。

113
00:06:16,376 --> 00:06:18,376
你可以在一行前设连字符，表示执行此代码，

114
00:06:18,378 --> 00:06:21,378
或者在一行前设等号，表示代替

115
00:06:21,381 --> 00:06:24,381
直接在模板内运行的此代码结果。

116
00:06:24,384 --> 00:06:28,384
这两者之间有什么不同？在这个例子中，对于电影标题

117
00:06:28,388 --> 00:06:31,388
我想要切实恢复它的字符串表示，

118
00:06:31,391 --> 00:06:35,391
同时做出页面的这一部分，

119
00:06:35,395 --> 00:06:38,395
然而现实中我要做的只有在这行开始For循环而已。

120
00:06:38,398 --> 00:06:41,398
我开始迭代了。迭代本身

121
00:06:41,401 --> 00:06:44,401
没有什么有趣可供捕捉的输出。所以，

122
00:06:44,404 --> 00:06:47,404
借助它，你可以实现这两点。连字号表示不要

123
00:06:47,407 --> 00:06:50,407
窜改、只运行代码的输出。等号表示插入输出，

124
00:06:50,410 --> 00:06:54,410
如果在一个以上的行内出现代码过剩，

125
00:06:54,414 --> 00:06:57,414
你可以在末尾使用立管符号表示

126
00:06:57,417 --> 00:07:00,417
存在多个代码行。使用HAML就不方便进行查看，

127
00:07:00,000 --> 00:07:03,420
这是因为实际操作中你根本

128
00:07:03,423 --> 00:07:06,423
不该把代码放到视图里。代码根本不属于

129
00:07:06,426 --> 00:07:09,426
MVC这部分，这部分的作用是向用户显示信息。

130
00:07:09,429 --> 00:07:12,429
代码属于模型内的控制器，

131
00:07:12,432 --> 00:07:15,432
大多处于模型内。所以HAML 可以

132
00:07:15,435 --> 00:07:18,435
对此稍稍做些社会工程设计，不过这有点超出它的使用方式。

133
00:07:18,438 --> 00:07:21,438
要做多行位的代码真的很不方便，这是因为

134
00:07:21,441 --> 00:07:24,441
它会向你发送信号，可那个代码却在它本不该出现的

135
00:07:24,444 --> 00:07:30,444
位置。所以我之前说，不要把代码放入你们的视图。

136
00:07:30,450 --> 00:07:33,450
不要把代码放入视图。从技术上讲你可以这么做，

137
00:07:33,453 --> 00:07:37,453
不过事实上按照HAML内的多行机制，

138
00:07:37,457 --> 00:07:41,457
你可以把等同于Ruby代码的整个内容放进去，

139
00:07:41,461 --> 00:07:45,461
只不过MVC提倡视图与控制器均应保持简短。

140
00:07:45,465 --> 00:07:48,465
视图在实际使用中功能有限。

141
00:07:48,468 --> 00:07:50,468
它的作用就是向用户展示信息。如果视图正在操作或操纵

142
00:07:50,470 --> 00:07:53,470
该信息，你就要自己想一想它为什么这么做了。

143
00:07:53,473 --> 00:07:57,473
这样做的原因可能是新计算在处理该信息，不过

144
00:07:57,477 --> 00:08:00,477
这个信息颇为有趣，本该是模型的组成部分，因为模型

145
00:08:00,000 --> 00:08:03,480
处理的正是管理

146
00:08:03,483 --> 00:08:06,483
的信息储存或操纵方法。

147
00:08:06,486 --> 00:08:08,486
你这样做只是为了使它看上去更美观。例如

148
00:08:08,488 --> 00:08:11,488
如果你想要显示价格，而它却作为浮点数回来了，

149
00:08:11,491 --> 00:08:13,491
这时你想要设一个金额符号还有小数位的正确数字，

150
00:08:13,493 --> 00:08:16,493
有一个名为辅助项的东西，基本上就是

151
00:08:16,496 --> 00:08:18,496
放置各种视图方法的专门位置，其中各种方法除了

152
00:08:18,498 --> 00:08:22,498
辅助美化视图内容外别无它用。

153
00:08:22,502 --> 00:08:24,502
它们对制作模型并不重要，

154
00:08:24,504 --> 00:08:27,504
它们对你处理数据的任何计算而言也不重要。它们的作用只是

155
00:08:27,507 --> 00:08:29,507
让你无需在视图内放置杂乱的代码，所以

156
00:08:29,509 --> 00:08:32,509
辅助项还应保持较小的尺寸。像我之前提到的，这儿还存在

157
00:08:32,512 --> 00:08:35,512
嵌入式Ruby模板。它们看上去更像是PHP，

158
00:08:35,515 --> 00:08:38,515
这一切本身就是个不去使用它们的原因，不过使用HAML的真实原因是，

159
00:08:38,518 --> 00:08:41,518
它在页面上留下的记号较少。更易于遵循缩排。

160
00:08:41,521 --> 00:08:43,521
更易于查错，而且一旦你习惯了，

161
00:08:43,523 --> 00:08:46,523
它就像读俳句一样简练。你会迷上这份优雅的。

162
00:08:46,526 --> 00:08:48,526
所以我建议使用它。


