1
00:00:00,000 --> 00:00:02,000
我们接下来要讲难看的代码，你们可能

2
00:00:02,002 --> 00:00:04,002
不会—但愿你们不会耗费大量时间来讲这些。

3
00:00:04,004 --> 00:00:08,004
在正确的基础上我们还能做什么？

4
00:00:08,008 --> 00:00:14,008
我们能探讨代码之美吗？在如何编写美丽的代码方面

5
00:00:14,014 --> 00:00:18,014
有什么指导规则吗？我们能否切实评估代码的质量？

6
00:00:18,018 --> 00:00:23,018
我们能否定量评估？这些工具有什么作用， 

7
00:00:23,023 --> 00:00:26,023
这些指标又有什么作用？然后，我们有哪些工具可以帮助我们

8
00:00:26,026 --> 00:00:30,026
实现这一点？这就是我们的引导问题了。

9
00:00:30,030 --> 00:00:32,030
我们要从气味开始讲。我们要讲气味。

10
00:00:32,032 --> 00:00:36,032
代码闻起来很有趣吗？这实际上涉及相关的技术概念， 

11
00:00:36,036 --> 00:00:42,036
人们写了这些有关异味代码的书籍。

12
00:00:42,042 --> 00:00:47,042
视你参考的内容而定，有20种常见错误， 

13
00:00:47,047 --> 00:00:51,047
代码气味，[代码异味 60 00:51]，取决于

14
00:00:51,051 --> 00:00:55,051
你对此采取的操作。我们会提前给大家一些例子，

15
00:00:55,055 --> 00:00:59,055
不过我想要大家理解的是避免异味代码的方法。

16
00:00:59,059 --> 00:01:04,059
我们使用缩写词SOFA。首先，这很短吗？

17
00:01:04,064 --> 00:01:06,064
我们要一次一个方法来进行讲解，

18
00:01:06,066 --> 00:01:10,066
所以保证方法简短就不太可能会产生异味代码。

19
00:01:10,070 --> 00:01:14,070
是只做一件事还是做很多事？

20
00:01:14,074 --> 00:01:18,074
一个方法是只有少数参数还是有很多参数？

21
00:01:18,078 --> 00:01:22,078
最后，代码是在同一抽象层面上的吗？很可能

22
00:01:22,082 --> 00:01:26,082
出现异味代码违反上述数项规定的情况， 

23
00:01:26,086 --> 00:01:30,086
而这些规定会使你的代码气味更芬芳。开始时要保证简短。

24
00:01:30,090 --> 00:01:34,090
简短表示什么？过去，

25
00:01:34,094 --> 00:01:37,094
终端就是24行，初级字符，所以尽数简短表示适合一个满屏显示。

26
00:01:37,097 --> 00:01:41,097
如今使用现代的大型显示器，

27
00:01:41,101 --> 00:01:44,101
你可以得到数百行代码。

28
00:01:44,104 --> 00:01:48,104
在大型显示器上的一个满屏显示并不短。

29
00:01:48,108 --> 00:01:53,108
这让你可以扫一眼代码，确定它在做什么。对此有一个工具。

30
00:01:53,113 --> 00:01:57,113
因为这涉及气味，所以称为Reek（臭气捕集）。臭气捕集负责

31
00:01:57,117 --> 00:02:01,117
为你捕获异味。单个提取级算是个抽象概念。

32
00:02:01,121 --> 00:02:05,121
它不会在一个任务中一次性完成所有工作。

33
00:02:05,125 --> 00:02:08,125
这儿有个任务，我要把它全数投入一个大方法内。

34
00:02:08,128 --> 00:02:11,128
你也可以试着分割解决，可是

35
00:02:11,131 --> 00:02:14,131
在你必须让它们处于相同的抽象层面。

36
00:02:14,134 --> 00:02:18,134
通常可以通过调用其他方法来达到这个标准，不过

37
00:02:18,138 --> 00:02:21,138
所有调用的方法均处于相同的复杂级。

38
00:02:21,141 --> 00:02:25,141
这很像是编写良好的新闻内容。

39
00:02:25,145 --> 00:02:29,145
如果你上过英语课或想成为一名通讯员，

40
00:02:29,149 --> 00:02:33,149
你一开始要做个不错的摘要，然后每一段都是更为详细的要点。

41
00:02:33,153 --> 00:02:36,153
相对于每一段都要有个确切的话题，

42
00:02:36,156 --> 00:02:39,156
样式较为散漫，可以在多个想法间来回切换。

43
00:02:39,159 --> 00:02:43,159
单级方法就是策划

44
00:02:43,163 --> 00:02:46,163
进行中的所有内容。这是

45
00:02:46,166 --> 00:02:50,166
单个提取级后要尝试的数个目标之一。

46
00:02:50,170 --> 00:02:53,170
谁会介意大量参数？首先，如果有很多许多参数，

47
00:02:53,173 --> 00:02:57,173
就很难确保测试涵盖所有内容。如果

48
00:02:57,177 --> 00:03:00,177
你真要用测试涵盖许多不同的内容，

49
00:03:00,000 --> 00:03:04,180
那么就会变得非常困难。同时，大量参数

50
00:03:04,184 --> 00:03:07,184
也会导致mock与stub变得困难，

51
00:03:07,187 --> 00:03:11,187
所以你可以隔离设计的各个部分以便

52
00:03:11,191 --> 00:03:15,191
采取不同的测试。有一种布尔变量的用法非常危险:

53
00:03:15,195 --> 00:03:19,195
你把布尔标识符作为参数之一，用其值来区分调用

54
00:03:19,199 --> 00:03:22,199
两个(本该分开的)方法中的哪个，出于某种原因， 

55
00:03:22,202 --> 00:03:25,202
其中一个方法很容易被调用

56
00:03:25,205 --> 00:03:28,205
而另一个方法实在很难生成数据来调用它。

57
00:03:28,208 --> 00:03:32,208
我们要避免这种情况。另一点是

58
00:03:32,212 --> 00:03:35,212
会有一堆参数结成一个包被传递于一堆方法之间。

59
00:03:35,215 --> 00:03:39,215
如果发生这种事，你应该提取他们，然后创建一个新类，

60
00:03:39,219 --> 00:03:42,219
这样你就不会漏过这些参数，

61
00:03:42,222 --> 00:03:46,222
而漏过[无声03:44]。

62
00:03:46,226 --> 00:03:51,226
让我们看一下这里的异味程序。这是一个真实的程序，

63
00:03:51,231 --> 00:03:54,231
在书中发现了[阿曼多 03:52]，这就是它。

64
00:03:54,234 --> 00:03:57,234
你在那儿看着它，多少会盯着这个东西，

65
00:03:57,237 --> 00:04:03,237
你会看见像y与d之类的字母。如果你的母语是英语， 

66
00:04:03,243 --> 00:04:06,243
你就会想，“哎呀，这会是什么意思呢？”

67
00:04:06,246 --> 00:04:09,246
然后你看到像365这样的数字，如果你使用的格里历里365是个数字，

68
00:04:09,249 --> 00:04:13,249
所以这可能表示年或类似的什么。

69
00:04:13,253 --> 00:04:16,253
现在，实际上，这个程序真的有个错误。

70
00:04:16,256 --> 00:04:20,256
这很难发现……你甚至不知道

71
00:04:20,260 --> 00:04:23,260
它是做什么的，更别提程序错误是什么了。

72
00:04:23,263 --> 00:04:26,263
我们将它通过臭气捕集时，臭气捕集就是这个查找异味的东西，

73
00:04:26,266 --> 00:04:29,266
鉴于此定性评估，它会就这个程序说什么呢？

74
00:04:29,269 --> 00:04:35,269
它首先违背了DRY机理。

75
00:04:35,275 --> 00:04:39,275
不要自我重复。它说的是，这个y+1在这里用了两次。

76
00:04:39,279 --> 00:04:43,279
在这些if与else语句中每个结尾都是相同的语句，

77
00:04:43,283 --> 00:04:46,283
你做了两次，可以去掉一次。

78
00:04:46,286 --> 00:04:49,286
它的第二个错误是方法过长。

79
00:04:49,289 --> 00:04:54,289
长度是多少以旁观者的角度确定的。现在Ruby代码非常强大，

80
00:04:54,294 --> 00:04:57,294
所以即便是像这样的一堆语句

81
00:04:57,297 --> 00:05:00,297
也嫌太长。其中很大一部分是这种内嵌的if语句。

82
00:05:00,000 --> 00:05:03,300
这有点难以发觉。它暗示这多少算是个长方法。

83
00:05:03,303 --> 00:05:06,303
第三个错误是这些单字母变量名称，

84
00:05:06,306 --> 00:05:10,306
这两个都作为参数出现，然后在while循环内又再次出现。

85
00:05:10,310 --> 00:05:16,310
看这个15行的小方法。

86
00:05:16,316 --> 00:05:19,316
臭气捕集提出有一堆东西气味奇怪。

87
00:05:19,319 --> 00:05:23,319
如果你不说英语的或者你使用的

88
00:05:23,323 --> 00:05:25,323
是犹太古历或别的什么，那么这些数字，你可能猜不出

89
00:05:25,325 --> 00:05:30,325
这些东西有什么含义。

90
00:05:30,330 --> 00:05:33,330
这就是用工具来对程序进行定性判断。

91
00:05:33,333 --> 00:05:36,333
那么定量判断呢？人们试着做什么呢，在这个……我们要创建的

92
00:05:36,336 --> 00:05:39,336
软件工程，是否有一些工具让我们可以

93
00:05:39,339 --> 00:05:42,339
看源程序本身来统计一些内容从而尝试

94
00:05:42,342 --> 00:05:46,342
测定复杂度。这类内容中最古老的一个

95
00:05:46,346 --> 00:05:50,346
名为ABC复杂性，这是赋值、分支与条件

96
00:05:50,350 --> 00:05:54,350
的函数。查看大量程序、大量子程序、

97
00:05:54,354 --> 00:05:57,354
及尝试确定复杂内容的方法

98
00:05:57,357 --> 00:06:00,357
是某人想到的公式，“好啦，让我们……

99
00:06:00,000 --> 00:06:02,360
我们要将赋值次数开平方，将

100
00:06:02,362 --> 00:06:05,362
分支次数开平方，将条件次数开平方， 

101
00:06:05,365 --> 00:06:07,365
取其平方根，然后这就是

102
00:06:07,367 --> 00:06:11,367
复杂度的数量测度。”

103
00:06:11,371 --> 00:06:13,371
不管你信不信，国家标准研究所(看上去

104
00:06:13,373 --> 00:06:15,373
这还有很多其他事情要处理)他们得出了

105
00:06:15,375 --> 00:06:19,375
（大笑）政府合同的衡量标准，其中谈到你要

106
00:06:19,379 --> 00:06:21,379
做的就是确保你的方法—不得太过复杂。

107
00:06:21,381 --> 00:06:25,381
对于方法，所有值的平方根应当低于20，

108
00:06:25,385 --> 00:06:29,385
有待政府批准的方法就这要求。（大笑不止）

109
00:06:29,389 --> 00:06:33,389
Rails自然没问题，因为它很简单。Rails环境有趣在哪里呢，

110
00:06:33,393 --> 00:06:36,393
因为要构建软件很简单，还有它……

111
00:06:36,396 --> 00:06:38,396
你在为程序员构建软件。程序员会为程序员制作工具。

112
00:06:38,398 --> 00:06:42,398
这儿有个程序名为Flog，

113
00:06:42,402 --> 00:06:47,402
它会自动计算Ruby方法的ABC复杂度。

114
00:06:47,407 --> 00:06:51,407
最为大家熟知的数量测度名为秩数复杂度。

115
00:06:51,411 --> 00:06:54,411
我们的想法是视图确定通过方法的独

116
00:06:54,414 --> 00:06:57,414
立路径有多少个，因为

117
00:06:57,417 --> 00:06:59,417
这会告诉你，你需要写哪些测试

118
00:06:59,419 --> 00:07:02,419
才能覆盖所有方法。同时，有人……

119
00:07:02,422 --> 00:07:06,422
这家伙是……他的名字是查尔斯•麦凯布；他在近40年前就这样做。

120
00:07:06,426 --> 00:07:11,426
他创造出此复杂度。它的公式是，“让我们

121
00:07:11,431 --> 00:07:15,431
聊聊这些节点吧，”不过节点是基础块，不是吗？

122
00:07:15,435 --> 00:07:17,435
一个分支进，一个分支出，在它们内部不存在分支。

123
00:07:17,437 --> 00:07:21,437
让我们数数这里面有多少节点。边缘位于节点间，

124
00:07:21,441 --> 00:07:24,441
这就是那儿的边缘，然后连通分支

125
00:07:24,444 --> 00:07:29,444
是彼此附近相连的这些东西。

126
00:07:29,449 --> 00:07:33,449
这个外形很小的查尔斯•麦凯布复杂度

127
00:07:33,453 --> 00:07:38,453
或秩数复杂度是九个边、八个节点以及

128
00:07:38,458 --> 00:07:41,458
一个连通分支。你像这样拉过它时，你就

129
00:07:41,461 --> 00:07:44,461
会得到连接三块的连通分支。

130
00:07:44,464 --> 00:07:47,464
按照国家测试标准研究所的规定，

131
00:07:47,467 --> 00:07:49,467
每模块的值都应该小于10.

132
00:07:49,469 --> 00:07:55,469
同样，在Rails社区内，有一个工具Saikuro，

133
00:07:55,475 --> 00:08:00,475
可以为你计算秩数复杂度。让我们开始……

134
00:08:00,000 --> 00:08:03,480
我们要看看第一个方法，回头看。

135
00:08:03,483 --> 00:08:06,483
基本上我们只讲定量测量。

136
00:08:06,486 --> 00:08:09,486
这些并非万无一失的方法，如果你评分不佳，这就是个坏方法。

137
00:08:09,489 --> 00:08:13,489
这暗示了可能有异味代码存在。

138
00:08:13,493 --> 00:08:17,493
如你试验这一堆方法，臭气捕集与Flog及Saikuro

139
00:08:17,497 --> 00:08:20,497
全部表示数值过大，或者给你很多警告， 

140
00:08:20,500 --> 00:08:22,500
你大概该花时间看看这些，然后想想对此你可做什么。

141
00:08:22,502 --> 00:08:25,502
当然也有其他工具(来做这些)。

142
00:08:25,505 --> 00:08:30,505
我们讲过测试中的简单覆盖，所有语句都要执行吗？

143
00:08:30,510 --> 00:08:33,510
这就是CO覆盖，阿曼多前一阵子讲过。

144
00:08:33,513 --> 00:08:37,513
在你的项目与工具中，SimpleCov就是完成该操作的工具。

145
00:08:37,517 --> 00:08:41,517
你的目标是实现90%以上的简单覆盖度。

146
00:08:41,521 --> 00:08:45,521
这里的Rake Stats实际上讲的是代码的测试比例。

147
00:08:45,525 --> 00:08:48,525
我们今天会讲到，测试驱动开发与行为

148
00:08:48,528 --> 00:08:52,528
驱动开发中很大部分均含有大量相关

149
00:08:52,532 --> 00:08:54,532
测试。正确的比例是，

150
00:08:54,534 --> 00:09:00,534
测试代码应该是执行代码的两倍。

151
00:09:00,000 --> 00:09:03,540
让我们看一看这个程序，实际上做的是

152
00:09:03,543 --> 00:09:07,543
某个闰年计算。ABC复杂度、赋值、分支、

153
00:09:07,547 --> 00:09:11,547
条件，得到分数23，这高于国家测试

154
00:09:11,551 --> 00:09:15,551
标准研究所的规定，所以这暗示存在问题。

155
00:09:15,555 --> 00:09:19,555
代码复杂度分数小于10。它不很复杂—

156
00:09:19,559 --> 00:09:23,559
这是几个条件，如果有语句that的话，

157
00:09:23,563 --> 00:09:26,563
没有大量并行传递，同时数值显示

158
00:09:26,566 --> 00:09:30,566
这并不是问题。我们要怎样解决？让我们看一遍。

159
00:09:30,570 --> 00:09:35,570
首先，我们确信d是天，而y就是年。

160
00:09:35,575 --> 00:09:40,575
我们把它放在这儿。我们执行闰年计算，

161
00:09:40,580 --> 00:09:43,580
我们用"leap?"方法来判断是否是闰年，

162
00:09:43,583 --> 00:09:46,583
它会返回布尔值。继续观察发现，

163
00:09:46,586 --> 00:09:49,586
我们已经把它拆分成独立的专用方法。

164
00:09:49,589 --> 00:09:52,589
我们用臭气捕集来处理它，

165
00:09:52,592 --> 00:09:56,592
之前有六个警告，警告中有一个说它过长， 

166
00:09:56,596 --> 00:10:02,596
同时变量名称无法通信，我不记得另一个是什么了，

167
00:10:02,602 --> 00:10:07,602
不过现在所有警告都消失了。现在的ABC复杂度， 

168
00:10:07,607 --> 00:10:11,607
不同于之前高于20的数值，每个方法都降到10左右， 

169
00:10:11,611 --> 00:10:15,611
而Saikuro数值低于该值。这个代码直观

170
00:10:15,615 --> 00:10:18,615
上更容易搞明白正在进行什么。你们问这是不是个闰年时， 

171
00:10:18,618 --> 00:10:23,618
大家都直觉猜到这儿在发生什么，这很好。

172
00:10:23,623 --> 00:10:25,623
好啦，所以这有点……你们应该想想用Ruby实现这一点。

173
00:10:25,625 --> 00:10:30,625
下次作业会包含这些工具。

174
00:10:30,630 --> 00:10:34,630
我们不会就这个评分，

175
00:10:34,634 --> 00:10:36,634
不过我们会让大家看看工具[无声 10:35]是什么。

176
00:10:36,636 --> 00:10:38,636
等到要做本课内的项目时，

177
00:10:38,638 --> 00:10:41,638
我们会对大家的代码运用这些工具，从而帮助你

178
00:10:41,641 --> 00:10:43,641
提高编写内容的质量。

