1
00:00:00,000 --> 00:00:04,000
接下来在我们的一系列课题中，我们要再一次用问题激发大家，

2
00:00:04,004 --> 00:00:07,004
为什么你们要注意数据库与活动记录，

3
00:00:07,007 --> 00:00:10,007
这我接下来就会讲。这就是本节课要解决的问题。

4
00:00:10,010 --> 00:00:13,010
到目前为止，我们讲目标倾向与如何

5
00:00:13,013 --> 00:00:15,013
组织各类时，顺带讲了各类，

6
00:00:15,015 --> 00:00:19,015
运用实例时又提到实例可含有属性。

7
00:00:19,019 --> 00:00:22,019
这是面向记录看待世界的方法。

8
00:00:22,022 --> 00:00:26,022
我们手边就有一些实例，例如银行账户，每个实例都有

9
00:00:26,026 --> 00:00:29,026
与之关联的一些属性。在我们的网络应用程序中，我们得

10
00:00:29,029 --> 00:00:31,029
能在某处存储这种数据，我们得能

11
00:00:31,031 --> 00:00:34,031
检索搜索到该数据。这就意味着

12
00:00:34,034 --> 00:00:37,034
在数据存储方式与以编程语言操纵

13
00:00:37,037 --> 00:00:39,037
数据的方式之间存在某种联系。

14
00:00:39,039 --> 00:00:42,039
为解决这个问题，人们已尝试了很多方法

15
00:00:42,042 --> 00:00:45,042
创建该映射，进而采用不同的思考方式，

16
00:00:45,045 --> 00:00:48,045
考虑我们应如何组织存储数据。

17
00:00:48,048 --> 00:00:53,048
回到我们的图解上来，我们今天从哪儿开始？我们还要继续探讨

18
00:00:53,053 --> 00:00:56,053
这里的应用程序结构，然后我们要看看

19
00:00:56,056 --> 00:00:59,056
在Rails结构中怎样处理模型视图控制器的模型部分。

20
00:00:59,059 --> 00:01:02,059
同样，除了Rails发送消息这一方法外，

21
00:01:02,062 --> 00:01:05,062
我还要介绍多个方法，

22
00:01:05,065 --> 00:01:07,065
Rails以这样的方式进行处理，不表示这就是

23
00:01:07,067 --> 00:01:12,067
适合所有应用程序的方法。我们

24
00:01:12,072 --> 00:01:16,072
讲讲存储器内对象与你存储的对象之间的关系。我们已经讲过了，

25
00:01:16,076 --> 00:01:18,076
你创建新类与用Ruby创建这些类的新实例时，

26
00:01:18,078 --> 00:01:21,078
很显然对于这些对象

27
00:01:21,081 --> 00:01:24,081
及其属性存在部分内存表达。

28
00:01:24,084 --> 00:01:28,084
这里的问题是，“你要如何表达存储的

29
00:01:28,088 --> 00:01:30,088
这个对象，才能在之后如数拿回、重组？”

30
00:01:30,090 --> 00:01:33,090
这就好像你要

31
00:01:33,093 --> 00:01:35,093
存储设备，关闭操纵该对象的程序，

32
00:01:35,095 --> 00:01:39,095
之后才意识到，你可以重启程序、读回对象，

33
00:01:39,099 --> 00:01:42,099
而不致损失任何信息。

34
00:01:42,102 --> 00:01:45,102
一般说来，这一操作过程就叫做编列。

35
00:01:45,105 --> 00:01:48,105
又称串行化。在区别与含义方面存在微妙的细微差别，

36
00:01:48,108 --> 00:01:50,108
不过我们不需为此担心。

37
00:01:50,110 --> 00:01:53,110
我们的想法是，如果我编列对象，这表示我

38
00:01:53,113 --> 00:01:56,113
将对象转换为新格式，这样它就能适合某些操作。

39
00:01:56,116 --> 00:01:59,116
通常，这里的操作指存储或向其他地方传输。

40
00:01:59,119 --> 00:02:03,119
我这样做是为了以后，我可以解编列

41
00:02:03,123 --> 00:02:06,123
或解串，然后以我自己的语言取回表达，

42
00:02:06,126 --> 00:02:09,126
在各个功能方式或各个行为方式上，

43
00:02:09,129 --> 00:02:13,129
我取回的东西等同于我一开始时处理的东西。

44
00:02:13,133 --> 00:02:15,133
在我们的示例中，我们讲到，例如，含有像名称与额定值之类属性的电影。

45
00:02:15,135 --> 00:02:18,135
我们要怎样实现该电影的内存表达，

46
00:02:18,138 --> 00:02:22,138
再在某个地方存储起来？尤其是，

47
00:02:22,142 --> 00:02:25,142
我们要做的操作，我们每次讲到管理存储的数据，

48
00:02:25,145 --> 00:02:28,145
都要创建某个东西的新副本。在我们的这个例子中，

49
00:02:28,148 --> 00:02:31,148
我们在这里的永久层，读取之前存储对象的现有副本，

50
00:02:31,151 --> 00:02:35,151
我们可以进行更新。例如，我们可以更改

51
00:02:35,155 --> 00:02:37,155
电影的名字，如果要做永久性的更改，

52
00:02:37,157 --> 00:02:39,157
我们就要从永久性的存储中删除一些东西。

53
00:02:39,159 --> 00:02:43,159
总地说来，这些都是CRUD增加、查询、更新、删除操作。Rails组织模型的方式

54
00:02:43,163 --> 00:02:46,163
取决于另一个名为活动记录的设计模式，

55
00:02:46,166 --> 00:02:49,166
主要优势在于像电影的每个模型、

56
00:02:49,169 --> 00:02:53,169
每种类型都能借助各式模型共享的一套通用机制

57
00:02:53,173 --> 00:02:56,173
自行完成增加、查询、更新、删除操作。

58
00:02:56,176 --> 00:03:00,176
如你来自，打个比方说，PHP世界，那里的对象会表达数据库的连接，

59
00:03:00,000 --> 00:03:03,180
这你已经司空见惯了吧。

60
00:03:03,183 --> 00:03:06,183
你创建查询和这样的东西，

61
00:03:06,186 --> 00:03:09,186
你可以把它移送到那个对象上。活动记录的考虑角度就颇为不同。

62
00:03:09,189 --> 00:03:13,189
程序员不会……没法切实看到明显阻塞，即

63
00:03:13,193 --> 00:03:16,193
数据库。阻塞是，

64
00:03:16,196 --> 00:03:18,196
你可以对这类对象采取的操作集合。

65
00:03:18,198 --> 00:03:21,198
而这恰好就是有待在数据库内存储的对象。

66
00:03:21,201 --> 00:03:24,201
对此我们会单独做更多讲解，不过

67
00:03:24,204 --> 00:03:26,204
从活动记录的角度看，存在通用的一组工具，

68
00:03:26,206 --> 00:03:30,206
借助这组工具，任何类型的活动记录对象都可以完成这些基础操作。

69
00:03:30,210 --> 00:03:35,210
在Rails示例中，我想多年前，

70
00:03:35,215 --> 00:03:37,215
我们都认为，关系数据库在存储方式上绝对是佼佼者，多数

71
00:03:37,217 --> 00:03:41,217
网络应用程序都采用这种方式存储数据。

72
00:03:41,221 --> 00:03:45,221
大体说来，在关系数据库内，我们的每种模型在这个数据库内都有

73
00:03:45,225 --> 00:03:48,225
自己的表格。表格内所有行

74
00:03:48,228 --> 00:03:50,228
均具有相同结构。这是关系数据库

75
00:03:50,230 --> 00:03:54,230
的内容包与组成部分。表格中每一行都是特定模型、类

76
00:03:54,234 --> 00:03:57,234
的一个实例……特定模型类。

77
00:03:57,237 --> 00:04:01,237
由于每行都是一个模型实例， 

78
00:04:01,241 --> 00:04:04,241
列自然就是属性， 

79
00:04:04,244 --> 00:04:07,244
每列都存有属性值。每列还含有唯一的主键。

80
00:04:07,247 --> 00:04:11,247
按照惯例，在Rails中，这是一个整数，称为ID。

81
00:04:11,251 --> 00:04:16,251
别让这个把你搞糊涂了。ID不是实际的电影属性、

82
00:04:16,256 --> 00:04:20,256
Ruby中的对象，不过

83
00:04:20,260 --> 00:04:22,260
它会成为存储在数据库内的电影属性、对象。

84
00:04:22,262 --> 00:04:25,262
这个例子说明阻塞并非尽善尽美。

85
00:04:25,265 --> 00:04:28,265
我们在讲的是，想要在数据库内的内存

86
00:04:28,268 --> 00:04:31,268
对象与对象之间建立映射，可实际上，

87
00:04:31,271 --> 00:04:33,271
它们并不相同。

88
00:04:33,273 --> 00:04:37,273
他们存在几个不同之处。像我们看到的那样， 

89
00:04:37,277 --> 00:04:39,277
之所以有这些差别是因为数据库对对象的操纵方式， 

90
00:04:39,279 --> 00:04:42,279
与你允许数据库这么做的阐述，

91
00:04:42,282 --> 00:04:46,282
这两者间存在一定的重叠，不过并非完全重叠，

92
00:04:46,286 --> 00:04:48,286
同时Ruby想要怎样操纵对象，

93
00:04:48,288 --> 00:04:51,288
你又想要在Ruby世界里使用哪些东西处理对象。

94
00:04:51,291 --> 00:04:56,291
大体说来，如果你在指定数据库内查看所有表格，

95
00:04:56,296 --> 00:04:59,296
他们会有哪些列等等，那些列又有哪些类型，

96
00:04:59,299 --> 00:05:01,299
这些内容统称为该应用程序的纲要。

97
00:05:01,301 --> 00:05:06,301
替代方案有哪些？假设你不想使用活动记录，

98
00:05:06,306 --> 00:05:08,306
那还可以使用什么方法，为什么要采用这样的方法？

99
00:05:08,308 --> 00:05:11,308
数据映射器是考虑数据的另一种方法，表示

100
00:05:11,311 --> 00:05:14,311
“每次你定义新的模型类型时，你应

101
00:05:14,314 --> 00:05:17,314
就该模型提出映射器。”

102
00:05:17,317 --> 00:05:20,317
映射器负责指出

103
00:05:20,320 --> 00:05:23,320
数据库要如何存储该类模型的详细情况。

104
00:05:23,323 --> 00:05:25,323
你之所以要如此操作，是因为它保持映射策略

105
00:05:25,325 --> 00:05:28,325
独立于具体数据存储类型。

106
00:05:28,328 --> 00:05:32,328
例如，正像我们看到的那样，由于它们基于活动记录得出，

107
00:05:32,332 --> 00:05:34,332
由于他们知道将要在关系数据库内存储，

108
00:05:34,334 --> 00:05:37,334
所以活动记录工具可以利用关系数据库的

109
00:05:37,337 --> 00:05:41,337
大量相关内容。如你读过类似NoSQL移动之类的内容，就会知道

110
00:05:41,341 --> 00:05:44,341
人们使用 MongoDB与 SimpleDB以及其他许多数据库， 

111
00:05:44,344 --> 00:05:48,344
不过它们中多数没有任何关系。

112
00:05:48,348 --> 00:05:51,348
它们缺乏关系数据库的许多数据 

113
00:05:51,351 --> 00:05:55,351
操纵功能。在这些例子中，由于活动记录高度依赖关系模式， 

114
00:05:55,355 --> 00:05:58,355
所以你没法切实使用活动记录。

115
00:05:58,358 --> 00:06:01,358
你可以使用像数据映射器之类的东西，

116
00:06:01,361 --> 00:06:05,361
不过实际上，你没法免费取得任何内容。如果你使用

117
00:06:05,365 --> 00:06:07,365
数据映射器，那么本来活动记录已经为你完成的大量工作，

118
00:06:07,367 --> 00:06:10,367
现在你都得自己重新做一遍，

119
00:06:10,370 --> 00:06:14,370
你得重新开发，这样才适合数据库处理的内容。

120
00:06:14,374 --> 00:06:16,374
我们开始讲高级概念，像是模型间的关联后，

121
00:06:16,376 --> 00:06:20,376
大家就明白这部分内容了。

122
00:06:20,380 --> 00:06:23,380
就像数据点，谷歌应用程序引擎使用数据映射器模式。

123
00:06:23,383 --> 00:06:25,383
这就是他们建议你按照他们的存储系统评价应用程序的方法，

124
00:06:25,385 --> 00:06:28,385
因为数据映射器的优点之一就是

125
00:06:28,388 --> 00:06:32,388
舍弃一些复杂的关系数据库内容不管，

126
00:06:32,392 --> 00:06:34,392
因此相比于多数关系数据库，他们的

127
00:06:34,394 --> 00:06:37,394
存储系统可以实现更大规模。

128
00:06:37,397 --> 00:06:40,397
这是架构折中方案的一个例子。在你达到一定的规模时， 

129
00:06:40,400 --> 00:06:43,400
一些内容的关系数据库

130
00:06:43,403 --> 00:06:46,403
不再处于扩充板内，这时你就可以使用替代方法。

131
00:06:46,406 --> 00:06:46,406



