1
00:00:00,000 --> 00:00:03,000
接着往下看。在今天的课堂上，我们要做些改变，

2
00:00:03,003 --> 00:00:05,003
其中一个就是比计划提前很多很多介绍测试的概念，

3
00:00:05,005 --> 00:00:09,005
并且介绍一个用于实现很多测试的工具，

4
00:00:09,009 --> 00:00:11,009
工具名称叫Rspec。

5
00:00:11,011 --> 00:00:13,011
它实际上是JAVA里面一些概念的继承。

6
00:00:13,013 --> 00:00:17,013
有一位很睿智的绅士曾经说过：

7
00:00:17,017 --> 00:00:20,017
“Debug比写代码要难一倍。

8
00:00:20,020 --> 00:00:23,020
因此，如果你用尽脑汁写了一个代码，

9
00:00:23,023 --> 00:00:26,023
从定义上说，你没有聪明到可以给自己的代码除错。”

10
00:00:26,026 --> 00:00:29,026
说这话的人很睿智。如果有人不知道这人是谁，

11
00:00:29,029 --> 00:00:32,029
他就是图灵奖获得者布莱恩•柯林汉，

12
00:00:32,032 --> 00:00:34,032
是C语言的发明者之一，你可能听说过。

13
00:00:34,034 --> 00:00:37,034
C语言是以字母表里的著名字母命名的语言之一。

14
00:00:37,037 --> 00:00:40,037
另一位睿智的绅士在编程语言历史上影响深远。

15
00:00:40,040 --> 00:00:44,040
他就是艾兹格•迪科斯彻，

16
00:00:44,044 --> 00:00:47,044
他因在结构化编程上的杰出贡献也获得了图灵奖。

17
00:00:47,047 --> 00:00:50,047
他写过一封有名的信件叫

18
00:00:50,050 --> 00:00:53,050
《Go to语句有害论》，

19
00:00:53,053 --> 00:00:57,053
他说过：“测试永远不能发现软件错误的___，

20
00:00:57,057 --> 00:01:00,057
发现的只能是它们的___。”

21
00:01:00,000 --> 00:01:05,060
有没有人知道空白处应该填什么？应该填Absences（不存在）和presence（存在）。

22
00:01:05,065 --> 00:01:07,065
测试可以证明你的软件有错误，

23
00:01:07,067 --> 00:01:11,067
但无法证明没有错误。我觉得还有一种更实用的版本，

24
00:01:11,071 --> 00:01:14,071
如果你...如果你们有人去过谷歌的总部，

25
00:01:14,074 --> 00:01:17,074
你们应该见到过这句话。Debug最弱，测试最牛。

26
00:01:17,077 --> 00:01:21,077
我自己干这个干了三年，所以我完全同意这种说法。

27
00:01:21,081 --> 00:01:23,081
我的目标是，到这堂课结束时，你们会爱上测试，

28
00:01:23,083 --> 00:01:26,083
爱上老大哥，就是测试，

29
00:01:26,086 --> 00:01:29,086
爱到什么程度呢？

30
00:01:29,089 --> 00:01:32,089
就像你收到facebook的信息或短信时多巴胺水平会上升一样，

31
00:01:32,092 --> 00:01:35,092
当你看到测试从“失败”变成“通过”时，多巴胺水平也会上升。

32
00:01:35,095 --> 00:01:40,095
相信我。事实上，2010年，

33
00:01:40,100 --> 00:01:46,100
有人进行了调研，

34
00:01:46,106 --> 00:01:49,106
证明之所以很难找出软件的错误，

35
00:01:49,109 --> 00:01:51,109
问题不一定在于代码的质量，

36
00:01:51,111 --> 00:01:54,111
而在于测试的过程。

37
00:01:54,114 --> 00:01:57,114
{在于机构里测试的制定方式}。我的另一个目标是，

38
00:01:57,117 --> 00:02:00,117
当你们走出教室时，不再有这些坏习惯，

39
00:02:00,000 --> 00:02:03,120
你们的测试习惯应该体现当下的最佳实践。

40
00:02:03,123 --> 00:02:07,123
现在搞测试可比以前有意思多了。现在的测试是怎么样的？

41
00:02:07,127 --> 00:02:10,127
我们首先来看看它以前是怎么样的。

42
00:02:10,130 --> 00:02:12,130
以前，开发人员写好代码后，

43
00:02:12,132 --> 00:02:15,132
把代码扔给质保部门，

44
00:02:15,135 --> 00:02:18,135
质保人员人工试运软件，稍微摆弄一下，

45
00:02:18,138 --> 00:02:20,138
过不久就签发——看着还行，

46
00:02:20,140 --> 00:02:24,140
然后就出货，而事实上还有很多漏洞。

47
00:02:24,144 --> 00:02:26,144
如今已经很不一样了。首先，测试是每一轮迭代的一部分。

48
00:02:26,146 --> 00:02:29,146
你总是在测试。在你开始写代码之前，

49
00:02:29,149 --> 00:02:32,149
你就会想测试问题，

50
00:02:32,152 --> 00:02:35,152
一边写也一边想该怎么测试。你测试自己的代码，

51
00:02:35,155 --> 00:02:38,155
开发人员测试自己的代码。

52
00:02:38,158 --> 00:02:42,158
很多都是自动的，人工测试的概念几乎要绝迹了。

53
00:02:42,162 --> 00:02:45,162
正常情况下可以人工进行的测试，

54
00:02:45,165 --> 00:02:47,165
只有极少数无法自动进行，

55
00:02:47,167 --> 00:02:50,167
这可省了很多麻烦。

56
00:02:50,170 --> 00:02:53,170
这是不是意味着不需要质保组或测试组了呢？

57
00:02:53,173 --> 00:02:55,173
当然需要，但它们不写测试程序。

58
00:02:55,175 --> 00:02:58,175
它们不做那个了。它们就像顾问，帮助你们把代码弄得更具可测试性，

59
00:02:58,178 --> 00:03:01,178
改善公司的测试工具和程序。

60
00:03:01,181 --> 00:03:04,181
前几年盛传一个著名的数据，

61
00:03:04,184 --> 00:03:07,184
据说微软说，它们每个测试...

62
00:03:07,187 --> 00:03:11,187
每个开发人员都匹配一个测试人员。

63
00:03:11,191 --> 00:03:13,191
开发人员和测试人员的比例是1：1.

64
00:03:13,193 --> 00:03:17,193
去年我问了几个谷歌的人，

65
00:03:17,197 --> 00:03:20,197
谷歌的开发人员和测试人员比例是多少？每个开发人员有几个测试人员？

66
00:03:20,200 --> 00:03:23,200
他们说，“大概每10个开发人员有一个测试人员。”

67
00:03:23,203 --> 00:03:26,203
大跌眼镜吧？

68
00:03:26,206 --> 00:03:30,206
谷歌是可靠代码之家啊，它支持数亿人进行网页活动。

69
00:03:30,210 --> 00:03:34,210
而事实上谷歌的测试工程师并不写测试，

70
00:03:34,214 --> 00:03:37,214
写测试是写代码的人的活。

71
00:03:37,217 --> 00:03:40,217
测试工程师的工作是改善测试环境。

72
00:03:40,220 --> 00:03:43,220
这种分工概念完全不一样，

73
00:03:43,223 --> 00:03:46,223
这也说明，

74
00:03:46,226 --> 00:03:49,226
软件质量现在已经不只是一个小组，比如质保小组的工作，

75
00:03:49,229 --> 00:03:52,229
它是一个流程，这个流程从一开始就涉及了开发人员。

76
00:03:52,232 --> 00:03:56,232
宏观地说，我们进行测试方式是 BDD 和 TDD，

77
00:03:56,236 --> 00:04:00,236
即行为驱动设计和测试驱动开发。

78
00:04:00,000 --> 00:04:02,240
它们很类似。

79
00:04:02,242 --> 00:04:05,242
行为驱动设计是指你和用户坐下来讨论，

80
00:04:05,245 --> 00:04:08,245
你发现用户的故事，

81
00:04:08,248 --> 00:04:10,248
那就是你想要的特征，你希望应用程序可以实现这些特征，

82
00:04:10,250 --> 00:04:14,250
但你还没写代码。可以看到，

83
00:04:14,254 --> 00:04:17,254
使用一个叫做Cucumber的工具，

84
00:04:17,257 --> 00:04:21,257
那些故事会变成你的应用程序的可运行的验收测试。实在是赞。

85
00:04:21,261 --> 00:04:24,261
现在你为想要实现的特征准备了一个故事，

86
00:04:24,264 --> 00:04:27,264
下一步你就想，我怎么写出一个代码，

87
00:04:27,267 --> 00:04:32,267
让它实现那个特征。如果是我，

88
00:04:32,272 --> 00:04:35,272
我会在用户故事中指明一些步骤，程序要经过这些步骤来实现该特征，

89
00:04:35,275 --> 00:04:38,275
对于每一个步骤，

90
00:04:38,278 --> 00:04:41,278
我都要为我想要的代码写测试。我已经从想要的特征讲到了

91
00:04:41,281 --> 00:04:44,281
想要的代码。这看起来像什么？

92
00:04:44,284 --> 00:04:50,284
一开始我们用了Cucumber 用户故事，

93
00:04:50,290 --> 00:04:53,290
但故事的第一步就失败了，因为它要运行的功能

94
00:04:53,293 --> 00:04:56,293
在定义上是不存在的。

95
00:04:56,296 --> 00:04:58,296
我们在开始思考那个功能的时候，

96
00:04:58,298 --> 00:05:01,298
就要思考如何写代码。在代码写出来之前，

97
00:05:01,301 --> 00:05:04,301
先为代码写测试。当然，测试失败了。

98
00:05:04,304 --> 00:05:07,304
如果没有代码测试还能通过，那可就太酷了。

99
00:05:07,307 --> 00:05:09,307
那生活多简单啊！但我们得现实点。

100
00:05:09,309 --> 00:05:13,309
我们得一直创建代码，直到测试通过。

101
00:05:13,313 --> 00:05:16,313
从红色到绿色。这么做之后，

102
00:05:16,316 --> 00:05:19,316
到某一个程度时，我们实现了足够多的代码可以使得

103
00:05:19,319 --> 00:05:22,319
故事的整个第一步都是绿色，通过！现在来到故事的第二步，

104
00:05:22,322 --> 00:05:25,322
就是这样做的。这个循环要做好几次，

105
00:05:25,325 --> 00:05:28,325
直到把整个特征都实现，然后核对、无误、签发，

106
00:05:28,328 --> 00:05:29,328
发货给客户。

