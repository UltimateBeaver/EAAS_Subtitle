1
00:00:00,000 --> 00:00:05,000
上次我们从较高层面介绍了Ruby语言，

2
00:00:05,005 --> 00:00:08,005
以及一些使用JAVA语言的人以前不熟悉的

3
00:00:08,008 --> 00:00:09,008
很酷的Ruby内容。

4
00:00:09,009 --> 00:00:14,009
我们简要讲到，Ruby其中一个有趣的地方

5
00:00:14,014 --> 00:00:16,014
就是可以通过集合的元素处理迭代。

6
00:00:16,016 --> 00:00:19,016
我想多花点时间讲讲这个，

7
00:00:19,019 --> 00:00:22,019
我们看到采用each的迭代，

8
00:00:22,022 --> 00:00:25,022
我也说过你们不应该以命令式for循环处理迭代，

9
00:00:25,025 --> 00:00:27,025
而应该让数据结构管理它们自己的遍历，

10
00:00:27,027 --> 00:00:31,027
那只是一种更通用机制的例子，

11
00:00:31,031 --> 00:00:33,031
这个机制在Ruby里称作yield，

12
00:00:33,033 --> 00:00:37,033
我们接下来就要讲这个。

13
00:00:37,037 --> 00:00:40,037
首先，我们来看看在JAVA这样的解释型语言里，

14
00:00:40,040 --> 00:00:43,040
一般怎么处理迭代。如果你们以前见过这种JAVA代码，

15
00:00:43,043 --> 00:00:45,043
一般这就是一个集合。

16
00:00:45,045 --> 00:00:49,045
这里是一个列表，如果你想对集合进行迭代，

17
00:00:49,049 --> 00:00:52,049
你会希望它实现迭代接口，而且你得建立一个新迭代器，

18
00:00:52,052 --> 00:00:55,052
时不时问问它集合里面还有没有别的元素。

19
00:00:55,055 --> 00:00:59,055
如果有，你让它把下一个元素给你，

20
00:00:59,059 --> 00:01:01,059
你对那个元素进行操作。

21
00:01:01,061 --> 00:01:04,061
我觉得这个不优美，因为它把两个东西混在一起了。

22
00:01:04,064 --> 00:01:08,064
红色的这个，有些代码是处理列表元素的，

23
00:01:08,068 --> 00:01:13,068
蓝色的这个，

24
00:01:13,073 --> 00:01:15,073
这其实只是将那些元素排除的技术细节。

25
00:01:15,075 --> 00:01:18,075
如果那些东西能彼此分开就好了。

26
00:01:18,078 --> 00:01:20,078
如果你们有人是伯克利的学生，而且在还教Scheme的时候上过61A课程，

27
00:01:20,080 --> 00:01:24,080
那可是我最喜欢的语言之一，

28
00:01:24,084 --> 00:01:27,084
你们就已经见过这种机制。如果你们还记得映射和过滤，

29
00:01:27,087 --> 00:01:30,087
那么你们就可以说“map”，

30
00:01:30,090 --> 00:01:32,090
给它一个函数和一个列表。

31
00:01:32,092 --> 00:01:34,092
在Scheme里，列表是唯一的类型，

32
00:01:34,094 --> 00:01:38,094
所以你不必担心哪些类型的东西可以映射，

33
00:01:38,098 --> 00:01:42,098
因为列表是唯一的选择。Ruby也基本一样。

34
00:01:42,102 --> 00:01:45,102
记住，在某些情况下，

35
00:01:45,105 --> 00:01:48,105
括号可以用来取代块两边的do和end。

36
00:01:48,108 --> 00:01:52,108
映射提取一个参数块，

37
00:01:52,112 --> 00:01:55,112
将块应用到集合里的每一个元素。

38
00:01:55,115 --> 00:01:58,115
如果你还记得Scheme的filter（过滤），

39
00:01:58,118 --> 00:02:00,118
Ruby的select（选择）基本上是同样的作用。

40
00:02:00,000 --> 00:02:03,120
这回我用的是" do" 和" end"而不是大括号，

41
00:02:03,123 --> 00:02:07,123
你们其实可以把它们合并起来。我可以提取在filter上运算的Lambda表达式映射，

42
00:02:07,127 --> 00:02:11,127
Ruby也是一样。我可以提取一个列表，

43
00:02:11,131 --> 00:02:14,131
可以调用select来过滤掉一部分元素，

44
00:02:14,134 --> 00:02:16,134
这就返回列表的新副本，

45
00:02:16,136 --> 00:02:20,136
里面只包含过滤后剩下的元素，然后我对结果调用映射。

46
00:02:20,140 --> 00:02:24,140
这反映出Ruby对函数式语言的众多继承之一，

47
00:02:24,144 --> 00:02:28,144
Scheme就是函数式语言的一个例子。

48
00:02:28,148 --> 00:02:31,148
和C++或JAVA语言的处理相比，

49
00:02:31,151 --> 00:02:34,151
我觉得它就是将迭代倒过来。在JAVA语言里，

50
00:02:34,154 --> 00:02:37,154
你把集合的每个元素都给我，我对其中一些进行处理，

51
00:02:37,157 --> 00:02:39,157
然后问你还有没有别的元素。

52
00:02:39,159 --> 00:02:41,159
而Ruby则恰恰相反，你说：

53
00:02:41,161 --> 00:02:44,161
“我想对集合的每个元素进行这个操作。”

54
00:02:44,164 --> 00:02:48,164
而你——数据结构——你来管理集合，

55
00:02:48,168 --> 00:02:51,168
把每个元素都按要求给我，这个环节我不需要担心。

56
00:02:51,171 --> 00:02:55,171
我们来举个例子演示一下。

57
00:02:55,175 --> 00:03:02,175
好，已经定义好了。我以前说过，在Ruby里，

58
00:03:02,182 --> 00:03:05,182
我们只关心你对什么方法有反应。

59
00:03:05,185 --> 00:03:09,185
这里我创建一个叫做随机序列的类。

60
00:03:09,189 --> 00:03:12,189
这个类将给我一个对象，

61
00:03:12,192 --> 00:03:16,192
这个对象生成一个从1到某个数的随机数列表，

62
00:03:16,196 --> 00:03:22,196
在那个列表中生成多达num个数。

63
00:03:22,202 --> 00:03:26,202
比如说，我可以调用 “ 10,4,” 意思是我想要一个

64
00:03:26,206 --> 00:03:30,206
从1到10的4个随机数的新序列。这是怎么办到的？

65
00:03:30,210 --> 00:03:34,210
首先，我要向大家证明，

66
00:03:34,214 --> 00:03:38,214
只要把这个粘贴到Ruby的解释器窗口就行了。

67
00:03:38,218 --> 00:03:46,218
当然，我得先启动Ruby解释器，现在可以抓取，

68
00:03:46,226 --> 00:03:51,226
这是一块代码...好了。

69
00:03:51,231 --> 00:03:53,231
这块代码创建了新的随机序列对象，

70
00:03:53,233 --> 00:03:56,233
并对其调用each。记住，我们说过，

71
00:03:56,236 --> 00:04:00,236
只要它对each做出反应。Each是一种承诺，

72
00:04:00,000 --> 00:04:04,240
表示我能管理自己的数据结构的遍历。这个例子中，

73
00:04:04,244 --> 00:04:07,244
我们生成了新的随机序列对象，依次地返回每一个元素。

74
00:04:07,247 --> 00:04:10,247
这是什么意思呢？我们怎么做到这一点？

75
00:04:10,250 --> 00:04:14,250
看看我们对each的定义，之前已经见过几次了。

76
00:04:14,254 --> 00:04:17,254
它的意思是“重复本代码块数次。”

77
00:04:17,257 --> 00:04:21,257
第二个参数是什么？块里面发生了什么？

78
00:04:21,261 --> 00:04:23,261
很多人可能是第一次见到这个。

79
00:04:23,263 --> 00:04:27,263
这是yield，它的意思是：“把指挥权交还给调用我的那个东西，

80
00:04:27,267 --> 00:04:31,267
因为有个代码块在等着我。”看这里，

81
00:04:31,271 --> 00:04:34,271
这里调用了随机序列，each的参数就是这里的块。

82
00:04:34,274 --> 00:04:38,274
这个块即将被调用，

83
00:04:38,278 --> 00:04:42,278
参数为yield，你可以看到yield正在对一个值进行让步执行，

84
00:04:42,282 --> 00:04:45,282
这个块将采用一个值。

85
00:04:45,285 --> 00:04:49,285
两个竖杠之间有一个值。这里事实上each被调用，

86
00:04:49,289 --> 00:04:53,289
每次一到达yield，它就将控制权

87
00:04:53,293 --> 00:04:57,293
交回到这里。这就把迭代器展现出来了。

88
00:04:57,297 --> 00:05:01,297
我们要做的就是定义一种方式，

89
00:05:01,301 --> 00:05:04,301
让each可以用yield一个一个地交回对象。

90
00:05:04,304 --> 00:05:11,304
这是个很漂亮的结构。迭代器只是yield众多

91
00:05:11,311 --> 00:05:14,311
应用中一种漂亮的，它的作用我们已经见过了，

92
00:05:14,314 --> 00:05:16,314
所以我才想用它来开始。我再来演示另一件

93
00:05:16,316 --> 00:05:19,316
你们可以做的有趣的事，它会让你们认识到yield可以

94
00:05:19,319 --> 00:05:22,319
更好地帮你们清理代码。

95
00:05:22,322 --> 00:05:24,322
左边是典型习惯用法和语言，

96
00:05:24,324 --> 00:05:27,324
提供了操作文档的方式。调用库来打开文档。

97
00:05:27,327 --> 00:05:30,327
再调用一个库来关闭文档。基本上，

98
00:05:30,330 --> 00:05:33,330
你需要做的就是调用file open（文档打开），对文档进行一些操作，

99
00:05:33,333 --> 00:05:36,333
然后关闭文档。这可能是你习惯的思维方式，

100
00:05:36,336 --> 00:05:38,336
但我们不因为一直这么做

101
00:05:38,338 --> 00:05:40,338
所以就继续这么做。

102
00:05:40,340 --> 00:05:43,340
更Ruby风格的做法是什么呢？就是认识到，

103
00:05:43,343 --> 00:05:47,343
打开文档、执行操作和关闭文档是一个非常普遍的模式。

104
00:05:47,347 --> 00:05:50,347
打开和关闭对谁都是一样。

105
00:05:50,350 --> 00:05:52,350
唯一不同的部分是打开与关闭之间发生了什么。

106
00:05:52,352 --> 00:05:55,352
我们可以用yield来提取，

107
00:05:55,355 --> 00:05:59,355
Ruby的文档调用就是这样执行的。

108
00:05:59,359 --> 00:06:01,359
然而，这里我们定义一个打开文件名方法，

109
00:06:01,361 --> 00:06:04,361
它会想尽办法打开文档，获取文件描述符，

110
00:06:04,364 --> 00:06:07,364
然后将该文件描述符yield回块。

111
00:06:07,367 --> 00:06:11,367
你使用时是什么样？在你的代码中，你可以说：

112
00:06:11,371 --> 00:06:14,371
“用文件名打开文档”，然而显示块。在这个块里，

113
00:06:14,374 --> 00:06:17,374
你可以对文档进行操作。这里会发生什么？

114
00:06:17,377 --> 00:06:20,377
我会调用文档打开，这就将控制权传递给打开的调用。

115
00:06:20,380 --> 00:06:23,380
打开调用实际上会打开文档，

116
00:06:23,383 --> 00:06:26,383
会将描述符yield给我。那现在我可以对文档进行操作。

117
00:06:26,386 --> 00:06:30,386
当块结束时，我在哪儿呢？

118
00:06:30,390 --> 00:06:34,390
我回到了yield后面的函数。这里，我可以关闭文档，

119
00:06:34,394 --> 00:06:36,394
执行其他清理。我已经提取出了通用部分，

120
00:06:36,396 --> 00:06:39,396
在两边调用了yield，

121
00:06:39,399 --> 00:06:41,399
而不是分别用两个函数调用。

122
00:06:41,401 --> 00:06:46,401
我只用了一个调用而不是两个。块是闭包。

123
00:06:46,406 --> 00:06:49,406
这是另一个概念，在61A和Scheme里教过，

124
00:06:49,409 --> 00:06:52,409
但在很多现代语言中都没有，起码不明显。

125
00:06:52,412 --> 00:06:55,412
闭包基本上是变量绑定的集合，

126
00:06:55,415 --> 00:06:58,415
这些变量都有值，

127
00:06:58,418 --> 00:07:01,418
在某个时间点可以看见。如果你记得，在61A里，

128
00:07:01,421 --> 00:07:04,421
这个叫做环境，你在这里画上图。

129
00:07:04,424 --> 00:07:07,424
就是这样的。这对于yield是什么意思？

130
00:07:07,427 --> 00:07:10,427
我们为什么要关心这个？回到我们的随机序列的例子，

131
00:07:10,430 --> 00:07:13,430
以及这里的情况，当我们调用random sequence new（新随机序列），

132
00:07:13,433 --> 00:07:16,433
然后取消each，这个变量是什么？

133
00:07:16,436 --> 00:07:22,436
“i?” 这只是随机局部变量。在这里。

134
00:07:22,442 --> 00:07:25,442
 “i”在作用域里，但记住控制流是什么。

135
00:07:25,445 --> 00:07:29,445
现在要调用each。现在我们在这个函数里。Each调用numtimes。

136
00:07:29,449 --> 00:07:33,449
第一次点击yield时，我们就回到这儿。

137
00:07:33,453 --> 00:07:37,453
你是不是在想，什么时候执行这个块？

138
00:07:37,457 --> 00:07:40,457
在调用yield时执行，但尽管如此，

139
00:07:40,460 --> 00:07:44,460
它还是可以访问变量“i”，

140
00:07:44,464 --> 00:07:47,464
“i”位于定义块的作用域里。

141
00:07:47,467 --> 00:07:50,467
这个概念比较深奥。就是说，你创建一个do块，

142
00:07:50,470 --> 00:07:53,470
那个块里面的所有可见变量都会可见，

143
00:07:53,473 --> 00:07:56,473
并具有那些值，即使块执行的地方

144
00:07:56,476 --> 00:07:59,476
和你定义它的地方相隔很远，

145
00:07:59,479 --> 00:08:02,479
或是在后面部分，或是第二部分（在线课程）

146
00:08:02,482 --> 00:08:05,482
我们还会在JavaScript里再次看到这个。

147
00:08:05,485 --> 00:08:08,485
JavaScript大量使用闭包，

148
00:08:08,488 --> 00:08:11,488
这也是刚学JavaScript的人写出很糟糕很糟糕代码的原因之一，

149
00:08:11,491 --> 00:08:13,491
因为他们还不了解一个很强大的概念：

150
00:08:13,493 --> 00:08:16,493
你可以定义一个程序环境，

151
00:08:16,496 --> 00:08:19,496
它总是把自己的变量带着跑。

