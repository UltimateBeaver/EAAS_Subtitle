1
00:00:00,000 --> 00:00:04,000
现在是时候讨论细节了。我们已经大体讲了

2
00:00:04,004 --> 00:00:07,004
SaaS应用程序的架构，我们讲了模型视图控制器，

3
00:00:07,007 --> 00:00:10,007
现在要开始实际的Rails结构课程了，

4
00:00:10,010 --> 00:00:12,010
我们一开始要具体讲解几个概念，

5
00:00:12,012 --> 00:00:18,012
看看Rails都会做些什么。如果你

6
00:00:18,018 --> 00:00:21,018
创建了新的Rails应用程序，又或者你使用的是我们课内

7
00:00:21,021 --> 00:00:24,021
创建的烂土豆应用程序，你要看看目录中都有什么，

8
00:00:24,024 --> 00:00:27,024
应用程序的根目录，在这里你会看到一大堆东西。

9
00:00:27,027 --> 00:00:29,027
我们不会注意在根目录里的所有内容，

10
00:00:29,029 --> 00:00:32,029
不过你会找到Gem文件和Rake文件，

11
00:00:32,032 --> 00:00:34,032
现在你开始查看目录，你会发现这基本上

12
00:00:34,034 --> 00:00:37,034
与我们讲过的概念完全一致。

13
00:00:37,037 --> 00:00:40,037
借助小架构图

14
00:00:40,040 --> 00:00:44,040
我们巧妙地以缩影的形式再现架构，在这个图解里，

15
00:00:44,044 --> 00:00:47,044
有一个目录叫App，下面有子目录models、views与controllers。

16
00:00:47,047 --> 00:00:49,047
你也许会基于我们已讲过的应用程序内容， 

17
00:00:49,049 --> 00:00:53,049
想到这些目录里面的内容。

18
00:00:53,053 --> 00:00:57,053
我们知道应用程序围绕MVC组织构建而成， 

19
00:00:57,057 --> 00:01:00,057
我们还知道每一个部分都有怎样的作用。例如，我们说过的各类内容，

20
00:01:00,000 --> 00:01:03,060
例如电影，就有它自己的模型、自己的视图组，

21
00:01:03,063 --> 00:01:06,063
还有特有的控制器，你可以想象这些东西你都能在目录中找到。

22
00:01:06,066 --> 00:01:11,066
如果我们继续探索，我们讲过

23
00:01:11,071 --> 00:01:14,071
使用样式表可以确定向用户呈现的内容样式。

24
00:01:14,074 --> 00:01:17,074
你可以在名为Assets的目录中找到样式表，

25
00:01:17,077 --> 00:01:19,077
你还会发现放置JavaScript的位置， 

26
00:01:19,079 --> 00:01:23,079
这我们以后会学到，此外你还会找到其他有趣儿的东西。

27
00:01:23,083 --> 00:01:27,083
我们讲过，Rails具有单独的路由子系统，

28
00:01:27,087 --> 00:01:30,087
所以你无需将固定的URI揉入代码，

29
00:01:30,090 --> 00:01:35,090
相反，你可以具体指定你想要支持的

30
00:01:35,095 --> 00:01:37,095
动作和资源，这样Rails就会向你提供

31
00:01:37,097 --> 00:01:40,097
生成相应URI需要使用的工具。

32
00:01:40,100 --> 00:01:43,100
在Config（配置）目录里，你会发现一个名为routes.rb的文件，

33
00:01:43,103 --> 00:01:47,103
借助它，你可以具体指定你要采取的动作，随着你的应用程序开始运转，

34
00:01:47,107 --> 00:01:51,107
这个文件的信息会用于运行时自动构建相应映射。

35
00:01:51,111 --> 00:01:55,111
还有一个名为db的数据库目录，我们知道， 

36
00:01:55,115 --> 00:01:58,115
数据库是实际存放模型数据的地方，

37
00:01:58,118 --> 00:02:02,118
我们接下来讲Rails怎样处理数据库时， 

38
00:02:02,122 --> 00:02:05,122
会简单讲一讲你可以有一个以上的多个数据库。

39
00:02:05,125 --> 00:02:08,125
尤其是，你可以在生产中使用一个数据库，

40
00:02:08,128 --> 00:02:10,128
在开发时使用一个，

41
00:02:10,130 --> 00:02:12,130
甚至还可以单单为运行测试再使用另一个。

42
00:02:12,132 --> 00:02:15,132
你会发现你可以在db子目录下

43
00:02:15,135 --> 00:02:20,135
找到所有数据库，或者至少可以找到数据库的路径信息。

44
00:02:20,140 --> 00:02:24,140
Rails是怎样作为MVC结构工作的呢？

45
00:02:24,144 --> 00:02:27,144
从很久以前我们就开始使用这样一幅图，显示的是你的网络浏览器

46
00:02:27,147 --> 00:02:29,147
由表示层进入，这儿是网络存储器所在的位置，

47
00:02:29,149 --> 00:02:32,149
它来到你的Rails应用程序这儿，然后从某种程度上可能

48
00:02:32,152 --> 00:02:36,152
从数据库得到数据。具体说来，你的应用程序内部是怎样的呢？

49
00:02:36,156 --> 00:02:39,156
在Rails的世界里，发生的第一件事就是

50
00:02:39,159 --> 00:02:41,159
从浏览器进入的请求抵达

51
00:02:41,161 --> 00:02:44,161
任一控制器，控制器代码在哪儿呢？

52
00:02:44,164 --> 00:02:47,164
在控制器目录里，在这儿你就能找到它。

53
00:02:47,167 --> 00:02:49,167
我们会时常回顾这个话题。

54
00:02:49,169 --> 00:02:52,169
如果你想尽量合理地进行操作，

55
00:02:52,172 --> 00:02:56,172
有很多工作没必要做。Rails 

56
00:02:56,176 --> 00:03:00,176
路由子系统负责将进入的URL映射到正确的控制器与正确的

57
00:03:00,000 --> 00:03:02,180
动作，或在出现不匹配的情况时负责使用信号通知错误。

58
00:03:02,182 --> 00:03:06,182
控制器会要求模型做同样的操作，

59
00:03:06,186 --> 00:03:09,186
那么什么是模型？确切说来，就是模型

60
00:03:09,189 --> 00:03:11,189
子目录内某个地方的一堆代码而已。

61
00:03:11,191 --> 00:03:15,191
我们都知道，由于Rails使用活动记录，

62
00:03:15,195 --> 00:03:17,195
这意味着存在关系数据库，在这个数据库内

63
00:03:17,197 --> 00:03:23,197
每个模型都有一个表格，里面有该模型启动的实例。

64
00:03:23,203 --> 00:03:25,203
一旦模型向控制器发还某个数据，

65
00:03:25,205 --> 00:03:29,205
控制器就会向Haml一类的模板系统发送该数据。

66
00:03:29,209 --> 00:03:32,209
插入经控制器发来的数据，由此提供视图，

67
00:03:32,212 --> 00:03:36,212
再返回你的浏览器。

68
00:03:36,216 --> 00:03:39,216
模型是什么？我们看到活动记录基地的分类，

69
00:03:39,219 --> 00:03:44,219
视图是动作视图的分类，而

70
00:03:44,224 --> 00:03:47,224
控制器是应用程序控制器的分类。

71
00:03:47,227 --> 00:03:51,227
这是你如何使用语言功能的一个例子，

72
00:03:51,231 --> 00:03:55,231
语言具有类层次结构与继承性从而可以支持框架。

73
00:03:55,235 --> 00:03:58,235
如果我们说活动记录具有所有模型都能使用的通用功能，

74
00:03:58,238 --> 00:04:00,238
同时存在与特定类型模式关联的指定工具，

75
00:04:00,000 --> 00:04:04,240
那这就是我们要重新使用实施时， 

76
00:04:04,244 --> 00:04:06,244
运用继承性的确切问题了。

77
00:04:06,246 --> 00:04:09,246
所有模型应该可以共享活动记录通用功能的实施，

78
00:04:09,249 --> 00:04:12,249
使模型为某个基类模型的子类是有意义的，

79
00:04:12,252 --> 00:04:15,252
这个基类模型应该具有对所有模型而言通用的功能才对。

80
00:04:15,255 --> 00:04:18,255
你可以对视图与控制器做个类似推理。

81
00:04:18,258 --> 00:04:22,258
这是继承性的好用途。

82
00:04:22,262 --> 00:04:25,262
在不同类型项目间存在通用性，

83
00:04:25,265 --> 00:04:27,265
这儿有我们想要捕获的一定的通用性，

84
00:04:27,267 --> 00:04:30,267
还有它们都可重复使用的通用实现，

85
00:04:30,270 --> 00:04:34,270
继承性就是重新使用实现的方法。我们

86
00:04:34,274 --> 00:04:39,274
纵览一下ails应用程序，很快就好。发生了什么呢……

87
00:04:39,279 --> 00:04:43,279
我把一些细节和文本放到图解后。在routes.rb内

88
00:04:43,283 --> 00:04:46,283
我们有专为自己应用程序定义的路径。

89
00:04:46,286 --> 00:04:50,286
它们将进入的请求URI映射到控制器动作，就像我们看到的那样，

90
00:04:50,290 --> 00:04:53,290
这些控制器动作路径可包含备选的指定查询项，

91
00:04:53,293 --> 00:04:55,293
像是标识那什么的查询项或是标识特定资源的参数，

92
00:04:55,295 --> 00:05:00,295
这些都为你提取出来了。

93
00:05:00,000 --> 00:05:03,300
这儿还有个例子，我们访问本地设备上运行的应用程序，

94
00:05:03,303 --> 00:05:06,303
我们会get/movie/3, 继续来自

95
00:05:06,306 --> 00:05:11,306
上一程序段的示例。在这种情况下，会查阅routes.rb，

96
00:05:11,311 --> 00:05:14,311
还会有一个映射，因为这就是

97
00:05:14,314 --> 00:05:17,314
Rails提供给我们的默认路径之一，

98
00:05:17,317 --> 00:05:20,317
这里说你应该看看电影的控制器，然后在

99
00:05:20,320 --> 00:05:22,320
这个控制器里调用显示动作。这些东西都会放在哪里？

100
00:05:22,322 --> 00:05:27,322
我们会现在就展示，约定优于配置，

101
00:05:27,327 --> 00:05:32,327
表示如果我们选择遵守命名

102
00:05:32,332 --> 00:05:34,332
与放置位置的一些默认规则，

103
00:05:34,334 --> 00:05:37,334
我们实际上没有必要告诉Rails要看哪里。

104
00:05:37,337 --> 00:05:42,337
它基本上会自己看着办。控制器动作可

105
00:05:42,342 --> 00:05:44,342
以经常做想要获得数据时要做的事情，它们一完成，会

106
00:05:44,344 --> 00:05:47,344
设置视图可见的实例变量。

107
00:05:47,347 --> 00:05:50,347
这就是从控制器子系统向视图子系统

108
00:05:50,350 --> 00:05:53,350
实际传送信息的方式。

109
00:05:53,353 --> 00:05:56,353
在控制器动作内设置的所有

110
00:05:56,356 --> 00:05:59,356
控制器实例变量均会自动变得试图可见。

111
00:05:59,359 --> 00:06:02,359
你一直在仔细听讲的话，那么现在你会说，或者说我希望你这么说，

112
00:06:02,362 --> 00:06:05,362
“等一下，阿曼多，你刚才说视图是

113
00:06:05,365 --> 00:06:09,365
动作视图的子类，而控制器是

114
00:06:09,369 --> 00:06:12,369
动作控制器的子类。那这是怎么回事， 

115
00:06:12,372 --> 00:06:15,372
如果设置某个东西的实例变量，那么

116
00:06:15,375 --> 00:06:18,375
控制器就会使类型完全不同的东西也可

117
00:06:18,378 --> 00:06:20,378
使用这些实例变量，是这样吗？”

118
00:06:20,380 --> 00:06:25,380
这实在毫无意义，你说得对。

119
00:06:25,385 --> 00:06:27,385
Rails实际做了什么，还记得我们之前

120
00:06:27,387 --> 00:06:30,387
讲过元编程，使用Ruby你就可以在运行时编写代码，

121
00:06:30,390 --> 00:06:34,390
在运行时调整类。根本上发生的就是

122
00:06:34,394 --> 00:06:37,394
创建了动作视图实例，同时借助元编程

123
00:06:37,397 --> 00:06:40,397
将新的实例变量属性注入该实例。

124
00:06:40,400 --> 00:06:43,400
它的实例变量会符合你使用控制器方法设置的项目。

125
00:06:43,403 --> 00:06:46,403
它们是什么不要紧，要记住的是在Ruby内我们

126
00:06:46,406 --> 00:06:49,406
可以询问任何对象有关该对象的内容，控制器方法会问，

127
00:06:49,409 --> 00:06:54,409
关于它本身，在控制器方法内程序员创建

128
00:06:54,414 --> 00:06:57,414
使用了哪些新实例变量？这些新变量还不是控制器

129
00:06:57,417 --> 00:07:00,417
本身的实例变量。针对其中的每个变量，

130
00:07:00,000 --> 00:07:04,420
我创建的变量版本名称与其他类的另一个对象一致，

131
00:07:04,424 --> 00:07:06,424
而这个对象就是动作视图。

132
00:07:06,426 --> 00:07:10,426
你为什么要这么做？因为这对程序员来说较为简单。

133
00:07:10,430 --> 00:07:12,430
你设置实例变量，就为了之后能使用它们，这就是你这么做的原因。

134
00:07:12,432 --> 00:07:14,432
这使得程序员的工作更简单，

135
00:07:14,434 --> 00:07:17,434
而Rails与Ruby正是为简化编程而存在。

136
00:07:17,437 --> 00:07:20,437
控制器可以设置视图可见的实例变量， 

137
00:07:20,440 --> 00:07:24,440
那它要在哪里找视图呢？正像我们所看到的，

138
00:07:24,444 --> 00:07:27,444
如果你有一个控制器动作，举例说，名为显示， 

139
00:07:27,447 --> 00:07:31,447
可以显示电影，那它就会查阅电影的视图

140
00:07:31,451 --> 00:07:35,451
子目录，然后查找show.html.haml，因为这才合理。

141
00:07:35,455 --> 00:07:37,455
我们要就约定优于配置讲更多内容。

142
00:07:37,457 --> 00:07:41,457
我们的控制器动作看上去如何，这儿有

143
00:07:41,461 --> 00:07:44,461
一个示例。我们有要查找的电影ID，

144
00:07:44,464 --> 00:07:47,464
这来自URI，路径子系统会为我们把它拉出来。

145
00:07:47,467 --> 00:07:51,467
就像我们看到的那样，其中一个方法是，我们可以告诉

146
00:07:51,471 --> 00:07:56,471
电影模型处理R，然后找到ID是这个的数据库记录， 

147
00:07:56,476 --> 00:07:59,476
把它分派给这个实例变量MV，然后像变魔术似的， 

148
00:07:59,479 --> 00:08:02,479
在视图里我们全都能使用这个实例变量。

149
00:08:02,482 --> 00:08:06,482
视图里面可能有一小片东西，

150
00:08:06,486 --> 00:08:09,486
像是Haml里面的这个，列表项目显示， 

151
00:08:09,489 --> 00:08:12,489
“本电影的等级是，”而插值显示， 

152
00:08:12,492 --> 00:08:15,492
“Mv等级。”这个为什么有效？ 

153
00:08:15,495 --> 00:08:18,495
因为MV只是电影变量，电影具有名为等级的属性， 

154
00:08:18,498 --> 00:08:22,498
我们可以解除它的引用。目标是让代码

155
00:08:22,502 --> 00:08:24,502
看上去符合你期望的运作方式。

156
00:08:24,504 --> 00:08:28,504
这样就省得你在看代码的时候频频吃惊。Rails的原理是

157
00:08:28,508 --> 00:08:31,508
在这方面下了很大功夫，我们接下来会看到

158
00:08:31,511 --> 00:08:34,511
很多示例……看一些缺陷，其中就有约定优于配置。

159
00:08:34,514 --> 00:08:39,514
从本质上看，这是说你要遵守某些规则，

160
00:08:39,519 --> 00:08:41,519
这样你就无需担心很多问题，

161
00:08:41,521 --> 00:08:44,521
像是怎样查找内容或在哪里命名内容。

162
00:08:44,524 --> 00:08:48,524
这个例子讲的是，如果电影是控制器，也就是……

163
00:08:48,528 --> 00:08:50,528
我们规定的控制器，那么它就是动作控制器的分类，

164
00:08:50,530 --> 00:08:53,530
我们想要在名为显示的那个控制器里

165
00:08:53,533 --> 00:08:57,533
查找动作或方法，Rails就会希望

166
00:08:57,537 --> 00:09:02,537
那个控制器的子目录包含movies_controller.rb。

167
00:09:02,542 --> 00:09:05,542
基本上这个规则就是，你获取内容的名称，就要以复数表示名称，然后

168
00:09:05,545 --> 00:09:09,545
添加控制器。预计会在现实动作结束时，

169
00:09:09,549 --> 00:09:12,549
除非你另作说明，否则会提供视图，

170
00:09:12,552 --> 00:09:16,552
所以应该查找电影子目录与视图， 

171
00:09:16,556 --> 00:09:20,556
以及该子目录下的show.html.haml。

172
00:09:20,560 --> 00:09:23,560
此时，只要你愿意，你可以随时尽数重写，不过如果你重写它，

173
00:09:23,563 --> 00:09:25,563
你就要做更多的事，因为现在你得告诉它

174
00:09:25,565 --> 00:09:31,565
要去哪找这些内容。就像你想到的那样，

175
00:09:31,571 --> 00:09:33,571
内部查阅Ruby对象然后问有关对象的问题这种能力， 

176
00:09:33,573 --> 00:09:36,573
像是我的名称是什么，这个变量的名称是什么， 

177
00:09:36,576 --> 00:09:39,576
me的名称是什么之类的问题，其实就是Rails随后

178
00:09:39,579 --> 00:09:42,579
借助相应名称在确定的目录下查找内容的方式。

179
00:09:42,582 --> 00:09:45,582
部分原因是不要自我重复的原理，又称DRY。

180
00:09:45,585 --> 00:09:49,585
如果你能只靠一些简单的名称规则猜

181
00:09:49,589 --> 00:09:53,589
出项目名称，例如文件与动作以及模板，

182
00:09:53,593 --> 00:09:56,593
那么你就没必要在其他位置

183
00:09:56,596 --> 00:09:58,596
明确重复该信息。

184
00:09:58,598 --> 00:10:00,598
如果你的应用程序发生变化，就需要多更新一个位置。

185
00:10:00,000 --> 00:10:04,600
我们会看到许多机制不仅借助常规优于

186
00:10:04,604 --> 00:10:07,604
再配置实现DRY，还会提取

187
00:10:07,607 --> 00:10:12,607
多处重复使用的通用功能。这两个机理，

188
00:10:12,612 --> 00:10:15,612
通过我们看到的例子各位会发现， 

189
00:10:15,615 --> 00:10:18,615
他们都在很大程度上依赖于Ruby语言功能。

190
00:10:18,618 --> 00:10:20,618
这就是人们常说“Rails只是个框架”的原因， 

191
00:10:20,620 --> 00:10:23,620
你可以做个跟Rails一样的结构，不过使用Java语言而非Ruby。

192
00:10:23,623 --> 00:10:26,623
这实际上并不简单，因为Rails应用程序

193
00:10:26,626 --> 00:10:29,626
之所以如此精简，从很多方面看是因为你可以摆脱许多……

194
00:10:29,629 --> 00:10:32,629
基本上不必明确投入大量信息，

195
00:10:32,632 --> 00:10:35,632
因为你可使用内省推断出该信息，

196
00:10:35,635 --> 00:10:38,635
你还可以使用元编程在运行时创建新对象， 

197
00:10:38,638 --> 00:10:40,638
使新对象具有以程序员乐见的样子。

198
00:10:40,640 --> 00:10:43,640
如果语言不支持这一点， 

199
00:10:43,643 --> 00:10:45,643
你也许会想你已经有像Rails的内容了， 

200
00:10:45,645 --> 00:10:48,645
不过实际上Rails部分原有的简洁紧凑

201
00:10:48,648 --> 00:10:49,648
在很大程度上已经不存在了。


