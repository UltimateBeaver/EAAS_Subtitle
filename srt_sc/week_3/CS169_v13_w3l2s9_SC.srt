1
00:00:00,000 --> 00:00:04,000
我们通过快速浏览SaaS架构已学到不少知识。

2
00:00:04,004 --> 00:00:09,004
我喜欢经常倒回去看这副大图，

3
00:00:09,009 --> 00:00:12,009
尤其是用我这双上了年纪状态不佳的眼睛看，

4
00:00:12,012 --> 00:00:15,012
这里的大图是模型视图控制器，

5
00:00:15,015 --> 00:00:17,015
这是我们构建应用程序的方法。

6
00:00:17,017 --> 00:00:20,017
它不一定是构建所有SaaS应用程序的方法，

7
00:00:20,020 --> 00:00:23,020
却是Rails针对目标选定的方法，

8
00:00:23,023 --> 00:00:26,023
由于它适用于大量应用程序，所以

9
00:00:26,026 --> 00:00:29,026
Rails的所有设计选项都青睐于使用模型视图控制器。如果你想要使用Rails

10
00:00:29,029 --> 00:00:32,029
编写应用程序，可它并不遵循MVC，那么你

11
00:00:32,032 --> 00:00:34,032
会发现自己要和Rails的许多既定设置缠斗，

12
00:00:34,034 --> 00:00:37,034
如果你违反结构工作，这就意味着

13
00:00:37,037 --> 00:00:39,037
你用错了结构。你的应用程序应

14
00:00:39,039 --> 00:00:42,039
该使用别的东西。尤其是在我们的案例中，

15
00:00:42,042 --> 00:00:45,042
我们要使用数据库存储数据， 

16
00:00:45,045 --> 00:00:47,045
过会儿我们要讲讲迁移，这是管理结构的方式，

17
00:00:47,047 --> 00:00:51,047
我们还会讲这类数据库的图解。

18
00:00:51,051 --> 00:00:55,051
我们已经掌握了CRUD操作的概念，在Rails使用的活动记录

19
00:00:55,055 --> 00:00:59,055
模型中，CRUD操作是每类模型的操作包与组成部分。

20
00:00:59,059 --> 00:01:03,059
对于控制器，我们知道使用HTTP可以与控制器通信。

21
00:01:03,063 --> 00:01:07,063
URI可完美实现表述性状态转移，可以

22
00:01:07,067 --> 00:01:09,067
编码处理资源与对该资源采取的操作，

23
00:01:09,069 --> 00:01:12,069
这就是我们指定要做什么的方法。

24
00:01:12,072 --> 00:01:16,072
这些都在脆弱的TCP/IP协议基础上发生，而对于视图， 

25
00:01:16,076 --> 00:01:20,076
我们使用HTML与CSS，借此向用户展示的操作步骤，不过我们也可以使用

26
00:01:20,080 --> 00:01:23,080
像HAML或ERB之类的模板系统来结合

27
00:01:23,083 --> 00:01:26,083
固定标记与控制器得出的步骤，大家会在接下来的

28
00:01:26,086 --> 00:01:29,086
家庭作业中看到对XML与XPath的介绍，

29
00:01:29,089 --> 00:01:33,089
你们不想呈现HTML设计供人消耗时，

30
00:01:33,093 --> 00:01:36,093
可以呈现XML设计供设备使用，

31
00:01:36,096 --> 00:01:39,096
这儿有不少好工具，

32
00:01:39,099 --> 00:01:40,099
借助它们，你可以编写应用程序生成并消耗XML，

33
00:01:40,100 --> 00:01:44,100
而这些XML，举例来说，可能来自于面向

34
00:01:44,104 --> 00:01:48,104
服务架构中的其他服务。2008年左右，

35
00:01:48,108 --> 00:01:52,108
米姆风行，这个米姆从本质上说就是Rails，只不过它不会扩展。

36
00:01:52,112 --> 00:01:56,112
你不能使用Rails构建大型应用程序。

37
00:01:56,116 --> 00:01:58,116
基于目前大家已经学到的内容，你们应该意识到

38
00:01:58,118 --> 00:02:02,118
这是个内容自由的主张。可扩展性并不是

39
00:02:02,122 --> 00:02:04,122
结构的性质。而是架构问题。

40
00:02:04,124 --> 00:02:08,124
这指的是，随着用户数量的增加，

41
00:02:08,128 --> 00:02:12,128
为增加应用程序的容量这要做出怎样的付出才能保证

42
00:02:12,132 --> 00:02:15,132
你不至于为每一位客户承担更高的成本。

43
00:02:15,135 --> 00:02:17,135
你可以继续提供性能良好的模型， 大致说来，

44
00:02:17,137 --> 00:02:22,137
每位用户的相应成本不会上升。现在我们看到

45
00:02:22,142 --> 00:02:24,142
HTTP设计的一个选择是

46
00:02:24,144 --> 00:02:28,144
保持其无状态性，同时借此基本上可以

47
00:02:28,148 --> 00:02:31,148
就一个应用程序服务器建立数个副本，

48
00:02:31,151 --> 00:02:33,151
同时将输入的请求引去你想要的任何副本。这在某种程度上

49
00:02:33,153 --> 00:02:36,153
算是明白的方法，尤其是使用云计算时，更是如此， 

50
00:02:36,156 --> 00:02:40,156
你可以为特定功能添加更多容量。我们还提到

51
00:02:40,160 --> 00:02:43,160
传统的关系数据库在扩展程度方面

52
00:02:43,163 --> 00:02:46,163
有些极为严格的限值。我们简单地提过

53
00:02:46,166 --> 00:02:49,166
替代方法，像是分片与分区，

54
00:02:49,169 --> 00:02:52,169
这是解决这些限制常用的方法，

55
00:02:52,172 --> 00:02:55,172
不过在一天结束时，关系数据库确实会出现一些限制，

56
00:02:55,175 --> 00:02:58,175
这有一部分是由提供的功能引起的。

57
00:02:58,178 --> 00:03:02,178
所以Rails无法扩展其实并不正确。另一表述是，关系数据库

58
00:03:02,182 --> 00:03:05,182
在扩展程度方面有所限制，

59
00:03:05,185 --> 00:03:09,185
也许我们可以采用一些所谓的

60
00:03:09,189 --> 00:03:12,189
无后续解决方案结合其他模型，例如数

61
00:03:12,192 --> 00:03:16,192
据映射器，来解决这个问题，从而在应用程序的相应部分内缓解扩展问题。

62
00:03:16,196 --> 00:03:20,196
我们还注意到捕捉的合理使用，

63
00:03:20,200 --> 00:03:22,200
基本上可以保留你最近计算的附近结果副本，

64
00:03:22,202 --> 00:03:26,202
在耗尽扩展规模前，有助于从数据库

65
00:03:26,206 --> 00:03:30,206
获取更多的扩展里程数。因此，这并不是说

66
00:03:30,210 --> 00:03:33,210
不能编写不良代码。

67
00:03:33,213 --> 00:03:36,213
即使有可扩展性良好的数据库，你仍可编写

68
00:03:36,216 --> 00:03:38,216
不良代码，像是[无声 03:36]，而数据库会尝试扩展。

69
00:03:38,218 --> 00:03:41,218
所以，我认为很多人说到Rails没法扩展时，

70
00:03:41,221 --> 00:03:44,221
他们想表达的是Rails支持

71
00:03:44,224 --> 00:03:47,224
架构模式的使用，这些模型里的活动记录设计模式， 

72
00:03:47,227 --> 00:03:52,227
反过来要求关系数据库支持部分最先进的功能， 

73
00:03:52,232 --> 00:03:54,232
如果这就是你正在做的事情，

74
00:03:54,234 --> 00:03:57,234
相比其他情况，鉴于不良代码会更快达到你的可扩展性限制，

75
00:03:57,237 --> 00:04:00,237
在有些情况下，编写不良代码实在不是件容易事。

76
00:04:00,000 --> 00:04:03,240
特别是，如果你是个新手，你没遵守

77
00:04:03,243 --> 00:04:06,243
这里建议的一些良好设计模式，那么

78
00:04:06,246 --> 00:04:09,246
这就是个让你一头栽进去的陷阱，可是人们却抱怨结构。

79
00:04:09,249 --> 00:04:11,249
他们本该埋怨的是，没能正确使用结构

80
00:04:11,251 --> 00:04:17,251
提供的抽象概念。

81
00:04:17,257 --> 00:04:19,257
现在回顾前面的内容，我们会发现要构建网络应用程序

82
00:04:19,259 --> 00:04:22,259
其实有多种方法，有不同的模板系统，

83
00:04:22,262 --> 00:04:25,262
还有支持哥哥选择的多个结构，

84
00:04:25,265 --> 00:04:29,265
不过网络在90年代中期成为大众消费市场的宠儿，

85
00:04:29,269 --> 00:04:32,269
那番景象就像狂野的西部。当时最大的网络服务器

86
00:04:32,272 --> 00:04:34,272
可没运行像今天的云计算一类的内容。

87
00:04:34,274 --> 00:04:37,274
它们在小型计算机上运行。老一辈可能还有人

88
00:04:37,277 --> 00:04:40,277
记得Altavista搜索引擎，这款搜索引擎

89
00:04:40,280 --> 00:04:45,280
在博士导师埃里克•布鲁尔所说的叉车式升级模型上运转，

90
00:04:45,285 --> 00:04:48,285
这个模式其实就是你增加应用程序容量的方式， 

91
00:04:48,288 --> 00:04:50,288
就好像你把东西从原来的小型计算机里提出来，

92
00:04:50,290 --> 00:04:53,290
再放入更大的小型计算机内，等到市面上在没有

93
00:04:53,293 --> 00:04:56,293
更大的小型计算机，那这就是极限容量了。

94
00:04:56,296 --> 00:04:58,296
这是你容量内的[无声 04:56]。

95
00:04:58,298 --> 00:05:01,298
事实上，当时的加州大学伯克利分校和我所在的

96
00:05:01,301 --> 00:05:04,301
教授布鲁尔研究团队对此都有所贡献，

97
00:05:04,304 --> 00:05:07,304
贡献之一就是你可从不同角度看待这些应用程序，

98
00:05:07,307 --> 00:05:09,307
你可以使用商品计算机组构建应用程序，

99
00:05:09,309 --> 00:05:13,309
随着时间的变化，上述观点，连同无状态

100
00:05:13,313 --> 00:05:16,313
与复制观点等等，一同体现在[无声05:16]中， 

101
00:05:16,316 --> 00:05:19,316
这些观点完美融合，

102
00:05:19,319 --> 00:05:21,319
最终形成了今天几乎所有应用程序的设计部署之法。

103
00:05:21,321 --> 00:05:24,321
所以我认为伯克利完全有资格

104
00:05:24,324 --> 00:05:27,324
凭借该校在网络开发方面的巨大影响力邀功。

105
00:05:27,327 --> 00:05:29,327
我相信，最有趣的事莫过于随着时间的推移， 

106
00:05:29,329 --> 00:05:33,329
当然这也是平心而论，有些个人凭借对

107
00:05:33,333 --> 00:05:37,333
上述观点的伟大实践，在一段时间内发了财。

108
00:05:37,337 --> 00:05:41,337
我想引人瞩目的不仅仅是这些模式，还有

109
00:05:41,341 --> 00:05:45,341
深入框架开展的最佳实践。

110
00:05:45,345 --> 00:05:48,345
这就是我们作为软件编程人习以为常的东西。

111
00:05:48,348 --> 00:05:51,348
一旦你动手处理的版本数量够多，

112
00:05:51,351 --> 00:05:53,351
你就会发现这些东西都具有共同性，

113
00:05:53,353 --> 00:05:56,353
要是我们能够提炼出共同的部分，其他人就不必重新开发，

114
00:05:56,356 --> 00:05:59,356
事实上这就是发明Rails的方法。Rails 

115
00:05:59,359 --> 00:06:02,359
是从指定应用程序中提取出来的，

116
00:06:02,362 --> 00:06:05,362
在构建这个程序后，作者说你知道

117
00:06:05,365 --> 00:06:08,365
其他人也可以使用构建模型视图控制器的这种特殊方法吧。

118
00:06:08,368 --> 00:06:11,368
于是他们从这个应用程序中提取出Rails框架。

119
00:06:11,371 --> 00:06:14,371
我觉得有趣的是，我们现在还在用从20世纪60年代 

120
00:06:14,374 --> 00:06:17,374
沿用至今的协议。我们现在使用的标记语言，它的祖先

121
00:06:17,377 --> 00:06:21,377
就是20世纪60年代期间面世的。我们用的浏览器，它的基本构架

122
00:06:21,381 --> 00:06:25,381
在20世纪90年代开发而成，

123
00:06:25,385 --> 00:06:29,385
不过二三十年前的网络服务器今天仍可继续使用。

124
00:06:29,389 --> 00:06:32,389
正是遵守这些分离原则、使用协议、理解

125
00:06:32,392 --> 00:06:35,392
数据序列化与反序列化支撑着

126
00:06:35,395 --> 00:06:38,395
交互操作量，这些原理实在威力无穷，

127
00:06:38,398 --> 00:06:41,398
因为这表示我们在万维网相伴的30年来

128
00:06:41,401 --> 00:06:45,401
体验的兼容度实在不同寻常。

129
00:06:45,405 --> 00:06:47,405
我在应用程序与设计模式中真切看到了

130
00:06:47,407 --> 00:06:50,407
结构的巨大价值。

131
00:06:50,410 --> 00:06:53,410
不过有时它没有得到应有的重视。最后，请记住，

132
00:06:53,413 --> 00:06:56,413
所谓架构就是在多个选项中间做选择，

133
00:06:56,416 --> 00:06:59,416
在本课内我们每次做选择时都会想办法讲解

134
00:06:59,419 --> 00:07:01,419
弃之不用的一些选项和不用的原因。

135
00:07:01,421 --> 00:07:06,421
因为我们在设计网络应用程序，所以网络就是根本的

136
00:07:06,426 --> 00:07:09,426
用户服务器系统，不过对有些系统而言

137
00:07:09,429 --> 00:07:12,429
P2P的意义可能更为重大。

138
00:07:12,432 --> 00:07:14,432
我们要就无共享的云计算进行部署。

139
00:07:14,434 --> 00:07:17,434
我们的个人设备可以处理应用程序服务器

140
00:07:17,437 --> 00:07:20,437
的数个副本，不过举个例子，科学应用

141
00:07:20,440 --> 00:07:23,440
程序中组织性能极差，这是因为应用

142
00:07:23,443 --> 00:07:26,443
程序要求在处理问题不同角度的不同

143
00:07:26,446 --> 00:07:28,446
设备间进行分享，我们使用模型视图

144
00:07:28,448 --> 00:07:31,448
控制器，是因为对于面向用户处理数据的

145
00:07:31,451 --> 00:07:34,451
应用程序而言，这是自然映射，

146
00:07:34,454 --> 00:07:36,454
不过对于较为简单的应用程序，【无声07:36】

147
00:07:36,456 --> 00:07:39,456
还有其他方法可用于组织简单的应用程序， 

148
00:07:39,459 --> 00:07:41,459
进而助你更快完成应用程序。

149
00:07:41,461 --> 00:07:45,461
Rails之所以选择使用活动记录，

150
00:07:45,465 --> 00:07:48,465
是因为我们讲部分高级功能时就会注意到，

151
00:07:48,468 --> 00:07:51,468
借助活动记录，不仅可以轻松在

152
00:07:51,471 --> 00:07:54,471
不同的模型类型间确立强大的关系，

153
00:07:54,474 --> 00:07:57,474
还可轻松操纵这些关系，

154
00:07:57,477 --> 00:08:00,477
而这全因活动记录可以利用关系数据库已经允许的操作。

155
00:08:00,000 --> 00:08:03,480
不过，出于扩展性原因， 你可能会

156
00:08:03,483 --> 00:08:06,483
面临不能使用关系数据库的困境。

157
00:08:06,486 --> 00:08:08,486
此时，最好知道像数据映射器一类的其他模式，

158
00:08:08,488 --> 00:08:12,488
这样以复杂性加大，同时放弃部分功能

159
00:08:12,492 --> 00:08:14,492
为代价，就能避开这些限制。

160
00:08:14,494 --> 00:08:18,494
最后，我们要讲讲可实现表述性状态转移的URI。

161
00:08:18,498 --> 00:08:21,498
URI可描述资源与处理资源的操作。

162
00:08:21,501 --> 00:08:24,501
它是完全独立的。你们许会注意到，

163
00:08:24,504 --> 00:08:27,504
即便是现代网络应用程序， 

164
00:08:27,507 --> 00:08:30,507
也有不少不符合此原理。相同的URI可视你上次在应用

165
00:08:30,510 --> 00:08:33,510
程序上的操作不同而处理不同对象， 

166
00:08:33,513 --> 00:08:36,513
抑或者要做到什么就必须遵守URI顺序，

167
00:08:36,516 --> 00:08:38,516
可如果你想在该顺序外发布上述URI中任何一个，

168
00:08:38,518 --> 00:08:42,518
你就只能得到一个毫无意义的结果。

169
00:08:42,522 --> 00:08:45,522
如果你想要把应用程序看成收集一堆相关服务的方式， 

170
00:08:45,525 --> 00:08:48,525
然后在你的面向服务的架构中使用相应服务，那么就会从中自然产生其他服务。

171
00:08:48,528 --> 00:08:52,528
在本课课外处理其他应用程序时，你应该思考这个问题。

172
00:08:52,532 --> 00:08:54,532
你应该选择什么样的构架，

173
00:08:54,534 --> 00:08:57,534
你应受限只能考虑哪些选项，

174
00:08:57,537 --> 00:08:59,537
无论是因为像可扩展性之类的技术限制

175
00:08:59,539 --> 00:09:01,539
还是因为需要兼容现有的系统部分， 

176
00:09:01,541 --> 00:09:04,541
在你受到限制时， 

177
00:09:04,544 --> 00:09:07,544
你应该时刻质疑架构选择，

178
00:09:07,547 --> 00:09:09,547
因为只有这样，软件才能向前发展， 

179
00:09:09,549 --> 00:09:11,549
你才会知道系统进化时在不同点的

180
00:09:11,551 --> 00:09:16,551
正确作业工具是什么。总结说来，

181
00:09:16,556 --> 00:09:18,556
我们已经看过模型视图控制器， 

182
00:09:18,558 --> 00:09:21,558
这是广为人知的架构模式，不过却不是构建面向用户的

183
00:09:21,561 --> 00:09:26,561
应用程序时唯一的架构模式。Rails选择编码化处理其MVC的结构，

184
00:09:26,566 --> 00:09:29,566
所以它作出的所有选择都是为了方便实现这类应用程序。

185
00:09:29,569 --> 00:09:31,569
如果你正在处理非MVC应用程序，

186
00:09:31,571 --> 00:09:35,571
你会发现自己正在解决Rails提供的

187
00:09:35,575 --> 00:09:37,575
内容，在这些组件执行视图的方法而言， 

188
00:09:37,577 --> 00:09:40,577
不是使用HAML就是嵌入式Ruby，先转换

189
00:09:40,580 --> 00:09:44,580
成HTML，然后浏览器才能看得见。模型存储在关系数据库内，活动记录

190
00:09:44,584 --> 00:09:47,584
可以自动支持在存储模型表示与

191
00:09:47,587 --> 00:09:50,587
数据库以及在Ruby内的操作版本间

192
00:09:50,590 --> 00:09:52,590
进行调节，控制器可以通过接去路径

193
00:09:52,592 --> 00:09:56,592
子系统将各项连在一起，

194
00:09:56,596 --> 00:09:59,596
这样就可以在控制器

195
00:09:59,599 --> 00:10:03,599
动作上映射输入的URI，同时控制器借此

196
00:10:03,603 --> 00:10:06,603
可以命名应予实例化的视图，然后将其返给用户，

197
00:10:06,606 --> 00:10:09,606
此外，控制器还可以命名插入上述视图内的数据等等。

198
00:10:09,609 --> 00:10:11,609
这样就结束了我们对高层次的学习课程。


