1
00:00:00,000 --> 00:00:08,000
关于如何开发软件以及构件软件方式的高见，

2
00:00:08,008 --> 00:00:12,008
而你们跳入了这个令人兴奋的新编程语言，

3
00:00:12,012 --> 00:00:19,012
或者不是你们，但你们需要我们很多。好吧，

4
00:00:19,019 --> 00:00:23,019
传统上，我们开发软件的第一件事，就是回忆最终文档流程，

5
00:00:23,023 --> 00:00:30,023
所以回忆一下前几个部分的内容，

6
00:00:30,030 --> 00:00:34,030
那就是，如果你通过构件软件来思考，那会是全世界最棒的，

7
00:00:34,034 --> 00:00:37,034
除非，你们知道，你可以拿你的朋友和邻居开玩笑。

8
00:00:37,037 --> 00:00:42,037
所以，你们知道，二十年构件软件，

9
00:00:42,042 --> 00:00:46,042
是的，问题是：我们可以让它变得可预测吗？

10
00:00:46,046 --> 00:00:49,046
建造一个桥梁设施，答话猫软件开发，是可靠的，

11
00:00:49,049 --> 00:00:53,049
是土木工程成本和进度。

12
00:00:53,053 --> 00:00:58,053
那么，要做什么呢。所以用它的软件，就像6岁孩子一样，

13
00:00:58,058 --> 00:01:03,058
所以拥有它的人该怎么做呢。

14
00:01:03,063 --> 00:01:06,063
而对于软件的绿化工程学科的概念，

15
00:01:06,066 --> 00:01:13,066
诞生于1969年，对，让人沮丧，开始发生灾难。

16
00:01:13,073 --> 00:01:17,073
所以我们把最终文档放在一起，

17
00:01:17,077 --> 00:01:23,077
将会有三个这样的例子，在任何人开始写之前，先提出一个观点，

18
00:01:23,083 --> 00:01:26,083
这是你建造桥梁的方式，所以对于计划的各个阶段的详细文档，

19
00:01:26,086 --> 00:01:31,086
你们要看这就是这些，

20
00:01:31,091 --> 00:01:34,091
然后你们根据计划评估项目进展状态，

21
00:01:34,094 --> 00:01:37,094
所以当你们开始构件软件，那么如果你们不是必须对项目作出改动，

22
00:01:37,097 --> 00:01:40,097
你们应该在文档中作出对计划的改动。

23
00:01:40,100 --> 00:01:44,100
所以这第一个例子，已经被称为瀑布式流程，

24
00:01:44,104 --> 00:01:48,104
是直接来自于软件工程的，也是第一个被应用的。

25
00:01:48,108 --> 00:01:52,108
这个概念，具有五个直接的阶段，

26
00:01:52,112 --> 00:01:56,112
所以不把它称为软件开发流程，

27
00:01:56,116 --> 00:02:00,116
而是称之为灯光，

28
00:02:00,000 --> 00:02:04,120
所以这种瀑布式具有泡沫，但处理器生命周期首先是写下需求，

29
00:02:04,124 --> 00:02:09,124
把需求写成一种规格，进行分析，

30
00:02:09,129 --> 00:02:13,129
对，规格。第二阶段是架构设计，

31
00:02:13,133 --> 00:02:17,133
第三阶段是构建，将部分整合在一起，

32
00:02:17,137 --> 00:02:22,137
然后进行检验，检验是确保符合了规格的要求，

33
00:02:22,142 --> 00:02:25,142
然后最终是移动操作，以及制作代替。

34
00:02:25,145 --> 00:02:29,145
所以这是一系列经典的阶段。而且你们要完成一个阶段，才能进入下一个阶段，

35
00:02:29,149 --> 00:02:32,149
其想法就是，他们发现，真的发现是，

36
00:02:32,152 --> 00:02:36,152
局限于架构阶段，它比检验阶段成本小很多。

37
00:02:36,156 --> 00:02:41,156
而且因为最后一年分布式软件项目，

38
00:02:41,161 --> 00:02:44,161
在它们部分有大量的文档，

39
00:02:44,164 --> 00:02:48,164
所以当你们员工在结束的时候，可以得到一个速度，

40
00:02:48,168 --> 00:02:53,168
所以故事就是这样的。

41
00:02:53,173 --> 00:02:57,173
所以生命周期的第一个软件开发流程，为何会不起作用呢。

42
00:02:57,177 --> 00:03:01,177
好吧，这里有一些某人匿名发布的内容，用户都时不时带着笑声惊呼。

43
00:03:01,181 --> 00:03:05,181
这是我们所要求的，但不是你们想要的，是的，

44
00:03:05,185 --> 00:03:09,185
所以当你们跟客户打交道时，通常会发生的情况是，

45
00:03:09,189 --> 00:03:12,189
他们不知道他们想要什么。

46
00:03:12,192 --> 00:03:15,192
而当你们做出了什么东西，在开始运行之后，他们才意识到：

47
00:03:15,195 --> 00:03:19,195
我不知道我们想要什么，情况就是这样，是的。

48
00:03:19,199 --> 00:03:23,199
所以在瀑布式流程中，会发生的就是，你会遇到问题，

49
00:03:23,203 --> 00:03:30,203
因为数字，而且他们会改变主意，另一个来自弗雷德•布鲁克斯。

50
00:03:30,210 --> 00:03:34,210
他的阶段就是，无论如何，抛弃第一个实现的成果。所以布鲁克斯是我个人心中英雄之一，

51
00:03:34,214 --> 00:03:37,214
我们会跟他打几次电话，但他获得了诺贝尔计算机科学奖。

52
00:03:37,217 --> 00:03:42,217
也是这些东西的作者。

53
00:03:42,222 --> 00:03:46,222
听着，软件可以被称为是神秘的，而基本上的情况就是，

54
00:03:46,226 --> 00:03:50,226
大多数开发者都是第一种，后来我就实现了一个想法，

55
00:03:50,230 --> 00:03:53,230
而如果你们用了他们的方式，最好开始做，

56
00:03:53,233 --> 00:03:57,233
所以这差不多就是软件生命周期的问题所在，

57
00:03:57,237 --> 00:04:01,237
他们会给我的客户做软件，

58
00:04:01,241 --> 00:04:06,241
然后在他们做好后，才发现了正确的做法。

59
00:04:06,246 --> 00:04:10,246
这也产生了下一种生命周期，叫做螺旋式。它试图结合瀑布式的特点，

60
00:04:10,250 --> 00:04:14,250
需要大量的计划与文档，

61
00:04:14,254 --> 00:04:19,254
以及构建原型和迭代和原型。

62
00:04:19,259 --> 00:04:24,259
所以你们要做的，就是把所有文档都留给B.U. 不时所有的文档，甚至是迭代。

63
00:04:24,264 --> 00:04:28,264
下面就让我们来看看这张图，

64
00:04:28,268 --> 00:04:31,268
这四个象限表示的是你构建创业公司所要经历的过程，

65
00:04:31,271 --> 00:04:34,271
包括确定的目标与限制，

66
00:04:34,274 --> 00:04:38,274
然后下一步就是评估一堆选择，

67
00:04:38,278 --> 00:04:43,278
并识别出项目将面临的所有风险，然后找出结果，

68
00:04:43,283 --> 00:04:48,283
然后下一个阶段就是开发验证原型验证方法，

69
00:04:48,288 --> 00:04:51,288
你们知道，这一部分会设计共同的客户。

70
00:04:51,291 --> 00:04:55,291
然后你们获得反馈，然后再进行下一次迭代，

71
00:04:55,295 --> 00:04:59,295
所以我们在这里遇到改动，然后一次又一次，

72
00:04:59,299 --> 00:05:06,299
直到最终原型，然后就得到了产品，

73
00:05:06,306 --> 00:05:10,306
我们要看看它能否正常工作。那么有什么好处有什么坏处呢，

74
00:05:10,310 --> 00:05:15,310
客户的迭代较好，

75
00:05:15,315 --> 00:05:18,315
在你做这个东西时，客户不太可能会改变主意。

76
00:05:18,318 --> 00:05:21,318
所以他们会把它视为球，减少癌症的误解风险管理，这是一件好事，

77
00:05:21,321 --> 00:05:24,321
这可以算是来自商学院的，

78
00:05:24,324 --> 00:05:27,324
你会认出最近的舞步，然后尽量避免，

79
00:05:27,327 --> 00:05:30,327
这是生命周期的一部分。

80
00:05:30,330 --> 00:05:33,330
很容易进行中等0母项目，瀑布式应当是分为不同的阶段，

81
00:05:33,333 --> 00:05:36,333
你们将四处走走，来看在第二种或第三种里面你们所处的位置， 

82
00:05:36,336 --> 00:05:42,336
而你们的时间表与成本预测应该随着时间变得更加现实。

83
00:05:42,342 --> 00:05:45,342
你们会对在座客户更加熟悉，了解想法，

84
00:05:45,345 --> 00:05:49,345
因为如果，是啊，但是这些是迭代，

85
00:05:49,349 --> 00:05:52,349
一个很长的过程，可能从半年到五十年不等，

86
00:05:52,352 --> 00:05:55,352
时间非常长，长得足够让客户改变你的想法了，

87
00:05:55,355 --> 00:06:00,355
如果迭代之间要花一年，每一次迭代都会有很多文档，

88
00:06:00,000 --> 00:06:03,360
每次迭代都有一套文档，

89
00:06:03,363 --> 00:06:07,363
其中有你要遵循的规则，技能，在这四个阶段里，

90
00:06:07,367 --> 00:06:09,367
你不应该在做一个阶段时去做另一个，

91
00:06:09,369 --> 00:06:12,369
除非你进入了下一阶段，总会诱惑你跳过步骤。

92
00:06:12,372 --> 00:06:16,372
所以，一部分产品坚持下去，因为在原型的建造中，

93
00:06:16,376 --> 00:06:21,376
所有的文档成本都非常高。

94
00:06:21,381 --> 00:06:26,381
而且，事实证明，预算时间表对我们来说很难，是的，所以，

95
00:06:26,386 --> 00:06:31,386
瀑布式，螺旋式，第三个例子，则又是在15年之后，

96
00:06:31,391 --> 00:06:35,391
在引入螺旋式和瀑布式15年之后，

97
00:06:35,395 --> 00:06:39,395
于是出现了统一软件开发过程。它并不是理性的，

98
00:06:39,399 --> 00:06:42,399
因为，其他的才是理性的，理性（Rational）这个是

99
00:06:42,402 --> 00:06:46,402
想出了统一软件开发过程的公司的名字。所以在这里，

100
00:06:46,406 --> 00:06:50,406
你可以在这个设计里看到，这些阶段都跨过顶部。

101
00:06:50,410 --> 00:06:52,410
然后它们有着被称为工程要求的东西，

102
00:06:52,412 --> 00:06:56,412
你们会独特的跨过底部，所以待会儿我会回来继续放幻灯片，

103
00:06:56,416 --> 00:06:59,416
在这些空间建造者之间，你们会有多个迭代，

104
00:06:59,419 --> 00:07:04,419
以细化构造，以及这些天

105
00:07:04,424 --> 00:07:07,424
在第一个阶段，你们要想出软件破坏模型的商业案例，

106
00:07:07,427 --> 00:07:12,427
要比较贴近商业流程。

107
00:07:12,432 --> 00:07:15,432
所以明智构造的商业案例是什么呢，

108
00:07:15,435 --> 00:07:18,435
因为这并不会永远都能满足。这时要为项目建立时间表和预算，

109
00:07:18,438 --> 00:07:22,438
还要对事情进行风险评估，

110
00:07:22,442 --> 00:07:27,442
这样，要么成本预算，要么计划时间表，

111
00:07:27,447 --> 00:07:31,447
这些约束尝试和评估

112
00:07:31,451 --> 00:07:35,451
第二阶段，协作话语，你们开发使用案例，

113
00:07:35,455 --> 00:07:38,455
稍后要聊聊这些部分，差不多是你们使用软件开发软件的方式，

114
00:07:38,458 --> 00:07:41,458
开发软件的架构，待会儿我们来说说，

115
00:07:41,461 --> 00:07:44,461
架构构建软件工程的重要性。

116
00:07:44,464 --> 00:07:48,464
而你们构建了第一个基础原型，该空间的糕点构造，

117
00:07:48,468 --> 00:07:51,468
你们要进行涂装，你们要测试产品，

118
00:07:51,471 --> 00:07:55,471
而且你们其实在最后一个叫做交付的阶段，才最初发布产品，

119
00:07:55,475 --> 00:07:59,475
在这个阶段，你们要进入真实环境，在那里运行软件，

120
00:07:59,479 --> 00:08:02,479
让客户签署客户认可。

121
00:08:02,482 --> 00:08:07,482
所以这些就是工程原则的四个阶段，

122
00:08:07,487 --> 00:08:09,487
在生命周期里你们都将需要其各种商业模型，

123
00:08:09,489 --> 00:08:12,489
这是让商业案例进行需求分析设计实施

124
00:08:12,492 --> 00:08:16,492
好的。

125
00:08:16,496 --> 00:08:20,496
那么让我们回来，用一张幻灯片来看看所有这些。

126
00:08:20,500 --> 00:08:24,500
所以，这里是需求，我们可以看到商业模式在初始阶段发挥着更重要的作用，

127
00:08:24,504 --> 00:08:28,504
也就是在初始的合作时，

128
00:08:28,508 --> 00:08:32,508
可以建议部署在目前是配置文件，在最后构造的末尾，

129
00:08:32,512 --> 00:08:37,512
在交付阶段开始的时候，进行迭代，

130
00:08:37,517 --> 00:08:41,517
你们其实可以开始测试，进行定期发布

131
00:08:41,521 --> 00:08:46,521
很多更加不同的实施，

132
00:08:46,526 --> 00:08:49,526
这样你们的团队就拥有这技能了，

133
00:08:49,529 --> 00:08:54,529
在以后你们会更加需要这些技能。

134
00:08:54,534 --> 00:09:04,534
所以，有什么，是的，使用正确的模型有什么好处呢，好的，

135
00:09:04,544 --> 00:09:06,544
训练业务流程，因为你们构建的软件，

136
00:09:06,546 --> 00:09:09,546
有活跃的商业案例，

137
00:09:09,549 --> 00:09:14,549
这与其他的很多工具联系更为密切，

138
00:09:14,554 --> 00:09:17,554
Rational是一家生成工具的公司，用来销售叫做计算机辅助软件工程（CASE）工具，

139
00:09:17,557 --> 00:09:20,557
这些工具非常贵，几万美元。

140
00:09:20,560 --> 00:09:25,560
有一个想法，但是也有想法是，这些工具可以支持

141
00:09:25,565 --> 00:09:30,565
随着时间的推移进行合理改进项目，

142
00:09:30,570 --> 00:09:33,570
你们知道，这是上万美元的工具，是开源版本，

143
00:09:33,573 --> 00:09:36,573
除非你给Rational付更多的钱，不然用不了这些工具。

144
00:09:36,576 --> 00:09:40,576
有很多定制的方法，你们知道，

145
00:09:40,580 --> 00:09:44,580
多少阶段氢气，但你们也可能不会导致工具强度，

146
00:09:44,584 --> 00:09:48,584
只为大项目而用它们，因为你们知道，这些很贵，

147
00:09:48,588 --> 00:09:52,588
自动决定一次迭代是如何在阶段内进行的，钠经验，

148
00:09:52,592 --> 00:09:55,592
事实上，关于这些项目，真正的情况是，

149
00:09:55,595 --> 00:10:01,595
它们需要有一个强大的项目经理，

150
00:10:01,601 --> 00:10:05,601
这个人要会写合同，从客户那里赢得项目，

151
00:10:05,605 --> 00:10:10,605
他还要会招人，从公司内部雇佣新人

152
00:10:10,610 --> 00:10:14,610
他将是你的老板，

153
00:10:14,614 --> 00:10:17,614
他会评估所有程序员的表现，限制影响，不好意思。

154
00:10:17,617 --> 00:10:21,617
而且在这里，他要负责进行

155
00:10:21,621 --> 00:10:24,621
估计成本、符合时间表，在此，我们中的一个，

156
00:10:24,624 --> 00:10:28,624
如何三人专栏作家，都是经理。

157
00:10:28,628 --> 00:10:32,628
而且他们要在管理计划里把一切都记录下来，

158
00:10:32,632 --> 00:10:37,632
差不多是老板获得成功采样，如果超出预算，

159
00:10:37,637 --> 00:10:42,637
这些团队的对接方法往往会变得更大，主要通过扩张另一件事，

160
00:10:42,642 --> 00:10:46,642
这件事，弗雷德•布鲁克斯在《人月神话》中说，

161
00:10:46,646 --> 00:10:49,646
是给后期项目增加人手。

162
00:10:49,649 --> 00:10:53,649
所以这就是他，在幕后洞察到的事情，

163
00:10:53,653 --> 00:10:56,653
我们实际上要做的，人们会说，

164
00:10:56,656 --> 00:11:00,656
我们带人过来，或者你们的人学习项目和其他事情需要花时间。

165
00:11:00,000 --> 00:11:04,660
因此，它需要一段时间有用，

166
00:11:04,664 --> 00:11:07,664
而沟通随着项目里的人数上升也会增加。

167
00:11:07,667 --> 00:11:11,667
因此，项目越大，就需要越多的沟通，工作的时间就越少。

168
00:11:11,671 --> 00:11:14,671
所以你可以扩张到更大的团队，到肯尼迪的规模，

169
00:11:14,674 --> 00:11:18,674
但是不能太大，这样就不会错过改变的时间，

170
00:11:18,678 --> 00:11:20,678
然后你仍然较高。

