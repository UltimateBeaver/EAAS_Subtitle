1
00:00:00,000 --> 00:00:08,000
关于如何开发软件以及构件软件方式的高见，

2
00:00:08,008 --> 00:00:12,008
而你们开始了这个令人兴奋的新编程语言，

3
00:00:12,012 --> 00:00:19,012
好吧，也许对有些人不是新的，但对大多数人是新的。

4
00:00:19,019 --> 00:00:23,019
传统上，我们开发软件的第一种模式，我们成为“计划－文档”流程，，

5
00:00:23,023 --> 00:00:30,023
所以回忆一下前几个部分的内容，

6
00:00:30,030 --> 00:00:34,030
那就是，你可能获得很多不好的恶习。你可以说写软件是全世界最棒的工作，

7
00:00:34,034 --> 00:00:37,034
但是，你们知道，你的朋友和邻居会嘲笑你。

8
00:00:37,037 --> 00:00:42,037
写了二十年代码，

9
00:00:42,042 --> 00:00:46,042
我们提出这样一个问题，问题是：我们可以让它变得可预测吗？

10
00:00:46,046 --> 00:00:49,046
就像构建一个类似桥梁设施的软件是可靠的，

11
00:00:49,049 --> 00:00:53,049
土木工程成本和进度都是能预测的。

12
00:00:53,053 --> 00:00:58,053
那么，要做什么呢。软件工程这个学科那时候就像6岁孩子一样不成熟，

13
00:00:58,058 --> 00:01:03,058
总有人需要发明出一种方法。

14
00:01:03,063 --> 00:01:06,063
这种让工程制度进入软件工程开发领域的想法

15
00:01:06,066 --> 00:01:13,066
诞生于1969年，对，让人沮丧地是，旋即开始发生灾难。

16
00:01:13,073 --> 00:01:17,073
所以我们会有总共三个“计划－文档”的例子，

17
00:01:17,077 --> 00:01:23,077
这种模式是这样工作的：在任何人开始写之前，先提出一个计划，

18
00:01:23,083 --> 00:01:26,083
类似建造桥梁的模式。

19
00:01:26,086 --> 00:01:31,086
对于计划的各个阶段写出详细文档，

20
00:01:31,091 --> 00:01:34,091
然后你们根据计划评估项目进展状态，

21
00:01:34,094 --> 00:01:37,094
所以当你们已经开始构件软件，但是必须对项目作出改动，

22
00:01:37,097 --> 00:01:40,097
你们应该首先在文档中作出对计划的改动。

23
00:01:40,100 --> 00:01:44,100
所以这第一个例子，现在被称为瀑布式流程，

24
00:01:44,104 --> 00:01:48,104
是直接来自于软件工程的，也是第一个被应用的。

25
00:01:48,108 --> 00:01:52,108
这个概念，具有五个直接的阶段，

26
00:01:52,112 --> 00:01:56,112
所以不把它称为软件开发流程，

27
00:01:56,116 --> 00:02:00,116
而是称之为生命周期，

28
00:02:00,000 --> 00:02:04,120
首先是写下需求，

29
00:02:04,124 --> 00:02:09,124
把需求写成规格说明，进行分析，

30
00:02:09,129 --> 00:02:13,129
对，规格说明。第二阶段是架构设计，

31
00:02:13,133 --> 00:02:17,133
第三阶段是构建，将部分整合在一起，

32
00:02:17,137 --> 00:02:22,137
然后进行检验，检验是确保符合了规格的要求，

33
00:02:22,142 --> 00:02:25,142
然后最终是上线和维护阶段。

34
00:02:25,145 --> 00:02:29,145
所以这是一系列经典的阶段。而且你们要完成一个阶段，才能进入下一个阶段，

35
00:02:29,149 --> 00:02:32,149
其中一个想法就是，如果能更早地发现漏洞，

36
00:02:32,152 --> 00:02:36,152
比如在架构阶段就发现漏洞，它比检验阶段才发现漏洞成本小很多。

37
00:02:36,156 --> 00:02:41,156
而且因为构建软件旷日持久，

38
00:02:41,161 --> 00:02:44,161
在它们有大量文档，

39
00:02:44,164 --> 00:02:48,164
所以当新员工加入项目的时候，可以看文档来追上大家的进度，

40
00:02:48,168 --> 00:02:53,168
所以故事就是这样的。

41
00:02:53,173 --> 00:02:57,173
所以生命周期是第一中软件开发流程，为何会不起作用呢。

42
00:02:57,177 --> 00:03:01,177
好吧，这里有一些某人匿名发布的内容：用户带着嘲笑说，

43
00:03:01,181 --> 00:03:05,181
这是我们所要求的，但不是我们想要的，是吧？

44
00:03:05,185 --> 00:03:09,185
所以当你们跟客户打交道时，通常会发生的情况是，

45
00:03:09,189 --> 00:03:12,189
他们不知道他们想要什么。

46
00:03:12,192 --> 00:03:15,192
而当你们做出了什么东西，在开始运行之后，他们才意识到：

47
00:03:15,195 --> 00:03:19,195
我不知道我们想要什么，但肯定不是这样的。

48
00:03:19,199 --> 00:03:23,199
所以在瀑布式流程中，会发生的就是，你花了好几年写出了一个软件

v49
00:03:23,203 --> 00:03:30,203
你拿给客户看，但是他们改变主意了，另一个来自弗雷德•布鲁克斯。

50
00:03:30,210 --> 00:03:34,210
他的经验就是，无论如何，抛弃第一个实现。所以布鲁克斯是我个人心中英雄之一，

51
00:03:34,214 --> 00:03:37,214
我们会跟他打几次电话，但他获得了计算机界的诺贝尔奖（大概是图灵奖的意思）。

52
00:03:37,217 --> 00:03:42,217
他写了一本著名的关于软件开发工程的书。

53
00:03:42,222 --> 00:03:46,222
叫做《人月神话》，而基本上的情况就是，

54
00:03:46,226 --> 00:03:50,226
大多数开发者都是第一次想出了一个方法，实现的过程中想出了更好的方法

55
00:03:50,230 --> 00:03:53,230
如果把第一次的工作直接舍弃，他们往往可以做得更好，

56
00:03:53,233 --> 00:03:57,233
所以这差不多就是软件生命周期的问题所在，

57
00:03:57,237 --> 00:04:01,237
他们会给我的客户做软件，

58
00:04:01,241 --> 00:04:06,241
然后在他们做好后，才发现了正确的做法。

59
00:04:06,246 --> 00:04:10,246
这也产生了下一种生命周期，叫做螺旋式。它试图结合瀑布式的特点，

60
00:04:10,250 --> 00:04:14,250
需要大量的计划与文档，

61
00:04:14,254 --> 00:04:19,254
以及构建原型和迭代和原型。

62
00:04:19,259 --> 00:04:24,259
所以你们要做的，就是在迭代中. 时不时地处理所有的文档。

63
00:04:24,264 --> 00:04:28,264
下面就让我们来看看这张图，

64
00:04:28,268 --> 00:04:31,268
这四个象限表示的是你构建创业公司所要经历的过程，

65
00:04:31,271 --> 00:04:34,271
包括确定的目标与限制，

66
00:04:34,274 --> 00:04:38,274
然后下一步就是评估一堆选择，

67
00:04:38,278 --> 00:04:43,278
并识别出项目将面临的所有风险，然后找出结果，

68
00:04:43,283 --> 00:04:48,283
然后下一个阶段就是开发验证原型验证方法，

69
00:04:48,288 --> 00:04:51,288
你们知道，这一部分会与客户一同参与。

70
00:04:51,291 --> 00:04:55,291
然后你们获得反馈，然后再进行下一次迭代，

71
00:04:55,295 --> 00:04:59,295
所以我们在这里遇到改动，然后一次又一次，

72
00:04:59,299 --> 00:05:06,299
直到最终原型，然后就得到了产品，

73
00:05:06,306 --> 00:05:10,306
我们要看看它能否正常工作。那么有什么好处有什么坏处呢，

74
00:05:10,310 --> 00:05:15,310
迭代中的参与程度比较高，

75
00:05:15,315 --> 00:05:18,315
在你做这个东西时，客户不太可能会改变主意。

76
00:05:18,318 --> 00:05:21,318
所以他们会把它视为很好的减少误解的风险管理，这是一件好事，

77
00:05:21,321 --> 00:05:24,321
这可以算是来自商学院的一种想法，

78
00:05:24,324 --> 00:05:27,324
你会发现最近的风险，然后尽量避免，

79
00:05:27,327 --> 00:05:30,327
这是生命周期的一部分。

80
00:05:30,330 --> 00:05:33,330
很容易调整其他项目，使得过程分为不同的阶段，

81
00:05:33,333 --> 00:05:36,333
你们将看看，比如当前是否在第二或第三阶段中， 

82
00:05:36,336 --> 00:05:42,336
而你们的时间表与成本预测应该随着时间变得更加准确。

83
00:05:42,342 --> 00:05:45,342
你们会对在座客户更加熟悉，了解想法，

84
00:05:45,345 --> 00:05:49,345
但是这些是迭代，

85
00:05:49,349 --> 00:05:52,349
一个很长的过程，可能从半年到五十年不等，

86
00:05:52,352 --> 00:05:55,352
时间非常长，长得足够让客户改变你的想法了，

87
00:05:55,355 --> 00:06:00,355
如果迭代之间要花一年，每一次迭代都会有很多文档，

88
00:06:00,000 --> 00:06:03,360
每次迭代都有一套文档，

89
00:06:03,363 --> 00:06:07,363
其中有你要遵循的规则，技能，在这四个阶段里，

90
00:06:07,367 --> 00:06:09,367
你不应该在做一个阶段时去做另一个，

91
00:06:09,369 --> 00:06:12,369
除非你进入了下一阶段。你总会想跳过步骤。

92
00:06:12,372 --> 00:06:16,372
所以，一部分产品坚持这种方式，因为原型和

93
00:06:16,376 --> 00:06:21,376
这些文档成本都非常高。

94
00:06:21,381 --> 00:06:26,381
而且，事实证明，预算时间表对我们来说很难。

95
00:06:26,386 --> 00:06:31,386
瀑布式，螺旋式。第三个例子是在15年之后，

96
00:06:31,391 --> 00:06:35,391
在引入螺旋式和瀑布式15年之后，

97
00:06:35,395 --> 00:06:39,395
于是出现了理性统一软件开发过程。它并不因为是理性的，

98
00:06:39,399 --> 00:06:42,399
名字里才有理性，理性（Rational）是

99
00:06:42,402 --> 00:06:46,402
想出了统一软件开发过程的公司的名字。所以在这里，

100
00:06:46,406 --> 00:06:50,406
你可以在这个设计里看到，这些阶段都跨过顶部。

101
00:06:50,410 --> 00:06:52,410
然后它们有着被称为工程要求的东西，

102
00:06:52,412 --> 00:06:56,412
你们会独特的跨过底部，所以待会儿我会回来继续放幻灯片，

103
00:06:56,416 --> 00:06:59,416
在这些阶段之间，你们会有多个迭代，

104
00:06:59,419 --> 00:07:04,419
以细化构造，以及这些天

105
00:07:04,424 --> 00:07:07,424
在第一个阶段，你们要想出软件商业模型，

106
00:07:07,427 --> 00:07:12,427
这个过程比较贴近商业流程。

107
00:07:12,432 --> 00:07:15,432
所以我们应该投资多少这里的回报能有多少，

108
00:07:15,435 --> 00:07:18,435
这时要为项目建立时间表和预算，

109
00:07:18,438 --> 00:07:22,438
还要对事情进行风险评估，

110
00:07:22,442 --> 00:07:27,442
成本预算，计划时间表，

111
00:07:27,447 --> 00:07:31,447
这些因素的评估

112
00:07:31,451 --> 00:07:35,451
第二阶段，详尽地阐述需求，你们创建使用案例，

113
00:07:35,455 --> 00:07:38,455
稍后要说这些部分。这差不多是你们使用软件开发软件的方式，

114
00:07:38,458 --> 00:07:41,458
开发软件的架构，待会儿我们也会说

115
00:07:41,461 --> 00:07:44,461
架构对构建软件工程的重要性。

116
00:07:44,464 --> 00:07:48,464
而你们构建了第一个基础原型，

117
00:07:48,468 --> 00:07:51,468
你们要进行集成，你们要测试产品，

118
00:07:51,471 --> 00:07:55,471
而且你们其实在最后一个叫做交付的阶段，才发布产品，

119
00:07:55,475 --> 00:07:59,475
在这个阶段，你们要在真实环境中运行软件，

120
00:07:59,479 --> 00:08:02,479
最后客户验收。

121
00:08:02,482 --> 00:08:07,482
所以这些就是工程原则的四个阶段，

122
00:08:07,487 --> 00:08:09,487
在各种商业模型的生命周期中都会遇到，

123
00:08:09,489 --> 00:08:12,489
根据商业案例，进行需求分析、设计和实现

124
00:08:12,492 --> 00:08:16,492
好的。

125
00:08:16,496 --> 00:08:20,496
那么让我们回来，用一张幻灯片来看看所有这些。

126
00:08:20,500 --> 00:08:24,500
所以，这里是需求，我们可以看到商业模式在初始阶段

127
00:08:24,504 --> 00:08:28,504
发挥着更重要的作用，

128
00:08:28,508 --> 00:08:32,508
而差不多在需求阐述阶段的末尾结束，

129
00:08:32,512 --> 00:08:37,512
运行则差不多是相反的，

130
00:08:37,517 --> 00:08:41,517
在测试阶段的后段才开始，直到发布

131
00:08:41,521 --> 00:08:46,521
测试周期性地在每个阶段的结尾发生。

132
00:08:46,526 --> 00:08:49,526
这样你们的团队就拥有这技能了，

133
00:08:49,529 --> 00:08:54,529
在以后你们会更加需要这些技能。

134
00:08:54,534 --> 00:09:04,534
所以，使用这个模型有什么好处和坏处呢

135
00:09:04,544 --> 00:09:06,544
和实际商业情况紧密相关

136
00:09:06,546 --> 00:09:09,546
有活跃的商业案例，

137
00:09:09,549 --> 00:09:14,549
这比其他的很多工具联系更为密切，

138
00:09:14,554 --> 00:09:17,554
Rational是一家生成工具的公司，用来销售叫做计算机辅助软件工程（CASE）工具，

139
00:09:17,557 --> 00:09:20,557
这些工具非常贵，几万美元。

140
00:09:20,560 --> 00:09:25,560
有一个想法，但是也有想法是，这些工具可以

141
00:09:25,565 --> 00:09:30,565
随着时间的推移合理地改进项目，

142
00:09:30,570 --> 00:09:33,570
你们知道，这是上万美元的工具，是开源版本，

143
00:09:33,573 --> 00:09:36,573
除非你给Rational付更多的钱，不然用不了这些工具。

144
00:09:36,576 --> 00:09:40,576
有很多定制的方法，你们知道，

145
00:09:40,580 --> 00:09:44,580
多少阶段氢气，但你们也可能不会导致工具强度，

146
00:09:44,584 --> 00:09:48,584
只为大项目才能使用它们，因为你们知道，这些东西很贵，

147
00:09:48,588 --> 00:09:52,588
能自动决定一次迭代是如何在阶段内进行的，

148
00:09:52,592 --> 00:09:55,592
事实上，关于这些项目，真正的情况是，

149
00:09:55,595 --> 00:10:01,595
它们需要有一个强大的项目经理，

150
00:10:01,601 --> 00:10:05,601
这个人要会写合同，从客户那里赢得项目，

151
00:10:05,605 --> 00:10:10,605
他还要会招人，从公司内部雇佣新人

152
00:10:10,610 --> 00:10:14,610
他将是你的老板，

153
00:10:14,614 --> 00:10:17,614
他会评估所有程序员的表现和做出限制。

154
00:10:17,617 --> 00:10:21,617
而且在这里，他要负责进行

155
00:10:21,621 --> 00:10:24,621
成本和进度的评估，

156
00:10:24,624 --> 00:10:28,624
还有风险规避，都是经理的责任。

157
00:10:28,628 --> 00:10:32,628
而且他们要在管理计划里把一切都记录下来，

158
00:10:32,632 --> 00:10:37,632
差不多是获得成功的话是老板的功劳。如果超出预算，也是他的责任

159
00:10:37,637 --> 00:10:42,637
这种团队往往规模会变大，主要原因是另一件更大的事，

160
00:10:42,642 --> 00:10:46,642
这件事，弗雷德•布鲁克斯在《人月神话》中说，

161
00:10:46,646 --> 00:10:49,646
是给已经超时的项目增加人手会让它延误得更久。

162
00:10:49,649 --> 00:10:53,649
所以这就是他，在观察到的事情，

163
00:10:53,653 --> 00:10:56,653
当事情来不及的时候，人们会说，

164
00:10:56,656 --> 00:11:00,656
带更多人过来，但是你们的人学习项目和其他事情需要花时间。

165
00:11:00,000 --> 00:11:04,660
因此，需要一段时间他们才能起作用，

166
00:11:04,664 --> 00:11:07,664
而沟通随着项目里的人数上升也会增加。

167
00:11:07,667 --> 00:11:11,667
因此，项目越大，就需要越多的沟通，工作的时间就越少。

168
00:11:11,671 --> 00:11:14,671
所以你可以扩张到更大的团队

169
00:11:14,674 --> 00:11:18,674
但是不能太大，这样就不会花太多时间在沟通上，

170
00:11:18,678 --> 00:11:20,678


