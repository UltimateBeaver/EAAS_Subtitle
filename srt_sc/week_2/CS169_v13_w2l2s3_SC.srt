1
00:00:00,000 --> 00:00:04,000
我们来谈谈Ruby中真正的面向对象。

2
00:00:04,004 --> 00:00:08,004
我一直在说，一切都是对象，

3
00:00:08,008 --> 00:00:12,008
一切都是方法调用，Ruby是一种动态语言，那问题是，

4
00:00:12,012 --> 00:00:13,012
你们为什么要注意这些呢？

5
00:00:13,013 --> 00:00:17,013
它怎么简化面向对象的编程？

6
00:00:17,017 --> 00:00:21,017
我们用一个简单的例子来说明。我将定义一个储蓄帐户，

7
00:00:21,021 --> 00:00:24,021
假设我说它继承了一个现有的类，叫“帐户”，

8
00:00:24,024 --> 00:00:26,024
而我们现在并没有类存在。

9
00:00:26,026 --> 00:00:29,026
我只是想让你们知道继承的语法。

10
00:00:29,029 --> 00:00:32,029
当然，我需要一个构造函数，在Ruby语言里，

11
00:00:32,032 --> 00:00:36,032
类的默认构造函数叫做"initialize"。为什么叫"initialize"，

12
00:00:36,036 --> 00:00:38,036
而你们却用"new"调用它？世界就是这样的。孩子们，抱歉。

13
00:00:38,038 --> 00:00:42,038
这个构造函数要做什么呢？

14
00:00:42,042 --> 00:00:45,042
它要接受一个参数，即初始余额。注意，

15
00:00:45,045 --> 00:00:49,045
由于在函数定义中给了参数一个可选值或者默认值，

16
00:00:49,049 --> 00:00:53,049
我可以在无参数的情况下调用新函数，

17
00:00:53,053 --> 00:00:56,053
这时余额会默认为0.

18
00:00:56,056 --> 00:01:00,056
就是说在Ruby中，可以有带默认值的可选参数。

19
00:01:00,000 --> 00:01:03,060
当我调用构造函数时，它会接受我传入的余额，

20
00:01:03,063 --> 00:01:07,063
并将其赋值给实例变量。

21
00:01:07,067 --> 00:01:10,067
在很久之前的一堂课上，我们说过实例变量以单个@符号开头，

22
00:01:10,070 --> 00:01:14,070
所以@balance是一个实例变量，

23
00:01:14,074 --> 00:01:17,074
不要与普通的balance混淆，那是不带@符号的。

24
00:01:17,077 --> 00:01:20,077
那只是一个普通的局部变量，一旦我们不在函数范围内，它就会消失。

25
00:01:20,080 --> 00:01:22,080
所以这就是构造函数的唯一作用。

26
00:01:22,082 --> 00:01:26,082
现在我们有了一个局部变量，或者用Java的术语来说是

27
00:01:26,086 --> 00:01:30,086
实例变量，来追踪帐户余额值，

28
00:01:30,090 --> 00:01:33,090
当然了，我们还要能访问这个值。

29
00:01:33,093 --> 00:01:35,093
和JAVA及其他一些语言不同的是，这里没有公共属性的概念。

30
00:01:35,095 --> 00:01:39,095
@balance这一实例变量

31
00:01:39,099 --> 00:01:42,099
仅在这个特定的对象实例中可见。

32
00:01:42,102 --> 00:01:46,102
如果对象外（当然也在类之外）的人

33
00:01:46,106 --> 00:01:50,106
想访问这一信息，必须定义一个访问器。

34
00:01:50,110 --> 00:01:54,110
这就是我的简单访问器。哇喔，希望你们听懂了。

35
00:01:54,114 --> 00:01:58,114
它的作用就是返回...顺便说一句，在Ruby函数中，

36
00:01:58,118 --> 00:02:01,118
如果没有显式的返回语句，

37
00:02:01,121 --> 00:02:04,121
函数中计算的最后一个表达式的值就是返回值。

38
00:02:04,124 --> 00:02:07,124
一切都有一个返回值，如果你不说返回，

39
00:02:07,127 --> 00:02:10,127
你得到的就是计算的最后一个表达式。

40
00:02:10,130 --> 00:02:14,130
这就是我的非常简单的访问器，你愿意的话也可以叫它getter。

41
00:02:14,134 --> 00:02:17,134
我还需要一个设置余额的办法。谁知道呢？

42
00:02:17,137 --> 00:02:21,137
说不定我想通过我的银行帐户洗钱。这里又有一个函数，

43
00:02:21,141 --> 00:02:25,141
balance= 是一种方法名称。还记得吗？

44
00:02:25,145 --> 00:02:29,145
我说过一切都是方法调用。这里可要认真起来了。

45
00:02:29,149 --> 00:02:32,149
balance= 是一种与balance不同的方法。

46
00:02:32,152 --> 00:02:36,152
Ruby的一个特殊之处就是以=结尾的方法，

47
00:02:36,156 --> 00:02:39,156
这也是你定义自己的setter的方法。那么balance= 会接受一个新的数额，

48
00:02:39,159 --> 00:02:42,159
并将实例变量设置为那个数额。

49
00:02:42,162 --> 00:02:44,162
当然，真正的银行帐户可没这么容易给自己加钱，

50
00:02:44,164 --> 00:02:47,164
所以我们要现实一点。

51
00:02:47,167 --> 00:02:50,167
我们也可以存钱。很简单，只要将存款数额

52
00:02:50,170 --> 00:02:55,170
加到实例变量balance上。

53
00:02:55,175 --> 00:02:58,175
我们也可以有类变量。比如说银行的名称可以是

54
00:02:58,178 --> 00:03:01,178
独立于任何特定实例的变量，

55
00:03:01,181 --> 00:03:05,181
我们把它们和@@放在一起。

56
00:03:05,185 --> 00:03:08,185
类变量可以从类内部访问。

57
00:03:08,188 --> 00:03:11,188
如果想从类之外访问该变量，必须设计一个特定的getter，

58
00:03:11,191 --> 00:03:15,191
这里是这个getter的例子。

59
00:03:15,195 --> 00:03:18,195
注意我们定义它的方式是不同的。

60
00:03:18,198 --> 00:03:21,198
定义self.bank_name。你们可能需要一点时间才能适应这种定义方式，

61
00:03:21,201 --> 00:03:24,201
这样之所以行得通，是因为一旦我们开始声明类，

62
00:03:24,204 --> 00:03:28,204
在这个声明里，

63
00:03:28,208 --> 00:03:32,208
self的值就是被创建的新类。

64
00:03:32,212 --> 00:03:35,212
所以，如果我们说def self.某个方法名称，其实我们要说的是：

65
00:03:35,215 --> 00:03:38,215
我们是在类本身上定义方法，

66
00:03:38,218 --> 00:03:41,218
而不是在类实例上定义。

67
00:03:41,221 --> 00:03:45,221
对吗？我们来返回银行名称。注意，

68
00:03:45,225 --> 00:03:48,225
我们不是为银行名称这个类变量提供setter，

69
00:03:48,228 --> 00:03:54,228
所以你不能设置它。如果要换一种方式说self.bank_name，

70
00:03:54,234 --> 00:03:58,234
那我们可以用：类名称.银行名称。为什么呢？

71
00:03:58,238 --> 00:04:01,238
因为在类定义中，

72
00:04:01,241 --> 00:04:04,241
self的值就是你正在创建的新类。

73
00:04:04,244 --> 00:04:07,244
类定义就讲到这。我马上要对Ruby解释器进行狂轰滥炸，

74
00:04:07,247 --> 00:04:10,247
那样我们可以对这些例子进行实战演练，

75
00:04:10,250 --> 00:04:14,250
但在此之前，

76
00:04:14,254 --> 00:04:17,254
先考考你们的记忆力。记住，我说过，记住，

77
00:04:17,257 --> 00:04:22,257
一切都是对象，一切都是方法调用，a. b...

78
00:04:22,262 --> 00:04:29,262
好了。哪一个是访问银行帐户实例余额的正确方法？

79
00:04:29,269 --> 00:04:34,269
先来第一轮快速投票。

80
00:04:34,274 --> 00:04:39,274
第一轮快速投票。你们确实很快，确实很快。

81
00:04:39,279 --> 00:04:44,279
一片海蓝色。现在我们讨论一下答案。

82
00:04:44,284 --> 00:04:47,284
A为什么错？有没有观众来回答？

83
00:04:47,287 --> 00:04:54,287
A有什么明显错误？有一种可能，

84
00:04:54,294 --> 00:04:58,294
你不能直接访问@balance，对，但第一个选项还有一个更浅显的错误。

85
00:04:58,298 --> 00:05:00,298
先生？

86
00:05:00,000 --> 00:05:04,300
没有叫做@balance的方法。没有叫做@balance的方法。

87
00:05:04,304 --> 00:05:08,304
A.b永远是指在对象A上调用方法b。

88
00:05:08,308 --> 00:05:10,308
方法名称绝不会以@符号开头，只有实例变量名称才会以@符号开头。

89
00:05:10,310 --> 00:05:14,310
所以一目了然，答案A不行。

90
00:05:14,314 --> 00:05:18,314
它在语法上也不合法。B和C是一样的，

91
00:05:18,318 --> 00:05:21,318
只是其中一个省略了对balance的方法调用的可选括号。

92
00:05:21,321 --> 00:05:25,321
就是这样了，现在回到讨论。

93
00:05:25,325 --> 00:05:30,325
现在我要将一些代码拷到Ruby解释器中。

94
00:05:30,330 --> 00:05:37,330
我还自己创建了三个帐户来玩玩。

95
00:05:37,337 --> 00:05:40,337
我的帐户有1000美元，Dave的是5000美元，

96
00:05:40,340 --> 00:05:44,340
比尔盖茨的比我们俩都多得多。

97
00:05:44,344 --> 00:05:52,344
一会再回来讲这个。现在你们已经了解了实例变量。

98
00:05:52,352 --> 00:05:55,352
你们知道了（如何）对实例变量定义显式的getters和setters。

99
00:05:55,355 --> 00:05:59,355
而另一方面，

100
00:05:59,359 --> 00:06:02,359
我们定义的getters和setters都很微不足道，

101
00:06:02,362 --> 00:06:05,362
要是...一旦你们看见这样的内容，

102
00:06:05,365 --> 00:06:08,365
你们已经看到过这种方法，而且知道接下来会发生什么，

103
00:06:08,368 --> 00:06:12,368
这说明这种语言没有在为你提供支持。

104
00:06:12,372 --> 00:06:16,372
有没有更简洁的办法？

105
00:06:16,376 --> 00:06:18,376
如果这些访问器(getters)和setters真那么普遍，难道不应该有一种更简洁的支持办法吗？

106
00:06:18,378 --> 00:06:23,378
的确有。

107
00:06:23,383 --> 00:06:29,383
我再做一次。老办法。新办法。

108
00:06:29,389 --> 00:06:35,389
我让代码消失了。这个神奇的attr_accessor是什么？

109
00:06:35,395 --> 00:06:40,395
它不是语言的一部分，只是普通的方法调用，

110
00:06:40,400 --> 00:06:42,400
一会我们要讲到元程序设计，

111
00:06:42,402 --> 00:06:45,402
也就是在运行期间定义、写和运行新代码的代码。

112
00:06:45,405 --> 00:06:49,405
在介绍Ruby时我说过，

113
00:06:49,409 --> 00:06:52,409
我只讲这些高大上的语言特征，

114
00:06:52,412 --> 00:06:55,412
因为我相信它们能帮助你们

115
00:06:55,415 --> 00:06:58,415
写出更简洁、更易读、更易懂的代码。

116
00:06:58,418 --> 00:07:02,418
这里有个例子。在下次家庭作业中，

117
00:07:02,422 --> 00:07:03,422
你们要完成的任务之一就是

118
00:07:03,423 --> 00:07:08,423
自己创建更复杂的attr_accessor。

119
00:07:08,428 --> 00:07:11,428
但你说attr_accessor : balance时，

120
00:07:11,431 --> 00:07:15,431
你说的其实是：请为我创建这两种方法，

121
00:07:15,435 --> 00:07:18,435
一个默认getter和一个默认setter，太明显了，直接做吧。

122
00:07:18,438 --> 00:07:21,438
你会琢磨出怎么弄的。如果你需要根据attr_accessor打印出那两个方法的文本，

123
00:07:21,441 --> 00:07:25,441
也可以。

124
00:07:25,445 --> 00:07:27,445
区别在于，在Ruby里，如果你能在运行时输出，

125
00:07:27,447 --> 00:07:30,447
那你肯定也能在运行时执行，

126
00:07:30,450 --> 00:07:34,450
这是很酷的。现在快速复习一下讲过的Ruby突出特征。

127
00:07:34,454 --> 00:07:37,454
首先，它极度的面向对象。

128
00:07:37,457 --> 00:07:41,457
即使最低级的整数型也是对象。

129
00:07:41,461 --> 00:07:44,461
它没有属性这一说法。有实例变量，

130
00:07:44,464 --> 00:07:47,464
但你得定义显式的getter和setter，

131
00:07:47,467 --> 00:07:52,467
因为你得通过方法来使用它们。一切都是方法调用。

132
00:07:52,472 --> 00:07:54,472
一般情况下，对于方法调用，你只需要关心一件事，

133
00:07:54,474 --> 00:07:56,474
接收者是否对你调用的方法有反应，

134
00:07:56,476 --> 00:07:59,476
一会我们讲鸭子类型时还要详细讲这个。

135
00:07:59,479 --> 00:08:02,479
我们讲过，

136
00:08:02,482 --> 00:08:05,482
对象可以有不同类型，

137
00:08:05,485 --> 00:08:09,485
但指向对象的变量却没有，

138
00:08:09,489 --> 00:08:12,489
我们见过的大多数表达式都是非破坏性的，

139
00:08:12,492 --> 00:08:14,492
所以我们举的例子有连接字符串、

140
00:08:14,494 --> 00:08:18,494
连接数组。现在我们看一些函数，

141
00:08:18,498 --> 00:08:22,498
它们让你选择、移动元素并重新排列数组。大多数情况下，

142
00:08:22,502 --> 00:08:24,502
当然我们也会举出一些例外情况，

143
00:08:24,504 --> 00:08:28,504
那些函数不会修改接收者。它们会返回新的对象拷贝。

144
00:08:28,508 --> 00:08:32,508
由于Ruby带有函数程序设计的色彩，

145
00:08:32,512 --> 00:08:34,512
因此它具有这一特征。

