1
00:00:00,000 --> 00:00:06,000
软件即服务的一个相关概念就是，它是一种面向服务的架构。

2
00:00:06,006 --> 00:00:10,006
所以说，有时在计算机科学领域，

3
00:00:10,010 --> 00:00:15,010
人们会造一些特别难懂的术语。或者也可以说，

4
00:00:15,015 --> 00:00:18,015
这句话对于一切都是适用，所以人们因而不用这些术语。

5
00:00:18,018 --> 00:00:22,018
那么，面向服务的架构，算是非常普遍了，所以差不多已经死了，

6
00:00:22,022 --> 00:00:26,022
它其实不过是含义比较好，并不能说明一切，

7
00:00:26,026 --> 00:00:29,026
并不是面向服务的架构

8
00:00:29,029 --> 00:00:33,029
所以这里的问题就是，设计软件有一种方式，

9
00:00:33,033 --> 00:00:36,033
让所有独立模块都可以重组，从中创造出新的应用，

10
00:00:36,036 --> 00:00:38,036
而不必再做很多的编程，这就是问题，

11
00:00:38,038 --> 00:00:43,038
而在面向服务的架构，在这种理念里，

12
00:00:43,043 --> 00:00:47,043
所有的部分都被设计为独立的服务，

13
00:00:47,047 --> 00:00:50,047
你们登上互联网，就可以使用它们了，这就是面向服务的架构的理念。

14
00:00:50,050 --> 00:00:54,050
所以，这就意味着，所有人都可以享受服务，

15
00:00:54,054 --> 00:00:57,054
如果你可以上网，就可以轻松获取，

16
00:00:57,057 --> 00:01:01,057
还能替换掉某一个，对，它们都是可以轻松替换的

17
00:01:01,061 --> 00:01:04,061
不会降低服务。而且还能恢复设计中的错误，

18
00:01:04,064 --> 00:01:07,064
把东西抛开，再重组在一起，这样灵活得多了。

19
00:01:07,067 --> 00:01:10,067
所以我和Armando必须得给这东西想一个名字，

20
00:01:10,070 --> 00:01:13,070
这不是面向服务的架构，我们认为这是一个软件silo。

21
00:01:13,073 --> 00:01:17,073
它是单片式的，打破了传统做法，

22
00:01:17,077 --> 00:01:21,077
没有应用程序界面，能看到所有东西的内部，

23
00:01:21,081 --> 00:01:24,081
这算是正常的做法，我们会把这个，你们知道，grain silo当作arc使用。

24
00:01:24,084 --> 00:01:29,084
所以说，我们有一个时期，一直在很不容易地向人们解释这个，

25
00:01:29,089 --> 00:01:32,089
然后在写这本书的时候，发生了这件事，

26
00:01:32,092 --> 00:01:36,092
纯属偶然，所以，如果你们在公司工作的话，

27
00:01:36,096 --> 00:01:40,096
通常在公司里，都会有一些出名的人，

28
00:01:40,100 --> 00:01:44,100
他们会写很多邮件，猛批公司有多糟糕，

29
00:01:44,104 --> 00:01:49,104
而我们必须这么做，因为你们知道，我们是傀儡，是啊，好吧，

30
00:01:49,109 --> 00:01:52,109
在谷歌曾经有个人，他原先是亚马逊的优秀员工，

31
00:01:52,112 --> 00:01:56,112
后来他到了谷歌，成功了一段时间，我们有博客，

32
00:01:56,116 --> 00:02:00,116
他有谷歌内部的博客，他会对谷歌里一切糟糕的事情开骂，

33
00:02:00,000 --> 00:02:04,120
而后来，他在他的公开博客上说，

34
00:02:04,124 --> 00:02:08,124
谷歌永远都是对了，真是太棒了，

35
00:02:08,128 --> 00:02:11,128
有可能是因为他在进行多任务处理，很有可能，你知道，一边玩着手机，

36
00:02:11,131 --> 00:02:16,131
在骂谷歌的时候，他本该在谷歌内部博客，结果发到了公共博客上，

37
00:02:16,136 --> 00:02:19,136
而那天可能在公开的博客上说了什么夸谷歌的话。

38
00:02:19,139 --> 00:02:23,139
那Armando看到了，

39
00:02:23,143 --> 00:02:26,143
他觉得这将存在很久，他抓住了，然后说，

40
00:02:26,146 --> 00:02:29,146
下一张幻灯就是它了，结果成了最好的一张。

41
00:02:29,149 --> 00:02:34,149
这是我们见过的，对主权服务器最好的描述，

42
00:02:34,154 --> 00:02:37,154
而那个人原本打算只在谷歌内部说的话，

43
00:02:37,157 --> 00:02:41,157
是关于杰夫•贝索斯的，

44
00:02:41,161 --> 00:02:47,161
即亚马逊的创始人兼CEO，

45
00:02:47,167 --> 00:02:50,167
而他在那里的时候，公司大概有七年历史了，而他们用的是

46
00:02:50,170 --> 00:02:53,170
一种单片软件。所以当你礼拜一早上来上班时，就会收到贝索斯的邮件，

47
00:02:53,173 --> 00:02:58,173
里面写了七点内容，而其中六点说的其实是一个意思，

48
00:02:58,178 --> 00:03:02,178
那个人是这么补充的，所以我会告诉你们是哪些内容的，

49
00:03:02,182 --> 00:03:06,182
邮件里说，所有团队都必须通过服务界面，

50
00:03:06,186 --> 00:03:11,186
公布他们的功能性数据，

51
00:03:11,191 --> 00:03:13,191
团队之间必须通过这些界面互相沟通，

52
00:03:13,193 --> 00:03:17,193
没有其他形式的媒介了，所以他不希望在这上面留有任何漏洞。

53
00:03:17,197 --> 00:03:20,197
你们必须要做到，团队的数据储存里没有直接的链接目录，

54
00:03:20,200 --> 00:03:23,200
没有共享模型，没有后门，唯一的通信交流，

55
00:03:23,203 --> 00:03:27,203
就是通过服务器界面登录。

56
00:03:27,207 --> 00:03:29,207
顺便提一下，贝索斯在普林斯顿拿到计算机科学学位，

57
00:03:29,209 --> 00:03:32,209
他是本科学位，所以他了解一些技术上的事，你们知道，

58
00:03:32,212 --> 00:03:36,212
所以这些人是最先开始使用的，他不怎么在乎应用程序界面，

59
00:03:36,216 --> 00:03:41,216
只要你，朋友，你们知道，你要选择你自己的方式来进行socket RPC，

60
00:03:41,221 --> 00:03:45,221
非常想做，但是它只能是

61
00:03:45,225 --> 00:03:48,225
像网络一样的界面，服务界面，无一例外，

62
00:03:48,228 --> 00:03:52,228
必须从下往上向外地设计，这就是说，

63
00:03:52,232 --> 00:03:56,232
团队必须得对设计进行计划，使界面开发者能够展现到外部世界。

64
00:03:56,236 --> 00:04:01,236
无一例外，好的，好吧，

65
00:04:01,241 --> 00:04:05,241
他是公司CEO，而你是软件工程师，得到了世界上最棒的工作，

66
00:04:05,245 --> 00:04:10,245
我为啥必须得做贝索斯叫我做的事呢，是啊，好，

67
00:04:10,250 --> 00:04:14,250
下一句话就进行说明了，有谁不做这些事的话，就会被炒鱿鱼

68
00:04:14,254 --> 00:04:19,254
所以这也比较清楚，而邮件的第七点内容则是：谢谢，祝你今天愉快！

69
00:04:19,259 --> 00:04:23,259
贝索斯是不会说最后这些话的，

70
00:04:23,263 --> 00:04:26,263
在邮件的末尾说，如果你不做这些就会被炒，

71
00:04:26,266 --> 00:04:29,266
好了，那这就是我们让软件工程认真注意的方式。

72
00:04:29,269 --> 00:04:33,269
而亚马逊，他们的确把把一个，你们知道，

73
00:04:33,273 --> 00:04:36,273
使用单片软件的非常成功的公司，

74
00:04:36,276 --> 00:04:40,276
转变为使用面向服务的架构。

75
00:04:40,280 --> 00:04:44,280
有趣的是，同样的事情也发生在Facebook，这次故事并没有很戏剧性，

76
00:04:44,284 --> 00:04:49,284
但是花了三年，他们花费了三年的代价，来完成这个。

77
00:04:49,289 --> 00:04:52,289
他们决定向前迈进，

78
00:04:52,292 --> 00:04:55,292
选用面向服务的架构，而如果当时你在用Facebook的话，

79
00:04:55,295 --> 00:04:59,295
正在电脑上看着纽约时报，

80
00:04:59,299 --> 00:05:02,299
突然，冒出了一些通知，告诉你，你的其他朋友在正在看同一篇文章，

81
00:05:02,302 --> 00:05:04,302
就是你看的这一篇，而他们的这个功能，

82
00:05:04,304 --> 00:05:08,304
是通过那个叫做Facebook平台实现的。所以为了说得再清楚一些，

83
00:05:08,308 --> 00:05:11,308
我们来举个例子把，假设我们做书店，我们会展出

84
00:05:11,311 --> 00:05:16,311
Silo和面向服务架构的版本，所以在这个特定的例子里，对，是成立的。

85
00:05:16,316 --> 00:05:23,316
然后我们分别有三位浏览数据库的用户，

86
00:05:23,323 --> 00:05:28,323
那么我们有不同的服务浏览子系统，

87
00:05:28,328 --> 00:05:34,328
必须与用户进行沟通，用户资料，

88
00:05:34,334 --> 00:05:37,334
用户购买系统，就是指令和用户。

89
00:05:37,337 --> 00:05:41,337
所以你们开发了这个，单片界面内部投票，大概这样的东西，

90
00:05:41,341 --> 00:05:44,341
你们给单界面提供了外部，书店服务，

91
00:05:44,344 --> 00:05:49,344
人们使用它，那么这就是一种单片方式，

92
00:05:49,349 --> 00:05:52,349
而面向服务方式有很多相同部分，

93
00:05:52,352 --> 00:05:57,352
但现在这些都是服务了，所以用户浏览服务，有编辑器，

94
00:05:57,357 --> 00:06:01,357
而用户浏览用户资料都是购买服务，

95
00:06:01,361 --> 00:06:04,361
而你们可以把这些组合起来，来得到书或者服务，就像我们之前做的那样，

96
00:06:04,364 --> 00:06:07,364
所以这更像开销支付网络，

97
00:06:07,367 --> 00:06:10,367
提供服务有开销，但是奏效。好的，这样的好处就是，

98
00:06:10,370 --> 00:06:13,370
我们能够轻松地添加信用卡操作，

99
00:06:13,373 --> 00:06:16,373
而在你们让服务器类似自我实现任何交易之前，可能没有这样的功能，

100
00:06:16,376 --> 00:06:20,376
一本全新的服务器收藏的书，

101
00:06:20,380 --> 00:06:23,380
你只需要用这两部分来创建，并绑定社交网络，

102
00:06:23,383 --> 00:06:26,383
然后你就可以发给你的朋友，或图书经销商。

103
00:06:26,386 --> 00:06:28,386
那么，这就是面向服务的架构的概念了。

