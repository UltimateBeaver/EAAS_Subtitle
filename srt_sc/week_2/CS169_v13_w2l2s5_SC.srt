1
00:00:00,000 --> 00:00:03,000
为什么我们说所有编程都是元编程？

2
00:00:03,003 --> 00:00:06,003
什么是元编程和反射？这两个词可是一字千金。

3
00:00:06,006 --> 00:00:09,006
用了它们，你会觉得自己更聪明。

4
00:00:09,009 --> 00:00:12,009
反射的意思是，我们可以在运行时间问对象关于它自己的问题，

5
00:00:12,012 --> 00:00:16,012
可以让它在运行时间进行自我修改。

6
00:00:16,016 --> 00:00:20,016
元编程的意思是：我们写的代码又可以写新代码，

7
00:00:20,020 --> 00:00:23,020
而新代码在运行时可以引起有趣的事情发生。问题是，

8
00:00:23,023 --> 00:00:26,023
这些一字千金的词只是让你觉得更聪明呢，

9
00:00:26,026 --> 00:00:29,026
还是能帮助你把代码写得更简洁、紧凑、易读？

10
00:00:29,029 --> 00:00:33,029
当然，要是这问题的答案不是肯定的，

11
00:00:33,033 --> 00:00:36,033
我也不会解释了。

12
00:00:36,036 --> 00:00:38,036
现在详解一下。为了有点国际范，

13
00:00:38,038 --> 00:00:41,038
我们来修改一个银行帐户，想往里面存外汇。

14
00:00:41,041 --> 00:00:44,041
我们比如已经存了100美元。

15
00:00:44,044 --> 00:00:48,044
如果能存欧元当然好，那么我们就能把欧元存成美元（20），

16
00:00:48,048 --> 00:00:51,048
但这不好看。这看着像是程序员才会写的东西。

17
00:00:51,051 --> 00:00:55,051
按今天的或者别的什么汇率，20欧元就跟1美元一样。

18
00:00:55,055 --> 00:00:58,055
好了， 这太难看。还能做什么？

19
00:00:58,058 --> 00:01:01,058
如果我们用的是传统的语言，

20
00:01:01,061 --> 00:01:06,061
我们就不得不写成这样，

21
00:01:06,066 --> 00:01:09,066
写一个货币转换器... 就是啊，对吧？请和我一起哀叹吧。

22
00:01:09,069 --> 00:01:13,069
太难看了，没有美感。

23
00:01:13,073 --> 00:01:17,073
我们都想写出有美感的代码。那我们想说什么？

24
00:01:17,077 --> 00:01:19,077
更易读的版本应该是什么样？

25
00:01:19,079 --> 00:01:24,079
这是美元，这个作为欧元怎么样？

26
00:01:24,084 --> 00:01:28,084
你想做什么一目了然。这在Ruby里不是问题，

27
00:01:28,088 --> 00:01:31,088
因为动态语言的好处之一就是有开放的类。

28
00:01:31,091 --> 00:01:34,091
也就是说我们既可以创建

29
00:01:34,094 --> 00:01:37,094
又可以修改、扩展Ruby自带的类。

30
00:01:37,097 --> 00:01:42,097
这里怎么做？

31
00:01:42,102 --> 00:01:44,102
我们已经知道一切都是方法调用，对吧？

32
00:01:44,104 --> 00:01:48,104
如果我们这么写，这就是说欧元是调用在接收者20上的一个方法。

33
00:01:48,108 --> 00:01:51,108
那它就是数值类的实例方法。

34
00:01:51,111 --> 00:01:55,111
没问题。我们可以打开类。

35
00:01:55,115 --> 00:01:57,115
我们根据以往的汇率来定义欧元，那是美国的“美好旧时光”，

36
00:01:57,117 --> 00:02:01,117
好了。这真能行吗？

37
00:02:01,121 --> 00:02:11,121
试试。重新打开类，添加方法。

38
00:02:11,131 --> 00:02:16,131
不赖嘛。先别急着吃惊，

39
00:02:16,136 --> 00:02:25,136
再往前走一步。这是什么？这是什么？

40
00:02:25,145 --> 00:02:30,145
这就有问题了，因为我们的函数是Euros（欧元复数）而不是Euro（欧元单数）。

41
00:02:30,150 --> 00:02:32,150
是有现成的解决办法，但为了让大家发挥下想像力，

42
00:02:32,152 --> 00:02:36,152
我们做些更大胆一点的事。

43
00:02:36,156 --> 00:02:40,156
先抛开那个不谈，比如说我还想支持其他货币，

44
00:02:40,160 --> 00:02:43,160
但如果我处理的只是一个货币名称清单和换算系数，

45
00:02:43,163 --> 00:02:46,163
似乎有点浪费。

46
00:02:46,166 --> 00:02:49,166
我不想写一堆方法，看起来都像我的三行方法一样，

47
00:02:49,169 --> 00:02:54,169
所以一定有更简洁的办法。

48
00:02:54,174 --> 00:02:57,174
的确有，这里就是一个可能的解决方案。

49
00:02:57,177 --> 00:03:00,177
和刚才一样，我重新打开数值类，

50
00:03:00,000 --> 00:03:03,180
但现在的更具一般性...这是散列，

51
00:03:03,183 --> 00:03:06,183
它将货币名称与换算系数映射起来，一点都不吃惊。

52
00:03:06,186 --> 00:03:10,186
酷的部分要到了。Ruby的功能之一叫做method_missing，

53
00:03:10,190 --> 00:03:15,190
如果你向接收者调用方法，而接收者不知道有那个名称的方法，

54
00:03:15,195 --> 00:03:17,195
那就调用method_missing，

55
00:03:17,197 --> 00:03:21,197
但如果你已在类里定义了叫做“method_missing”的方法，

56
00:03:21,201 --> 00:03:25,201
接收者就可以接收调用。

57
00:03:25,205 --> 00:03:28,205
method_missing被传递给三个参数。第一个是你尝试调用的方法的实际名称，

58
00:03:28,208 --> 00:03:30,208
但它好像不存在，

59
00:03:30,210 --> 00:03:34,210
如果这个方法存在，那就有一份该方法应该接收到的参数列表，

60
00:03:34,214 --> 00:03:37,214
也可以是一个代码块。

61
00:03:37,217 --> 00:03:41,217
一会要详细讲到代码块。由于大多数Ruby方法

62
00:03:41,221 --> 00:03:43,221
都可以采用代码块作为参数，

63
00:03:43,223 --> 00:03:46,223
可能我们的方法也可以。

64
00:03:46,226 --> 00:03:50,226
在这里，method_missing的作用是将方法ID转换成字符串，

65
00:03:50,230 --> 00:03:55,230
去掉后面的所有s...

66
00:03:55,235 --> 00:03:58,235
记住，我们遇到过想用1调用的问题。

67
00:03:58,238 --> 00:04:01,238
Euro和1.Euros...

68
00:04:01,241 --> 00:04:05,241
基本上我们要将货币名称标准化为单数形式，

69
00:04:05,245 --> 00:04:08,245
然后看我们有没有对应那个货币的键，

70
00:04:08,248 --> 00:04:13,248
再进行转换。是不是大开眼界？我能感觉到。

71
00:04:13,253 --> 00:04:15,253
隔着这个屏幕我也能感觉到你们的震惊。

72
00:04:15,255 --> 00:04:18,255
现在看看，如果这样做会发生什么。

73
00:04:18,258 --> 00:04:27,258
我现在回到解释器。

74
00:04:27,267 --> 00:04:31,267
如果我这样...会怎么样？不起作用，对吧？

75
00:04:31,271 --> 00:04:35,271
出什么问题了？调用了method_missing，对吧？

76
00:04:35,275 --> 00:04:38,275
事实上，调试器告诉我们出问题的就是method_missing。

77
00:04:38,278 --> 00:04:42,278
这是我定义的method_missing。

78
00:04:42,282 --> 00:04:45,282
问题在这儿，对吧？

79
00:04:45,285 --> 00:04:49,285
在我们的货币数组中没有英镑的键，所以失败了，

80
00:04:49,289 --> 00:04:53,289
那会怎么样呢？我来调用，我基本上使用父类。

81
00:04:53,293 --> 00:04:57,293
在所有语言中都有这样一种说法：

82
00:04:57,297 --> 00:05:00,297
如果你没有一个函数，而你的父类或一个祖先类有，

83
00:05:00,000 --> 00:05:03,300
那它就能得到处理。

84
00:05:03,303 --> 00:05:06,303
Ruby也是这样，但区别在于

85
00:05:06,306 --> 00:05:09,306
先调用method_missing，所以在祖先类有机会处理之前，

86
00:05:09,309 --> 00:05:12,309
我先有机会用method_missing来处理。

87
00:05:12,312 --> 00:05:15,312
这是一种可扩展的办法，

88
00:05:15,315 --> 00:05:26,315
可以用它来完成我们之前完成的任务。懂了吗？很简洁。这是什么意思？

89
00:05:26,326 --> 00:05:30,326
反射和元编程不仅仅是一些高大上的概念。

90
00:05:30,330 --> 00:05:33,330
你可以在运行时问Ruby对象关于它们自己的问题。

91
00:05:33,333 --> 00:05:37,333
比如说，method_missing可以看到

92
00:05:37,337 --> 00:05:39,337
本应调用的方法名称，

93
00:05:39,339 --> 00:05:41,339
以及该方法本应接收的参数。

94
00:05:41,341 --> 00:05:45,341
我们可以利用这些信息在运行时间生成新代码。

95
00:05:45,345 --> 00:05:49,345
这就是attr_accessor做的事，对吧？

96
00:05:49,349 --> 00:05:52,349
它马不停蹄地为实例变量创建getters和setters，

97
00:05:52,352 --> 00:05:56,352
这就是说你的代码还可以写代码。如你们刚才所见，你可以随时重新打开任意类，

98
00:05:56,356 --> 00:05:58,356
不管是你自己的还是Ruby内置的，

99
00:05:58,358 --> 00:06:01,358
你可以添加内容，

100
00:06:01,361 --> 00:06:05,361
也可以修改它的作用。

101
00:06:05,365 --> 00:06:08,365
当我向学习其他语言的人第一次解释Ruby时，

102
00:06:08,368 --> 00:06:11,368
他们有一个普遍的反应：“天啊，

103
00:06:11,371 --> 00:06:14,371
这太混乱了。你的意思是，你可以重新打开任意类，

104
00:06:14,374 --> 00:06:16,374
如果我在操作别人的代码，我不知道字符串到底是不是字符串，

105
00:06:16,376 --> 00:06:19,376
也不知道它是不是特殊字符串。

106
00:06:19,379 --> 00:06:21,379
如果我想调用方法，它们有各种各样的method_missing，

107
00:06:21,381 --> 00:06:23,381
所以我调用的方法并不是我以为我调用的方法。

108
00:06:23,383 --> 00:06:28,383
这太混乱了。”我想说的是，你们都是成年人，

109
00:06:28,388 --> 00:06:31,388
至少我猜你们大多数是成年人。

110
00:06:31,391 --> 00:06:34,391
权力越大，责任越大，对吧？ 

111
00:06:34,394 --> 00:06:37,394
如果一种语言给你的绳子足以让你上吊， 

112
00:06:37,397 --> 00:06:40,397
那你起码应该知道什么时候才能使用这根绳子。

113
00:06:40,400 --> 00:06:42,400
如果有疑问，可以问经验更丰富的人。

114
00:06:42,402 --> 00:06:46,402
你可以看别人的代码，确实有人滥用这些特征，

115
00:06:46,406 --> 00:06:48,406
就像所有优秀的特征都会被滥用一样。

116
00:06:48,408 --> 00:06:51,408
任何好技术都可以用来行善也可以用来行恶。

117
00:06:51,411 --> 00:06:54,411
我们会尝试列举行善的例子，带来更美的代码，

118
00:06:54,414 --> 00:06:57,414
而代码评审、结对编程这样的工作

119
00:06:57,417 --> 00:07:00,417
可以帮助我们避免一些最糟糕的过度操作，

120
00:07:00,000 --> 00:07:04,420
从而避免使用不当和/或特征滥用。

