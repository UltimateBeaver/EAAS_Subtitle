1
00:00:00,000 --> 00:00:05,000
这有个例子，你们试试。运行这段代码，

2
00:00:05,005 --> 00:00:08,005
这里哪个字符串不会出现？当然代码会完全运行。

3
00:00:08,008 --> 00:00:11,008
也许代码有语法错误，根本不运行。

4
00:00:11,011 --> 00:00:21,011
先看看这段代码，想一想。

5
00:00:21,021 --> 00:00:23,021
对了，匹配是一个正则表达式。

6
00:00:23,023 --> 00:00:29,023
我忘了，得先来第一轮投票。我觉得是橙色这个，对吗？

7
00:00:29,029 --> 00:00:37,029
基于明亮的程度，是橙色吗？你们这么快，

8
00:00:37,037 --> 00:00:40,037
那我们直接来讲答案吧。这个表达式是怎么回事？

9
00:00:40,040 --> 00:00:43,040
这个数组包含三样东西，

10
00:00:43,043 --> 00:00:45,043
我们调用map时，map会做什么？

11
00:00:45,045 --> 00:00:48,045
它会返回一个新集合，对吧？它会用这个匿名函数，

12
00:00:48,048 --> 00:00:51,048
运用到每一个元素上，

13
00:00:51,051 --> 00:00:54,051
然后返回被那些应用生效的新集合。

14
00:00:54,054 --> 00:00:57,054
函数主体里面有什么？取一个元素然后对它调用reverse，

15
00:00:57,057 --> 00:01:00,057
我们已经见过那个字符串了。reverse方法会颠倒一个字符串，

16
00:01:00,000 --> 00:01:05,060
那我们得到的就是ananab, anana，

17
00:01:05,065 --> 00:01:09,065
我得到的是回文和naan，后面的也是个回文，是不是很酷？

18
00:01:09,069 --> 00:01:11,069
对了，三种都是很不错的水果。中间这个是西班牙文的菠萝。

19
00:01:11,071 --> 00:01:17,071
这里，end后面，我们在这里。

20
00:01:17,077 --> 00:01:19,077
我们得到了一个有三个字符串的新集合，

21
00:01:19,079 --> 00:01:22,079
但每个字符串都被反转了。在这个集合里，

22
00:01:22,082 --> 00:01:26,082
我们要挑选出，或者说过滤出

23
00:01:26,086 --> 00:01:31,086
所有和要求以A开头的正则表达式匹配的字符串。

24
00:01:31,091 --> 00:01:34,091
Ananab 和anana 都符合这个标准，但naan不符合，

25
00:01:34,094 --> 00:01:37,094
所以它不会出现，那么橙色的是正确答案。

26
00:01:37,097 --> 00:01:37,097
好样的。

