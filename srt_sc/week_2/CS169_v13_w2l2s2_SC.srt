1
00:00:00,000 --> 00:00:06,000
准备好标号卡。现在开始，

2
00:00:06,006 --> 00:00:10,006
我定义了一个有三个参数的函数，

3
00:00:10,010 --> 00:00:15,010
我的想法是函数首先采用一个标量参数，

4
00:00:15,015 --> 00:00:19,015
然后是散列的参数。之前向你们暗示的问题是，

5
00:00:19,019 --> 00:00:23,019
哪一个不是函数的合法调用？

6
00:00:23,023 --> 00:00:27,023
提示一下：要使调用不合法，

7
00:00:27,027 --> 00:00:30,027
参数列表的分析方法要存在二义性。

8
00:00:30,030 --> 00:00:35,030
想一想。我们先来第一轮投票。

9
00:00:35,035 --> 00:00:42,035
准备好了吗？第一轮。哇塞，你们学得很快啊。

10
00:00:42,042 --> 00:00:47,042
现在来讨论一下。投票选的是绿色，我很高兴，

11
00:00:47,047 --> 00:00:53,047
看来说你们聪明真没错。现在来说说为什么。

12
00:00:53,053 --> 00:00:57,053
在所有三个例子中，最顶上这个大家看得出这有个参数。

13
00:00:57,057 --> 00:00:59,057
这是个参数，有大括号，

14
00:00:59,059 --> 00:01:02,059
这是第三个参数，

15
00:01:02,062 --> 00:01:06,062
它有一个单一键值对。这都没问题。同样地，这里，

16
00:01:06,066 --> 00:01:09,066
第三个选择，基本一致，

17
00:01:09,069 --> 00:01:15,069
但这里我包括了arg列表的可选括号。在最后一个例子中，

18
00:01:15,075 --> 00:01:18,075
我省略了括号，但在两个散列上都用了大括号。

19
00:01:18,078 --> 00:01:22,078
在这三个合法分列中，很容易看出

20
00:01:22,082 --> 00:01:26,082
一个散列在哪儿结束，另一个在哪开始。

21
00:01:26,086 --> 00:01:29,086
绿色的例子中有三个键值对，

22
00:01:29,089 --> 00:01:32,089
但函数需要两个散列。

23
00:01:32,092 --> 00:01:37,092
没有一个明确的办法找出第一个散列在哪结束、第二个在哪开始。

24
00:01:37,097 --> 00:01:41,097
你们怎么知道特定的函数调用呢？

25
00:01:41,101 --> 00:01:44,101
如果我不告诉你们foo的定义，

26
00:01:44,104 --> 00:01:47,104
你们不一定知道绿色的不合法，对吧？

27
00:01:47,107 --> 00:01:51,107
如果将foo定义为两个参数的函数，其中第二个参数是一个散列，

28
00:01:51,111 --> 00:01:54,111
那这个调用就完全合法。有时候，

29
00:01:54,114 --> 00:01:57,114
你们得理解或看看函数说明，

30
00:01:57,117 --> 00:01:59,117
才能理解调用为什么不合法，

31
00:01:59,119 --> 00:02:00,119
以及在诗歌模式里如何避免不合法调用。

