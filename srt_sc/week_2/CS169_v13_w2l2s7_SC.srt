1
00:00:00,000 --> 00:00:03,000
发言者1：我们的下一个话题

2
00:00:03,003 --> 00:00:06,003
是Ruby的众多强大之处之一，

3
00:00:06,006 --> 00:00:09,006
也是新接触这一语言的人会比较头疼的一点，

4
00:00:09,009 --> 00:00:12,009
因为和大多数人都在使用的现代语言相比，

5
00:00:12,012 --> 00:00:15,012
Ruby的一些特征要罕见得多。

6
00:00:15,015 --> 00:00:20,015
{这些特征当然不会出现在JAVA中，在Python里出现了一些，但也不象Ruby中用的那么多}。

7
00:00:20,020 --> 00:00:23,020
我们来讨论一下块、迭代器，还有其他一些函数术语。

8
00:00:23,023 --> 00:00:27,023
函数式编程，

9
00:00:27,027 --> 00:00:31,027
如果你有机会上一门这里已经不教的课程的话，

10
00:00:31,031 --> 00:00:33,031
这门课叫计算机程序结构与解释。

11
00:00:33,033 --> 00:00:37,033
这门课以前在一门叫Scheme的语言里会教，

12
00:00:37,037 --> 00:00:41,037
那门课介绍的内容之一是一个很深邃的概念，

13
00:00:41,041 --> 00:00:44,041
函数式编程，这个概念在语言领域里已经很长时间了。

14
00:00:44,044 --> 00:00:46,044
包括我在内的一些人都认为

15
00:00:46,046 --> 00:00:49,046
这个概念没有得到足够的宣传和推广。

16
00:00:49,049 --> 00:00:52,049
接下来的几分钟我们来讨论函数式编程技术

17
00:00:52,052 --> 00:00:55,052
如何帮助我们重新思考一些基本编程概念。

18
00:00:55,055 --> 00:00:59,055
以迭代为例，我们经常做，所以觉得理所当然。

19
00:00:59,059 --> 00:01:02,059
在循环、遍历数据结构中都用到。

20
00:01:02,062 --> 00:01:06,062
更重要的是，为什么要重新思考？

21
00:01:06,066 --> 00:01:09,066
这些都是基本的编程架构，为什么还要

22
00:01:09,069 --> 00:01:12,069
重新思考我们常用的处理方法？先来看一些例子。

23
00:01:12,072 --> 00:01:16,072
和以往一样，你们会习惯我举例，

24
00:01:16,076 --> 00:01:19,076
随着你们越来越多地使用这种语言， 

25
00:01:19,079 --> 00:01:23,079
你们很快就会发现例子的价值所在。

26
00:01:23,083 --> 00:01:26,083
这儿是三样东西的集合：apple（苹果）、banana（香蕉）和cherry（樱桃）。

27
00:01:26,086 --> 00:01:29,086
这是一个由三个字符串组成的数组，

28
00:01:29,089 --> 00:01:33,089
每个字符串都可以打印。看着像是循环。

29
00:01:33,093 --> 00:01:36,093
如果你经常使用JAVA这样的命令式语言，

30
00:01:36,096 --> 00:01:38,096
你会说，“懂了。就像是为数组元素写循环语句。”

31
00:01:38,098 --> 00:01:42,098
其实不是。你使用它本身的优势，是each方法。

32
00:01:42,102 --> 00:01:45,102
这里有一个集合，用每一个元素进行操作。

33
00:01:45,105 --> 00:01:49,105
再举几个例子进一步解释一下。

34
00:01:49,109 --> 00:01:53,109
你也可以这样，但这只是这种的糖衣语法。

35
00:01:53,113 --> 00:01:57,113
这到底是什么？

36
00:01:57,117 --> 00:02:00,117
这个是要干嘛？我们知道这是方法调用，

37
00:02:00,000 --> 00:02:03,120
是对整数型的方法，是有一个参数的方法调用。

38
00:02:03,123 --> 00:02:07,123
后面可以跟块，块就是lambda表达式，

39
00:02:07,127 --> 00:02:10,127
是一个没有名称的过程。

40
00:02:10,130 --> 00:02:13,130
在这个例子里，它是一个参数num的过程。它的作用就是

41
00:02:13,133 --> 00:02:16,133
打印出那个num。这就是它的作用，是一个过程。

42
00:02:16,136 --> 00:02:20,136
这是个函数调用。现在我要生成一个数值列表，

43
00:02:20,140 --> 00:02:23,140
为每一个数值调用一个函数，

44
00:02:23,143 --> 00:02:27,143
将数值作为参数传递。

45
00:02:27,147 --> 00:02:31,147
Ruby提供了另一种捷径。rah, rah, rah. 

46
00:02:31,151 --> 00:02:35,151
这里我用大括号代替do和and，

47
00:02:35,155 --> 00:02:42,155
这个不常用，但有时也会见到。不要太糊涂了。

48
00:02:42,162 --> 00:02:46,162
好了，不好意思。如果见到“替换大括号”

49
00:02:46,166 --> 00:02:52,166
而不是“用大括号代替do-and”，不要觉得困惑。

50
00:02:52,172 --> 00:02:56,172
这些例子又是在干嘛？

51
00:02:56,176 --> 00:02:58,176
前面有堂课我简单讲过这个，这些例子有一个共同点，

52
00:02:58,178 --> 00:03:01,178
即我们让对象管理自己的遍历。

53
00:03:01,181 --> 00:03:05,181
在这个例子里，我们有一系列对象，

54
00:03:05,185 --> 00:03:08,185
整数型1到10，于是我们说，

55
00:03:08,188 --> 00:03:12,188
自行遍历且遍历在此过程中返回的每一个元素，

56
00:03:12,192 --> 00:03:14,192
我将提供你们调用的函数，由该元素作为参数，

57
00:03:14,194 --> 00:03:17,194
匿名函数，匿名lambda表达式。

58
00:03:17,197 --> 00:03:19,197
如果你在对话中频繁使用这个词，

59
00:03:19,199 --> 00:03:22,199
你的朋友可能会觉得你真的很喜欢匿名，

60
00:03:22,202 --> 00:03:27,202
然后他们也就再不会约你去参加聚会了。

61
00:03:27,207 --> 00:03:31,207
不管怎样，这是一个range遍历。那这些数组呢？

62
00:03:31,211 --> 00:03:34,211
我们可以用一个数组，对其中的每个元素进行操作，

63
00:03:34,214 --> 00:03:36,214
我再给你们一个函数， 

64
00:03:36,216 --> 00:03:39,216
你们将其调用在每一个数组元素上。

65
00:03:39,219 --> 00:03:41,219
他们之间的有趣之处在于作为一个程序员，

66
00:03:41,221 --> 00:03:45,221
你完全不知道里面使用的是什么机制， 

67
00:03:45,225 --> 00:03:48,225
可以抓取每一个元素，并把它提供给你。

68
00:03:48,228 --> 00:03:52,228
你将这个负责交给了目标。散列也可以这样。

69
00:03:52,232 --> 00:03:55,232
散列是有键和值的，记得吧？

70
00:03:55,235 --> 00:03:57,235
事实上有几个不同的架构适用于遍历这些键值对。

71
00:03:57,237 --> 00:04:01,237
对于每个键，你可以说把那个键给我，做点什么，

72
00:04:01,241 --> 00:04:05,241
也可以对每个键值对这样，

73
00:04:05,245 --> 00:04:07,245
因为匿名函数既可以有多个参数，

74
00:04:07,247 --> 00:04:14,247
也可以有0个。回到我之前的简单例子。

75
00:04:14,254 --> 00:04:18,254
10. times，这其实是这一条的简化版，

76
00:04:18,258 --> 00:04:21,258
只不过它是参数0的迭代，

77
00:04:21,261 --> 00:04:24,261
它不需要参数，因为如果我们说10 times，

78
00:04:24,264 --> 00:04:27,264
你大概并不在乎指标的值。

79
00:04:27,267 --> 00:04:29,267
如果你在乎的话，你就会采用前面几种办法。

80
00:04:29,269 --> 00:04:35,269
很多Ruby程序员将这样做的结果

81
00:04:35,275 --> 00:04:38,275
称为表达定位。你不会想：

82
00:04:38,278 --> 00:04:41,278
“我要对这个集合进行操作。”

83
00:04:41,281 --> 00:04:44,281
你想的是：“集合，我要找你要点东西，

84
00:04:44,284 --> 00:04:47,284
还要对你的元素进行操作。”

85
00:04:47,287 --> 00:04:50,287
比如说，我有一个集合x，

86
00:04:50,290 --> 00:04:54,290
它是字符串数组，我说“自行整理，”

87
00:04:54,294 --> 00:04:56,294
“自取唯一元素。”这就是“do”,

88
00:04:56,296 --> 00:05:00,296
它返回复本。这里X并没有修改，

89
00:05:00,000 --> 00:05:04,300
在准备这些例子时没有破坏过x。

90
00:05:04,304 --> 00:05:08,304
我得到一个新副本，就是x，但没有了复制的元素，

91
00:05:08,308 --> 00:05:13,308
现在我要反转，得到香蕉、樱桃、苹果。

92
00:05:13,313 --> 00:05:15,313
有些版本是危险的。记得，

93
00:05:15,315 --> 00:05:18,315
我说过，如果有时候你看到一个函数名称以!(感叹号)结尾，

94
00:05:18,318 --> 00:05:21,318
这说明这个函数是危险的，或者有副作用，

95
00:05:21,321 --> 00:05:25,321
所以要小心使用。在反转时，

96
00:05:25,325 --> 00:05:29,325
有变量以!结尾，修改了接收器。X reverse!

97
00:05:29,329 --> 00:05:34,329
或x反转其实是指x将被修改。

98
00:05:34,334 --> 00:05:40,334
还有一个map(映射)。如果你使用Python或Scheme这样的语言，

99
00:05:40,340 --> 00:05:44,340
映射就是...对于数组中每个元素来说，

100
00:05:44,344 --> 00:05:48,344
我要对每个元素进行操作，结果是返回新内容，

101
00:05:48,348 --> 00:05:51,348
而结果是...之前，在遍历元素时，

102
00:05:51,351 --> 00:05:54,351
我们的意思是“这是函数调用，它将对每个元素进行操作。”

103
00:05:54,354 --> 00:05:57,354
映射要更进一步，它说...

104
00:05:57,357 --> 00:06:00,357
事实上，整体映射的结果是一个新的集合，

105
00:06:00,000 --> 00:06:08,360
在这个集合里，每个元素都是调用匿名lambda的结果。

106
00:06:08,368 --> 00:06:12,368
在这个例子里，我采用了最初的水果集合，

107
00:06:12,372 --> 00:06:15,372
对其中的每个元素，我都要调用反转，

108
00:06:15,375 --> 00:06:17,375
于是字符串反转，产生新的字符串复本，

109
00:06:17,377 --> 00:06:22,377
元素反转了。中间这一步的结果

110
00:06:22,382 --> 00:06:25,382
是一个每个单词都被反转的数组。

111
00:06:25,385 --> 00:06:28,385
顺便说一句，既然整体映射的结果

112
00:06:28,388 --> 00:06:31,388
本身是一个新集合，我可以调用sort。

113
00:06:31,391 --> 00:06:36,391
在Ruby里，你会看到A. B. C. D，你创建一个待办事件列表，

114
00:06:36,396 --> 00:06:39,396
这就像UNIX管道，

115
00:06:39,399 --> 00:06:43,399
但任何对象都返回某个对象的复本并且是有值的，

116
00:06:43,403 --> 00:06:46,403
它是一个表达式，

117
00:06:46,406 --> 00:06:49,406
而你可以在那个表达式上进行更多操作。

118
00:06:49,409 --> 00:06:51,409
这种思考方式来源于函数式编程。

119
00:06:51,411 --> 00:06:55,411
我们要举几个例子，说明这种方式非常非常有用。

120
00:06:55,415 --> 00:06:58,415
这是另外一个集合，“将你集合中的每一个元素都给我，

121
00:06:58,418 --> 00:07:02,418
我要采集这个函数返回true值的所有元素。”

122
00:07:02,422 --> 00:07:06,422
你可以测试，

123
00:07:06,426 --> 00:07:09,426
到底字符串包不包含字符？

124
00:07:09,429 --> 00:07:12,429
你可以测试数组是否包含字符。

125
00:07:12,432 --> 00:07:14,432
一会我们会讲到，为什么“include（包含）”好像在哪都能用，

126
00:07:14,434 --> 00:07:17,434
用于各种不同的类。我可以问，

127
00:07:17,437 --> 00:07:21,437
“是不是有元素满足某个特定条件？”

128
00:07:21,441 --> 00:07:25,441
有一个现实生活中的例子。我建议你们课下去找找，

129
00:07:25,445 --> 00:07:27,445
因为我不想占用这个在线课程的时间。

130
00:07:27,447 --> 00:07:33,447
先给你们预览一下，

131
00:07:33,453 --> 00:07:36,453
给你们看一下代码，现在不详细讲。

132
00:07:36,456 --> 00:07:38,456
住在旧金山湾区的人都有路路通卡，

133
00:07:38,458 --> 00:07:41,458
那是公交卡，你可以上网查余额等。

134
00:07:41,461 --> 00:07:43,461
我想写一个脚本，

135
00:07:43,463 --> 00:07:48,463
它可以让我上一个URL查询余额，

136
00:07:48,468 --> 00:07:52,468
而不用登录官方网站，那网站我不喜欢。

137
00:07:52,472 --> 00:07:54,472
我用了一个叫Mechanize 的库，

138
00:07:54,474 --> 00:07:58,474
可以在远程Web服务器上写脚本。我创建了

139
00:07:58,478 --> 00:08:03,478
新的mechanized对象，我在路路通网址的URL上写上我的用户名

140
00:08:03,483 --> 00:08:06,483
和密码。请注意每行后面的点。

141
00:08:06,486 --> 00:08:10,486
这是一行。记住，我说过 A. B. C.

142
00:08:10,490 --> 00:08:13,490
我将调用一系列不同的方式来构建这个表达式。

143
00:08:13,493 --> 00:08:17,493
我现在提交一个表单，这样做的结果是

144
00:08:17,497 --> 00:08:20,497
不管网站返回的是什么，我都要找含有 H ref的链接，

145
00:08:20,500 --> 00:08:23,500
点击该链接，解析产生的网页，

146
00:08:23,503 --> 00:08:26,503
寻找这些HTML 元素。来到表格第一行，

147
00:08:26,506 --> 00:08:29,506
第二列，第三列，

148
00:08:29,509 --> 00:08:32,509
寻找与“美元符号后接小数”相匹配的内容，

149
00:08:32,512 --> 00:08:36,512
然后返回HTML。孩子们，这是一个语句。

150
00:08:36,516 --> 00:08:39,516
我没说它有美感，我没这个意思，别误会。

151
00:08:39,519 --> 00:08:41,519
我需要的是又快又能解决问题的办法。

152
00:08:41,521 --> 00:08:45,521
我现在想的是：我居然能这么紧凑地写出这个东西来。

