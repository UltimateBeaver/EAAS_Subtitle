1
00:00:00,000 --> 00:00:02,000
今天我们马上开始讲Ruby，

2
00:00:02,002 --> 00:00:06,002
它是一种现代的面向对象的语言。你们多数学过JAVA，

3
00:00:06,006 --> 00:00:09,006
从JAVA世界来的人，

4
00:00:09,009 --> 00:00:11,009
在做面向对象编程时要吸收很多新概念。

5
00:00:11,011 --> 00:00:13,011
要学习对象，学习对象的属性，

6
00:00:13,013 --> 00:00:16,013
要讨论属性的getter和setter。

7
00:00:16,016 --> 00:00:19,016
要讨论对象支持的方法。

8
00:00:19,019 --> 00:00:23,019
如果你们做过C++，你就知道操作符重载。

9
00:00:23,023 --> 00:00:25,023
有接口，让你能在类里面添加行为。

10
00:00:25,025 --> 00:00:29,025
JAVA也有整数型这样的原始类型。

11
00:00:29,029 --> 00:00:32,029
必须调用box和unbox才能对其进行操作。

12
00:00:32,032 --> 00:00:35,032
你可能会问，

13
00:00:35,035 --> 00:00:38,035
在JAVA或C++语言中使用这些不同的机制时， 

14
00:00:38,038 --> 00:00:41,038
有没有一组比较小的机制组

15
00:00:41,041 --> 00:00:44,041
来支持你要做的这些事。

16
00:00:44,044 --> 00:00:47,044
Ruby极大地简化了这种情况的处理，

17
00:00:47,047 --> 00:00:50,047
将所有东西都看作对象。

18
00:00:50,050 --> 00:00:53,050
要完成一项操作，只能对对象调用方法。这到底是什么意思？

19
00:00:53,053 --> 00:00:57,053
首先，即使是整数型也是对象。

20
00:00:57,057 --> 00:01:00,057
就是说你可以对整数型调用方法。

21
00:01:00,000 --> 00:01:05,060
比如整数调用days方法，three days ago方法，

22
00:01:05,065 --> 00:01:08,065
它会告诉你从三天前开始过了多少秒。在原生的Ruby中，

23
00:01:08,068 --> 00:01:10,068
这行不通，但在Rails中行得通。我一会再讲为什么会这样。

24
00:01:10,070 --> 00:01:14,070
为了让你们有个概念，我也可以说"50.method"。

25
00:01:14,074 --> 00:01:17,074
我问整数50，“你对什么方法有反应？

26
00:01:17,077 --> 00:01:21,077
你会做什么？”在Ruby中，

27
00:01:21,081 --> 00:01:25,081
我可以明确说反应，可以直接问对象，

28
00:01:25,085 --> 00:01:28,085
“你对什么方法有反应？”，

29
00:01:28,088 --> 00:01:32,088
只要调用这个内置的respond to方法。想看我画画如何？

30
00:01:32,092 --> 00:01:36,092
还行吧？事实上，

31
00:01:36,096 --> 00:01:38,096
这些都可以理解成单个架构外面包裹的语法糖，

32
00:01:38,098 --> 00:01:41,098
这架构就是发送（send）方法。这是这门语言的基础。

33
00:01:41,101 --> 00:01:44,101
它说：“用下面的方法调用，发送到对象。

34
00:01:44,104 --> 00:01:48,104
这样我们就将对象称为接收对象。

35
00:01:48,108 --> 00:01:50,108
Ruby只关心你发送信息的对象

36
00:01:50,110 --> 00:01:54,110
是否知道如何对信息做出反应。

37
00:01:54,114 --> 00:01:58,114
举个例子，如果我说1+2，事实上，

38
00:01:58,118 --> 00:02:02,118
我是向接收对象发送对象1，信息+，

39
00:02:02,122 --> 00:02:04,122
以及另一个参数2。

40
00:02:04,124 --> 00:02:08,124
这就是语言层面上的解释。

41
00:02:08,128 --> 00:02:11,128
{事实上这就是另外一种方法，调用参数1，

42
00:02:11,131 --> 00:02:14,131
将其加到接收对象上。}同样地，

43
00:02:14,134 --> 00:02:17,134
如果我用方括号对一个数组解引用，

44
00:02:17,137 --> 00:02:22,137
我是在将方括号解引用方法发送给目标数组，

45
00:02:22,142 --> 00:02:24,142
也在传送另一个参数--我想要得到的下标。

46
00:02:24,144 --> 00:02:27,144
也可以举其他例子。

47
00:02:27,147 --> 00:02:30,147
当进行数组赋值时，“这里在干嘛？”不管你相不相信，

48
00:02:30,150 --> 00:02:34,150
这是一种方法调用。有种方法调用，

49
00:02:34,154 --> 00:02:37,154
意思是赋值至数组，这次我们需要两个参数：

50
00:02:37,157 --> 00:02:40,157
分配哪个下标，以及那里的新值是什么？

51
00:02:40,160 --> 00:02:42,160
{重点是，

52
00:02:42,162 --> 00:02:46,162
可以为数组找到方法，叫做"[]="。}

53
00:02:46,166 --> 00:02:50,166
<<<<<<< HEAD
你说数组下标3的位置等于foo，这只是简写，
=======
当你调用数组"[3] = foo"，这只是简写，
>>>>>>> bdb3fe105a95a489e5a2a44db34ac1cd9ba8f00b

54
00:02:50,170 --> 00:02:53,170
是调用含有那两个参数的"[]="方法的糖衣语法。

55
00:02:53,173 --> 00:02:56,173
这已经大大简化了。 

56
00:02:56,176 --> 00:02:58,176
可能还需要时间习惯，

57
00:02:58,178 --> 00:03:01,178
但请再耐心一点听我多举几个例子。

58
00:03:01,181 --> 00:03:05,181
如果我做比较，我在做什么？

59
00:03:05,185 --> 00:03:09,185
我在向目标发送信息"=="，

60
00:03:09,189 --> 00:03:12,189
还有一个参数——要比较的对象。

61
00:03:12,192 --> 00:03:16,192
我调用正常的函数功能，事实上是在发送给self，即隐式接收对象。

62
00:03:16,196 --> 00:03:19,196
对了，如果在这个小点“.”前面什么也没有，

63
00:03:19,199 --> 00:03:21,199
那就是说self的值是什么这里就是什么。

64
00:03:21,201 --> 00:03:24,201
我们讲到面向对象时会详细讲述这一点。

65
00:03:24,204 --> 00:03:28,204
我们向self发送方法名称 - my func，

66
00:03:28,208 --> 00:03:32,208
和方法对应的一个参数。

67
00:03:32,212 --> 00:03:36,212
我们希望self有一个叫做my func的实例方法，

68
00:03:36,216 --> 00:03:41,216
而my func准备好接受参数。情况就是这样。

69
00:03:41,221 --> 00:03:44,221
记住，你们这样做，可以不那么头疼。

70
00:03:44,224 --> 00:03:48,224
如果看到.b，意思是在对象a上调用了方法b。

71
00:03:48,228 --> 00:03:51,228
这是什么意思？

72
00:03:51,231 --> 00:03:55,231
这并不是说b是a的实例变量，

73
00:03:55,235 --> 00:03:58,235
也不是说a是某种数据结构而b是该结构中的一个字段，

74
00:03:58,238 --> 00:04:01,238
不是这个意思，对吧？

75
00:04:01,241 --> 00:04:04,241
记住这一点，你可以更好地分析Ruby表达式，

76
00:04:04,244 --> 00:04:06,244
在你们习惯这种语言之前它们看起来有点让人犯晕。

77
00:04:06,246 --> 00:04:09,246
但一旦你们习惯了，就很自然了。

78
00:04:09,249 --> 00:04:13,249
记住这个区别，牢记这一条简单的规则，

79
00:04:13,253 --> 00:04:17,253
你们可以少些头疼，少些困惑。

80
00:04:17,257 --> 00:04:20,257
你说每个操作都是一次方法调用，再深入一点。

81
00:04:20,260 --> 00:04:25,260
这是什么意思？这里是+的三种用法。

82
00:04:25,265 --> 00:04:28,265
Ruby是一种现代的高度面向对象的语言，

83
00:04:28,268 --> 00:04:31,268
不了解它的人看到这三行会说，

84
00:04:31,271 --> 00:04:34,271
“如果这些都是合法调用，那Ruby应该是有

85
00:04:34,274 --> 00:04:37,274
很复杂的类型推理和类型转换，

86
00:04:37,277 --> 00:04:41,277
+才知道根据它两个参数的类型要进行什么操作。”

87
00:04:41,281 --> 00:04:43,281
你们已经知道，一切都是对象，

88
00:04:43,283 --> 00:04:46,283
+只是一个方法，

89
00:04:46,286 --> 00:04:49,286
你们应该很清楚这是三种不同的方法。

90
00:04:49,289 --> 00:04:52,289
这三种+的用法是三种不同方法。

91
00:04:52,292 --> 00:04:56,292
一种是数字类定义的+，

92
00:04:56,296 --> 00:04:59,296
一种是数组类定义的+，

93
00:04:59,299 --> 00:05:02,299
还有一种是字符串类定义的+。Ruby怎么知道该用哪个？

94
00:05:02,302 --> 00:05:05,302
用第三个举例。

95
00:05:05,305 --> 00:05:09,305
y = "hello" + "world"，+的接收对象是哪个？

96
00:05:09,309 --> 00:05:13,309
是第一个参数hello，这是一个字符串。

97
00:05:13,313 --> 00:05:15,313
{字符串类取决于+方法。}

98
00:05:15,315 --> 00:05:18,315
+方法会遇到第二个参数，即这里的“world”，

99
00:05:18,318 --> 00:05:21,318
它最好知道如何正确处理那个参数。

100
00:05:21,321 --> 00:05:24,321
问题的答案：

101
00:05:24,324 --> 00:05:27,324
“如果我说foo + bar，

102
00:05:27,327 --> 00:05:30,327
和foo + bar是不同的类或不同的类型，

103
00:05:30,330 --> 00:05:34,330
这时会发生什么情况？”在foo + bar中，foo是接收对象，+是发送给它的，

104
00:05:34,334 --> 00:05:37,334
<<<<<<< HEAD
它会收到bar作为参数，
=======
它会传递参数bar，
>>>>>>> bdb3fe105a95a489e5a2a44db34ac1cd9ba8f00b

105
00:05:37,337 --> 00:05:39,337
而且要决定它能否根据bar的性质或属性做出合理处理。

106
00:05:39,339 --> 00:05:43,339
结束介绍之前再说最后一点。

107
00:05:43,343 --> 00:05:47,343
诗歌模式。我在之前的课程中提到过，

108
00:05:47,347 --> 00:05:51,347
我喜欢页面只有最少数量的符号，

109
00:05:51,351 --> 00:05:54,351
这样我写代码容易，

110
00:05:54,354 --> 00:05:57,354
别人读代码也容易。Ruby支持这种效果的

111
00:05:57,357 --> 00:06:00,357
方法之一就是诗歌模式。这里是一个合法的Ruby语句示例，

112
00:06:00,000 --> 00:06:02,360
它来自我一个使用诗歌模式的应用软件。

113
00:06:02,362 --> 00:06:06,362
你们几乎可以大声念出来并想明白代码的作用。

114
00:06:06,366 --> 00:06:10,366
Redirect to login page and return unless logged in（重回到登录页面，返回，除非已经登录）。

115
00:06:10,370 --> 00:06:13,370
很少有比这更直白的代码了。

116
00:06:13,373 --> 00:06:16,373
这是合法参数，因为当括号里的函数调用参数可选时，

117
00:06:16,376 --> 00:06:19,376
即就算省略也不会造成语法分析器混淆时，

118
00:06:19,379 --> 00:06:22,379
Ruby就让你省略掉它们，

119
00:06:22,382 --> 00:06:26,382
同时也因为散列的括号在背景清晰时经常可以省略。

120
00:06:26,386 --> 00:06:30,386
比如，如果我们用带括号的语法重写，

121
00:06:30,390 --> 00:06:34,390
我们会看到 - Redirect to login page（重回到登录页面）

122
00:06:34,394 --> 00:06:37,394
这个“Redirect to（重回到）”是一种方法，它期待一个参数 - 

123
00:06:37,397 --> 00:06:41,397
也是一个标准Boolean连接器，你们之前见过了 - 

124
00:06:41,401 --> 00:06:45,401
即Return（返回）。这里的Return并没有返回明确的值，

125
00:06:45,405 --> 00:06:49,405
所以它是个函数调用，但没有参数，

126
00:06:49,409 --> 00:06:51,409
Logged in（登录）是另一个函数，我没有加上空括号。

127
00:06:51,411 --> 00:06:55,411
一旦你们习惯了这种语言，

128
00:06:55,415 --> 00:06:57,415
它就变得自然了，你也就很清楚什么时候能省略一些东西。

129
00:06:57,417 --> 00:07:01,417
还有个例子。

130
00:07:01,421 --> 00:07:04,421
Dave在之前的课程中提到，可以写出这样的句子 - 

131
00:07:04,424 --> 00:07:06,424
“a should be greater than or equal to seven when you're expressing test cases” （在测试用例中，a 应该大于或等于7）。

132
00:07:06,426 --> 00:07:09,426
这怎么行得通呢？

133
00:07:09,429 --> 00:07:13,429
如果我们加上括号，这真的是一个只有一个参数的函数吗？

134
00:07:13,433 --> 00:07:16,433
这里的参数是

135
00:07:16,436 --> 00:07:19,436
“大于或等于7”。我知道b不是变量，

136
00:07:19,439 --> 00:07:22,439
而是另一个函数调用。

137
00:07:22,442 --> 00:07:27,442
是方法调用。在诗歌模式的例子中，

138
00:07:27,447 --> 00:07:31,447
我省略了b的空括号，

139
00:07:31,451 --> 00:07:34,451
它告诉我们这是一个没有参数的函数调用，

140
00:07:34,454 --> 00:07:39,454
而括号应该捕捉其参数。最后一个例子，

141
00:07:39,459 --> 00:07:42,459
这个例子是说当背景明显说明某项内容是散列时，

142
00:07:42,462 --> 00:07:46,462
大括号可以省略。这个调用在

143
00:07:46,466 --> 00:07:50,466
Rails应用中非常普遍，

144
00:07:50,470 --> 00:07:54,470
创建一个URL，链接到你程序中的某个特定流程，

145
00:07:54,474 --> 00:07:57,474
该程序处理用户或app的互动。

146
00:07:57,477 --> 00:08:01,477
我们这里事实上省略了两个东西。

147
00:08:01,481 --> 00:08:04,481
这是一个含有一个参数的函数，那个参数是个散列。

148
00:08:04,484 --> 00:08:07,484
分析时很清晰，所以我们

149
00:08:07,487 --> 00:08:10,487
不仅可以省略函数参数的括号，

150
00:08:10,490 --> 00:08:13,490
还可以省略通常在散列表字面量两边的大括号。

151
00:08:13,493 --> 00:08:16,493
你们第一次见这个的时候，是有点困惑，

152
00:08:16,496 --> 00:08:18,496
你们不一定总能知道什么时候这样做是可以接受的，什么时候不可以。

153
00:08:18,498 --> 00:08:22,498
如果有疑问，你们总可以加上括号。

154
00:08:22,502 --> 00:08:25,502
一般来说，你们很会就会习惯，什么时候可以这样做，

155
00:08:25,505 --> 00:08:27,505
你们会发现，这使你的代码更易读。

156
00:08:27,507 --> 00:08:28,507


