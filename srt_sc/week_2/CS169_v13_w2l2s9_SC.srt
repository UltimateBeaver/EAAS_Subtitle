1
00:00:00,000 --> 00:00:09,000
鸭子类型，这个很有意思。我一直在说，

2
00:00:09,009 --> 00:00:13,009
Ruby强调的是做什么、对什么方法有反应，

3
00:00:13,013 --> 00:00:17,013
而不是你属于什么类。那问题是，

4
00:00:17,017 --> 00:00:20,017
你为什么要关心这个？是吧？它能怎么刺激生产力？

5
00:00:20,020 --> 00:00:24,020
它能让你重复使用什么？

6
00:00:24,024 --> 00:00:26,024
有些人用了一个非正式的诙谐名称来指代Ruby的这种实现——鸭子类型。

7
00:00:26,026 --> 00:00:32,026
你可能听到过这样一种说法：

8
00:00:32,032 --> 00:00:35,032
如果看起来像鸭子，那它走起来也像鸭子，

9
00:00:35,035 --> 00:00:37,035
叫起来也像鸭子，你也可以像对待鸭子一样对待它。

10
00:00:37,037 --> 00:00:41,037
我的意思是，如果你的对象对某些方法做出反应，

11
00:00:41,041 --> 00:00:45,041
它看上去像什么，你就怎么对待它。

12
00:00:45,045 --> 00:00:49,045
如果它对“give me each of yourself（将你的每一个成分给我）”

13
00:00:49,049 --> 00:00:52,049
或“reverse yourself（自行反转）”做出反应，

14
00:00:52,052 --> 00:00:55,052
在什么东西上讨论这些运算才是有意义的呢？它应该是某种集合。

15
00:00:55,052 --> 00:00:58,055
在Ruby里，如果你说什么东西叫起来像个集合，

16
00:00:58,055 --> 00:01:01,058
那意思是“你可以认为这个东西能对，

17
00:01:01,058 --> 00:01:03,000
大多数相同的，一般的集合比如内置集合的数组可以响应的，

18
00:01:03,000 --> 00:01:06,064
面向集合的方法做出响应。”

19
00:01:06,067 --> 00:01:08,067
如果你在JAVA里用到接口，你就会发现和这个有点类似，

20
00:01:08,069 --> 00:01:15,069
但我觉得这个更容易。

21
00:01:15,076 --> 00:01:19,076
比如说，如果我在我的列表上调用sort，那是什么意思？

22
00:01:19,080 --> 00:01:21,080
假如我的列表就像这个整数型数组，

23
00:01:21,082 --> 00:01:25,082
你可以想像sort在上面运算是什么意思。

24
00:01:25,086 --> 00:01:27,086
如果是字符串列表呢？你可以想像，

25
00:01:27,088 --> 00:01:31,088
Sort在那上面操作、

26
00:01:31,092 --> 00:01:34,092
或是在一个符号(Symbol类)列表上、甚至是从 IO readlines得到的内容上运算，那是什么情形。

27
00:01:34,095 --> 00:01:37,095
从IO readlines得到的是文件中的所有行，一次一行，对吧？

28
00:01:37,098 --> 00:01:42,098
在IO readlines的情况下，我们的意思就是“Sort this file（整理本文件）”。

29
00:01:42,103 --> 00:01:45,103
为什么会起作用呢？为了找出这个答案，我们来介绍一种新的Ruby架构，

30
00:01:45,106 --> 00:01:47,106
它在其他语言中不会出现。

31
00:01:47,108 --> 00:01:52,108
而在它出现的那些语言中，module（模块）这个词

32
00:01:52,113 --> 00:01:55,113
表达的是不同的意思。在Ruby里，模块是指不属于类的方法的集合。

33
00:01:55,116 --> 00:01:58,100
模块不是一个类，你不能对它进行实例化。

34
00:01:58,119 --> 00:02:01,119
不存在模块的实例。

35
00:02:01,122 --> 00:02:04,200
它其实就是一组采集了相关行为并彼此配合的方法。

36
00:02:04,200 --> 00:02:07,174
在一些简单情况下，使用模块

37
00:02:07,203 --> 00:02:11,203
就是采集方法，比如与通用运算集相关的方法，

38
00:02:11,207 --> 00:02:15,207
像是数学运算或本身就是数学运算的常量。

39
00:02:15,207 --> 00:02:17,200
这都是很明显的。我们关注的是更有趣的应用。

40
00:02:17,200 --> 00:02:21,200
更有趣的应用是用模块将方法与类混合。

41
00:02:21,204 --> 00:02:25,204
这是什么意思？

42
00:02:25,208 --> 00:02:29,208
假设，在我声明A类时，

43
00:02:29,212 --> 00:02:32,212
我说“包含某个模块的名称”，这意思是

44
00:02:32,215 --> 00:02:36,215
当我试着对A的实例调用方法时，如果我调用A. Foo，

45
00:02:36,219 --> 00:02:41,219
首先它会搜索A类是否有这个方法，

46
00:02:41,224 --> 00:02:43,224
然后搜索类包括的模块中是否有这个方法，

47
00:02:43,226 --> 00:02:45,226
接下来它的操作我们都已经讲过了。

48
00:02:45,228 --> 00:02:48,228
它会调用method_missing，会指向祖先，

49
00:02:48,231 --> 00:02:50,231
但本质上模块让你有办法说出，

50
00:02:50,233 --> 00:02:53,233
“等等，在这个类里添加点东西，我还没整完呢。”

51
00:02:53,236 --> 00:02:57,236
你之所以想这么做，

52
00:02:57,060 --> 00:03:00,240
是因为相当可能，

53
00:03:00,243 --> 00:03:04,243
比起类和类型来，Ruby更关心响应。

54
00:03:04,247 --> 00:03:07,247
对模块、行为集合的定义方式

55
00:03:07,250 --> 00:03:10,250
是可以在很多不同的类上重复使用的。在学习的过程中，

56
00:03:10,253 --> 00:03:13,253
它会令你吃惊并进一步学习。以上一张幻灯片上的sort方法为例，

57
00:03:13,256 --> 00:03:15,256
你认为它是定义在数组上的，

58
00:03:15,258 --> 00:03:21,258
但事实上不是，

59
00:03:21,264 --> 00:03:23,264
它是定义在叫做Enumerable的模块上的。

60
00:03:23,266 --> 00:03:26,266
只要类知道如何枚举自己的元素，Enumerable模块就可以混合进这样的类。

61
00:03:26,269 --> 00:03:29,269
这个不太明显，所以我再重复一遍。

62
00:03:29,272 --> 00:03:33,272
我们看到了使用each的不同的例子。

63
00:03:33,276 --> 00:03:36,276
我一直在说，我们不是在强行从集合里取东西，

64
00:03:36,279 --> 00:03:38,279
我们在友好地跟集合说，

65
00:03:38,281 --> 00:03:41,281
“作为交换，请把你的每一个元素按顺序给我。

66
00:03:41,284 --> 00:03:43,284
我不管你是怎么得来的，我只想要每一个元素，

67
00:03:43,286 --> 00:03:47,286
那样我就可以对它进行操作了。”我们的意思是，

68
00:03:47,290 --> 00:03:50,290
“如果你能同意这么做，我知道

69
00:03:50,293 --> 00:03:53,293
如何免费执行一些操作。比如说，

70
00:03:53,296 --> 00:03:56,296
如果你能返回自己的每一个元素，我可以对你排序，前提是

71
00:03:56,299 --> 00:03:59,299
你的方法...你的集合里的东西可以被排序。

72
00:03:59,302 --> 00:04:02,302
我们一会再回来讲这个。

73
00:04:02,305 --> 00:04:05,300
你还能做什么？如果你能返回自己的每一个元素，

74
00:04:05,300 --> 00:04:08,309
我可以在某些条件下用Select、Collect 以及那些我们见过的方法

75
00:04:08,312 --> 00:04:11,312
来测试每一个元素。这是什么意思呢？

76
00:04:11,315 --> 00:04:14,315
举了实在点的例子，这意思就是混合(mix-in)就像个合同。

77
00:04:14,318 --> 00:04:18,318
我们以Enumerable模块为例，

78
00:04:18,322 --> 00:04:21,322
因为它在Ruby里用得很广泛，

79
00:04:21,325 --> 00:04:24,325
很常用。它假设，在你把模块混合进去的那个类里的目标对象

80
00:04:24,328 --> 00:04:28,328
知道如何对each做出响应，对吧？

81
00:04:28,328 --> 00:04:31,500
正如我所说，如果你定义一个新类，比如说一个二叉树数据结构，

82
00:04:31,500 --> 00:04:34,500
你把each定义为获取该数据结构里元素的办法，

83
00:04:34,503 --> 00:04:37,503
现在你就可以混合Enumerable模块，

84
00:04:37,506 --> 00:04:41,506
就可以免费得到这些方法。

85
00:04:41,510 --> 00:04:44,510
它为你定义像all、any、collect、find、include、map和partition这样的谓词，

86
00:04:44,513 --> 00:04:49,513
一大堆很干净利落的谓词，

87
00:04:49,518 --> 00:04:53,518
因为你同意提供each。这是一种超强大的行为。

88
00:04:53,518 --> 00:04:57,400
Enumerable也是sort在Ruby里被定义的地方，

89
00:04:57,400 --> 00:05:00,427
但sort还有其它要求，就是你的模型...

90
00:05:00,430 --> 00:05:04,400
对不起。sort还有其它要求，

91
00:05:04,400 --> 00:05:08,400
就是类...集合中的元素能对

92
00:05:08,400 --> 00:05:10,406
宇宙飞船操作符（<=>）做出反应。还记得宇宙飞船操作符吗？

93
00:05:10,408 --> 00:05:14,408
它把所有等号操作符合成一个。

94
00:05:14,412 --> 00:05:17,412
如果A比B小，那么A<=>B就是-1，

95
00:05:17,412 --> 00:05:20,415
如果B比A大，那么就是+1。如果A比B小，那就是-1，

96
00:05:20,418 --> 00:05:25,400
如果A比B大，那就是+1，如果A等于B，那就是0，对吧？

97
00:05:25,500 --> 00:05:28,522
可以想象，不管你想要什么类，

98
00:05:28,525 --> 00:05:32,525
你可以定义宇宙飞船操作符，可以定义让它

99
00:05:32,529 --> 00:05:35,529
按你喜欢的顺序对颜色排序。

100
00:05:35,532 --> 00:05:38,532
在Int和String这样的类中，

101
00:05:38,532 --> 00:05:42,535
显然宇宙飞船操作符已经以你期望的语义来定义了。这里的重点是，

102
00:05:42,535 --> 00:05:44,900
如果你有一个集合，这个集合对each作出反应，

103
00:05:45,000 --> 00:05:48,400
而集合中的元素对宇宙飞船操作符作出反应，

104
00:05:48,500 --> 00:05:50,956
那你什么也不用做，排序就能完成，

105
00:05:51,003 --> 00:05:55,003
对吧？排序是什么？

106
00:05:55,007 --> 00:05:58,007
就是进行成对比较，看两个中哪个更大，

107
00:05:58,010 --> 00:06:01,010
再以算法型将其重新排列。

108
00:06:01,013 --> 00:06:05,000
实际上，Ruby中还有一个附带的模块Comparable，

109
00:06:05,116 --> 00:06:07,116
如果你提供宇宙飞船操作符，

110
00:06:07,118 --> 00:06:11,118
需要一个参数，对吗？宇宙飞船操作符需要一个参数，

111
00:06:11,122 --> 00:06:13,122
因为它已经有一个接受者，

112
00:06:13,124 --> 00:06:15,124
和一个你正在与接受者相比较的东西。

113
00:06:15,126 --> 00:06:20,126
如果你提供宇宙飞船操作符，那么我就会提供一些别的东西和一些让你

114
00:06:20,131 --> 00:06:23,131
高兴的东西比如between方法，between告诉你根据排好的顺序，

115
00:06:23,134 --> 00:06:25,100
你是否有一个元素在某两个元素之间。

116
00:06:25,136 --> 00:06:28,100
这些都意味着什么呢？这意味着这些对象属于什么类几乎不重要，

117
00:06:28,100 --> 00:06:31,140
重要的是它们所响应的方法。

118
00:06:31,140 --> 00:06:35,100
让我们来看看一些例子。对一个文件排序，

119
00:06:35,100 --> 00:06:37,100
首先，我们打开这个文件。这是一个返回代表打开的文件的IO（输入输出）对象

120
00:06:37,100 --> 00:06:41,800
的方法。IO对象确实定义了each，

121
00:06:41,900 --> 00:06:45,900
它将each方法定义为，“我要按顺序返回这个文件的每一行。”

122
00:06:45,909 --> 00:06:49,909
对于读取一个文本文件来说，这是很合理的语义。

123
00:06:49,913 --> 00:06:53,913
这是什么意思？比如说，我能打开一个文件然后对它排序。

124
00:06:53,917 --> 00:06:57,917
就是这样。我不需要提供任何其他东西因为

125
00:06:57,921 --> 00:06:59,921
我正在调用sort的对象是一个集合，并且响应each。

126
00:06:59,923 --> 00:07:02,923
它知道如何给出（yield）它的每一个元素。在这个集合之中，

127
00:07:02,926 --> 00:07:07,926
它的每一个元素都是什么呢？是一个字符串，对吗？

128
00:07:07,931 --> 00:07:10,931
是文件中的一行。字符串知道如何比较它们自己，

129
00:07:10,934 --> 00:07:12,934
这是内置的字符串表现。不需要额外的工作，

130
00:07:12,936 --> 00:07:15,936
尽管类是各异的，我依旧可以重复使用各种特性。

131
00:07:15,939 --> 00:07:19,939
我也可以说文件的哪一行是以一个元音开始的，

132
00:07:19,943 --> 00:07:22,943
这是很简单的。我们已经知道如何

133
00:07:22,943 --> 00:07:26,000
Select来传递一个匿名的方法给一些东西，

134
00:07:26,000 --> 00:07:28,000
匿名函数。对于文件的每一行，我要选出

135
00:07:28,100 --> 00:07:30,500
那些正则表达式返回真值的。

136
00:07:30,500 --> 00:07:35,500
又一次，我们不需要任何额外的工作。我们可以构建自己的例子。

137
00:07:35,500 --> 00:07:42,500
但是在我们这样做之前，我们先问问怎样才能这样做呢？

