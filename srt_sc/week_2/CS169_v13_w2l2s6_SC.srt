1
00:00:00,000 --> 00:00:05,000
记住刚才那些。现在我们把例子扩展一下，

2
00:00:05,005 --> 00:00:09,005
比如说我们想这样。我们想以卢比或其它我们选择的货币来换5欧元，

3
00:00:09,009 --> 00:00:13,009
一般来说，

4
00:00:13,013 --> 00:00:16,013
如果我们要实现这一目的，应该怎么做？

5
00:00:16,016 --> 00:00:21,016
可能性之一是改变Numeric类之中的method_missing，

6
00:00:21,021 --> 00:00:24,021
可以察觉对“in”的调用，看看这些参数。

7
00:00:24,024 --> 00:00:28,024
这是方法之一。或者...

8
00:00:28,028 --> 00:00:30,028
这是Numeric.method_missing。这是类方法。

9
00:00:30,030 --> 00:00:33,030
或者我们可以改变实例方法，Numeric的method_missing来实现同样的目的。

10
00:00:33,033 --> 00:00:37,033
我们可以定义一种新方法，叫“in”，

11
00:00:37,037 --> 00:00:40,037
作为数值实例方法。顺便说一句，

12
00:00:40,040 --> 00:00:43,040
现在你们已经习惯了，Numeric.method_missing就意味着

13
00:00:43,043 --> 00:00:46,043
作为类方法的method_missing。Numeric#method_missing

14
00:00:46,046 --> 00:00:49,046
意味着这是实例方法。那是Ruby的符号，

15
00:00:49,049 --> 00:00:54,049
都是转换。或者我们可以定义类方法数值in。

16
00:00:54,054 --> 00:00:57,054
这里四个选项，哪一个是处理这种例子的最好办法？

17
00:00:57,057 --> 00:01:03,057
来投个票。投票。投票。

18
00:01:03,063 --> 00:01:08,063
我总算提了一个引起点争议的问题了。

19
00:01:08,068 --> 00:01:13,068
现在讨论一下。OK，再投一次票。

20
00:01:13,073 --> 00:01:20,073
准备好了吗？准备，投票。投票。

21
00:01:20,080 --> 00:01:24,080
OK，意见分歧很大啊。红色和蓝色支持比较多。

22
00:01:24,084 --> 00:01:28,084
我看每个选项都有不同程度的支持者啊。

23
00:01:28,088 --> 00:01:30,088
我们来看看。这个可以好好讨论一下。

24
00:01:30,090 --> 00:01:32,090
这个可以好好讨论一下。现在我们一个一个来讲这几个选项。

25
00:01:32,092 --> 00:01:37,092
首先，我们调用了5.Euros，

26
00:01:37,097 --> 00:01:40,097
Euros是什么方法？实例还是类？

27
00:01:40,100 --> 00:01:43,100
是实例方法，对吧？

28
00:01:43,103 --> 00:01:47,103
我们将其调用在Fixnum的一个实例上。记住我们是如何定义方法的。

29
00:01:47,107 --> 00:01:50,107
它将数值乘以某个数，

30
00:01:50,110 --> 00:01:54,110
那么我们从欧元方法中得到什么？也是Fixnum，对吧？

31
00:01:54,114 --> 00:01:58,114
如果我们想在结果上调用“in rupees”（以卢比），

32
00:01:58,118 --> 00:02:01,118
“in” 在某种程度上也是实例方法，

33
00:02:01,121 --> 00:02:05,121
对吧？这点我们是同意的。

34
00:02:05,125 --> 00:02:07,125
所以定义类方法的答案应该都搞错对象了。

35
00:02:07,127 --> 00:02:12,127
这不是类方法。

36
00:02:12,132 --> 00:02:16,132
这个呢？像之前一样修改method_missing。

37
00:02:16,136 --> 00:02:18,136
这也定义成实例方法，对吧？

38
00:02:18,138 --> 00:02:21,138
如果对象实例不能对某项内容作出反应，

39
00:02:21,141 --> 00:02:25,141
就调用这个。

40
00:02:25,145 --> 00:02:29,145
我们能不能增强method_missing来处理对“in”的调用？可以。

41
00:02:29,149 --> 00:02:33,149
这办法好吗？不一定，是吧？因为前一个例子中，

42
00:02:33,153 --> 00:02:36,153
关于货币处理的动机是

43
00:02:36,156 --> 00:02:39,156
它让我们用一种一般性办法来处理很多不同的方法调用，

44
00:02:39,159 --> 00:02:41,159
而那些调用的结果是一样的。它们只是将某个内容乘以一个数值而已。

45
00:02:41,161 --> 00:02:45,161
所以这样更紧凑。

46
00:02:45,165 --> 00:02:48,165
我们不用为20种不同的货币定义20种方法，

47
00:02:48,168 --> 00:02:51,168
而只需要用方法缺失来进行更简洁的处理。

48
00:02:51,171 --> 00:02:53,171
我们要做的要简单许多。

49
00:02:53,173 --> 00:02:58,173
我们要定义一个叫做" in" 的新方法，它被发送到定长整数，

50
00:02:58,178 --> 00:03:01,178
将引起多种形式的转换，而这些转换形式我们还没有确定。

51
00:03:01,181 --> 00:03:05,181
定义一个叫"in"的实例方法是解决这一问题的最简单办法。

52
00:03:05,185 --> 00:03:07,185
method_missing也可以达到这个效果，

53
00:03:07,187 --> 00:03:09,187
但那太大才小用了。

54
00:03:09,189 --> 00:03:11,189
解决这个问题不需要元编程。

55
00:03:11,191 --> 00:03:15,191
这只是传统的函数调用。

56
00:03:15,195 --> 00:03:18,195
在这里做这个练习，一部分原因

57
00:03:18,198 --> 00:03:21,198
是要再次让你们知道，有这些强大的机制可用，

58
00:03:21,201 --> 00:03:23,201
不代表你一定要用到它们。事实上，

59
00:03:23,203 --> 00:03:25,203
应该采用最简单的办法达到同样的效果。记住，

60
00:03:25,205 --> 00:03:29,205
那是极限编程的格言之一。在这个例子里，

61
00:03:29,209 --> 00:03:32,209
一个简单传统的实例方法就够用了。有没有问题？

62
00:03:32,212 --> 00:03:33,212
没有的话，我们继续往下讲。

