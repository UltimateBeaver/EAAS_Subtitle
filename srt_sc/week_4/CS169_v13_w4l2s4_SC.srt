1
00:00:00,000 --> 00:00:03,000
基于大家刚刚听到的内容，假定我们有一个名为幸运饼干的表格。

2
00:00:03,003 --> 00:00:09,003
它有一个列是幸运文本，

3
00:00:09,009 --> 00:00:13,009
如果幸运饼干继承自活动记录，

4
00:00:13,013 --> 00:00:16,013
那么这些中哪一种方法在向幸运文本添上“ on bed”时不会

5
00:00:16,016 --> 00:00:22,016
返回愚蠢的幸运签？

6
00:00:22,022 --> 00:00:27,022
用点时间把这些都看一遍。第一轮投票好吗？让我们来第一轮投票。

7
00:00:27,027 --> 00:00:35,027
第一轮投票结果？第一轮投票显示四个选项都有人选。

8
00:00:35,035 --> 00:00:38,035
这很好。我们是不是应该再来第二轮投票？让我们再投一次票，如何？

9
00:00:38,038 --> 00:00:43,038
第二轮投票怎么说？第二轮投票？第二轮投票大多数人都选择红色， 

10
00:00:43,043 --> 00:00:50,043
有些选黄色，有些绿色，还有些智能手机

11
00:00:50,050 --> 00:00:54,050
亮着不知道是什么的颜色。让我们讲一遍这儿的答案。

12
00:00:54,054 --> 00:00:58,054
我们看看这是怎么回事。哪个选项

13
00:00:58,058 --> 00:01:02,058
不会正常查找并在幸运文本属性结尾“在床上”，

14
00:01:02,062 --> 00:01:07,062
添上“ on bed”？让我们按这里的文本顺序来讲。

15
00:01:07,067 --> 00:01:11,067
这儿会发生什么呢？我们正要求引用实例变量，

16
00:01:11,071 --> 00:01:14,071
不过活动记录的要点在于

17
00:01:14,074 --> 00:01:16,074
你不在只讨论实例变量，你还在讨论

18
00:01:16,076 --> 00:01:17,076
具有数据库内有表示的属性。

19
00:01:17,077 --> 00:01:22,077
在此默认情况下，幸运文本属性会作为nil出现，

20
00:01:22,082 --> 00:01:25,082
这不是你所想的那个属性，

21
00:01:25,085 --> 00:01:30,085
因为活动记录操纵内部属性状态的方法不

22
00:01:30,090 --> 00:01:33,090
借助于设定简单的Ruby实例变量。

23
00:01:33,093 --> 00:01:35,093
这实际上有些复杂的逻辑，由此在

24
00:01:35,095 --> 00:01:37,095
数据库后保存这些内容时，正确事项的数值会

25
00:01:37,097 --> 00:01:41,097
显现。橙色选项不起作用，它不会完成你期待的

26
00:01:41,101 --> 00:01:45,101
任务。那绿色与红色选项如何呢？

27
00:01:45,105 --> 00:01:49,105
如果我们从绿色选项开始，要是我们说这些是

28
00:01:49,109 --> 00:01:52,109
幸运饼干的实例方法，这就没错，因为这表示

29
00:01:52,112 --> 00:01:54,112
在某项的实例方法范围内，self的值会是多少？

30
00:01:54,114 --> 00:01:58,114
这仅仅是对象接收到消息。self.幸运文本

31
00:01:58,118 --> 00:02:01,118
实际上就是本来的幸运文本。

32
00:02:01,121 --> 00:02:03,121
幸运文本是方法调用，大家要记住所有getter都是方法调用。

33
00:02:03,123 --> 00:02:06,123
我们得省略掉……我们省略了这里的括号。

34
00:02:06,126 --> 00:02:09,126
这是真的，有些人会说，“看看红色的示例， 

35
00:02:09,129 --> 00:02:13,129
幸运文本是方法调用

36
00:02:13,133 --> 00:02:15,133
而不是普通的局部变量，不是很明显呀。”

37
00:02:15,135 --> 00:02:18,135
确实如此，你可以把这看成是Ruby的缺点。

38
00:02:18,138 --> 00:02:21,138
在方法调用时，有些人老是设些空括号，不过

39
00:02:21,141 --> 00:02:24,141
Ruby工作方式是，如果幸运文本是一个变量且

40
00:02:24,144 --> 00:02:27,144
是范围内的局部变量，这就是可以使用的值。

41
00:02:27,147 --> 00:02:30,147
如果不存在这样的局部变量，它就检查是否有方法， 

42
00:02:30,150 --> 00:02:31,150
同时检查看你说作为方法调用是什么意思。

43
00:02:31,151 --> 00:02:34,151
这是在语言方面潜在的二义性。有些人

44
00:02:34,154 --> 00:02:39,154
总要在方法调用后设空括号，以此

45
00:02:39,159 --> 00:02:42,159
围绕它谨慎编写代码。另一方面，

46
00:02:42,162 --> 00:02:45,162
因为幸运文本切实……存在于现实生活中，它是模型的属性，

47
00:02:45,165 --> 00:02:48,165
因此认为你应该像对属性那样看待它，

48
00:02:48,168 --> 00:02:50,168
而属性在后面是没有括号的。这多少算是个人喜好问题，

49
00:02:50,170 --> 00:02:53,170
不过在语法上讲，绿色的选项2

50
00:02:53,173 --> 00:02:56,173
与红色的选项3其实完全相同。

51
00:02:56,176 --> 00:02:59,176
因为你没有……你有方法调用但没有明确的接收器时，

52
00:02:59,179 --> 00:03:01,179
隐式的接收器永远是自己。

53
00:03:01,181 --> 00:03:06,181
可以吗？有什么问题吗？讲话人2：二和三都起作用吗？

54
00:03:06,186 --> 00:03:09,186
S·杜邦：三什么？讲话人2：二和三都起作用吗？

55
00:03:09,189 --> 00:03:11,189
S·杜邦：二和三都起作用。一不会， 

56
00:03:11,191 --> 00:03:13,191
对此，第四个选项明显错误。

57
00:03:13,193 --> 00:03:14,193
所以答案是一号。

