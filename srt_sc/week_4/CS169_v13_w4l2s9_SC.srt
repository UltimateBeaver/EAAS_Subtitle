1
00:00:00,000 --> 00:00:03,000
继续我们的旅程，我们非常快速地介绍了一下

2
00:00:03,003 --> 00:00:06,003
各类模型。接下来我们要快速介绍一下

3
00:00:06,006 --> 00:00:09,006
MVC模式的另外两个要素，控制器和视图。

4
00:00:09,009 --> 00:00:11,009
我们来回到‘cookbook approach’（烹饪方法）。我们已经知道

5
00:00:11,011 --> 00:00:13,011
如何新建模型，或者更改已有模型的属性

6
00:00:13,013 --> 00:00:16,013
现在我们想添加一个新动作，能够对模型实施的新动作。

7
00:00:16,016 --> 00:00:20,016
要添加新动作，想想

8
00:00:20,020 --> 00:00:21,020
模型-视图-控制器系统中都需要什么？为了让控制器完成自己的工作

9
00:00:21,021 --> 00:00:25,021
你需要从一个URI获得

10
00:00:25,025 --> 00:00:28,025
在控制器中实际处理的方法

11
00:00:28,028 --> 00:00:31,028
而我们看到路由子系统正是完成这个过程的地点

12
00:00:31,031 --> 00:00:35,031
然后你可以设立一个名为‘routed. rb’的[ fall 00:00:32]

13
00:00:35,035 --> 00:00:37,035
尽管默认设置基本上会为你的模型上

14
00:00:37,037 --> 00:00:39,037
所有‘CRUD动作’(创建、读取、更新、删除)提供路由。

15
00:00:39,039 --> 00:00:43,039
同时你还需要添加执行动作的实际代码

16
00:00:43,043 --> 00:00:46,043
记住，当我们说“添加控制器代码”

17
00:00:46,046 --> 00:00:49,046
大多数情况下，发生动作的真正地点是模型，对吗？

18
00:00:49,049 --> 00:00:51,049
控制器代码正是起着

19
00:00:51,051 --> 00:00:55,051
调解视图与模型内容的作用，因此

20
00:00:55,055 --> 00:00:58,055
你要添加进控制器的代码往往要很小。

21
00:00:58,058 --> 00:01:00,058
你可能已经在模型里添加了实际执行的代码。

22
00:01:00,000 --> 00:01:03,060
现在基本上你只需要将它连接到

23
00:01:03,063 --> 00:01:06,063
你的应用程序的其余部分。一定要确保它有东西

24
00:01:06,066 --> 00:01:09,066
可返回。记住，‘http’是一种请求回复协议

25
00:01:09,069 --> 00:01:12,069
这表示无论何时向服务器做出请求

26
00:01:12,072 --> 00:01:15,072
都必须有内容返回。通常这种内容就是视图

27
00:01:15,075 --> 00:01:18,075
所以你必须要确保有视图

28
00:01:18,078 --> 00:01:21,078
与该动作关联。一种可能性是每一个视图

29
00:01:21,081 --> 00:01:24,081
或者每一个动作，都有单独的视图与之关联。

30
00:01:24,084 --> 00:01:27,084
但是如我们所见，另一个可能性是让不同的动作

31
00:01:27,087 --> 00:01:29,087
重复使用同一个视图

32
00:01:29,089 --> 00:01:33,089
只要有内容被返回就可以。我们要使用

33
00:01:33,093 --> 00:01:36,093
‘show action’（显示动作），以及与之相对应的视图，就像

34
00:01:36,096 --> 00:01:39,096
我们这里的演练实例。书上的演练实例使用的是

35
00:01:39,099 --> 00:01:41,099
‘index action’（索引动作），所以这样

36
00:01:41,101 --> 00:01:45,101
我们就得到两种不同的类型，记住，模型-视图-控制器的职责

37
00:01:45,105 --> 00:01:47,105
模型是动作发生的地点

38
00:01:47,107 --> 00:01:50,107
模型操作数据，与数据库对话

39
00:01:50,110 --> 00:01:52,110
控制器调出模型的内容，用于视图。

40
00:01:52,112 --> 00:01:55,112
所以我们要写入什么方法？我们要写入方法

41
00:01:55,115 --> 00:01:58,115
或者‘controller action’（控制器动作），我猜是，

42
00:01:58,118 --> 00:02:01,118
假设…你想看某部特定电影的相关信息

43
00:02:01,121 --> 00:02:05,121
就会从模型里获得这个信息

44
00:02:05,125 --> 00:02:08,125
或者通过模型从数据库获得信息，并创建一个视图

45
00:02:08,128 --> 00:02:11,128
显示这个信息，详细的信息。

46
00:02:11,131 --> 00:02:15,131
我们之所以能够创建一个能够使用

47
00:02:15,135 --> 00:02:18,135
某物的主关键ID的方法，是因为当我们创建索引，也就是

48
00:02:18,138 --> 00:02:21,138
所有电影的列表，每个电影旁边都有一个链接

49
00:02:21,141 --> 00:02:23,141
将你带往该电影的详情页

50
00:02:23,143 --> 00:02:26,143
那些链接基本上都是创建时，路由就都已经包含

51
00:02:26,146 --> 00:02:29,146
电影的ID。最终用户将永远不知道这一点

52
00:02:29,149 --> 00:02:31,149
但如果最终用户只是

53
00:02:31,151 --> 00:02:34,151
从名单上截取信息，如果我们能生成这个名单

54
00:02:34,154 --> 00:02:37,154
我们可以只要确保链接的指向都是对的。

55
00:02:37,157 --> 00:02:40,157
这就是书上索引实例演练的内容。

56
00:02:40,160 --> 00:02:43,160
它建立了一个视图，图中所有链接都嵌有ID

57
00:02:43,163 --> 00:02:46,163
我们将展示如何做到这一切。

58
00:02:46,166 --> 00:02:49,166
但是记住，这里的整体模版是

59
00:02:49,169 --> 00:02:52,169
当我们用控制器方法设立一个实体变量，比如‘@movie’

60
00:02:52,172 --> 00:02:55,172
它将可以神奇般地用在视图中

61
00:02:55,175 --> 00:02:57,175
该视图会显示数据，也许还能允许用户对它进行操作。

62
00:02:57,177 --> 00:03:01,177
在这个案例中，视图将显示电影内容和评级的描述

63
00:03:01,181 --> 00:03:05,181
以及其他内容，我们

64
00:03:05,185 --> 00:03:08,185
稍后展示视图，然后再看看还有其他什么内容也许我们

65
00:03:08,188 --> 00:03:11,188
想放到页面上的，以及用户如何

66
00:03:11,191 --> 00:03:27,191
从那个页面开始？我们去'Pastebin'，好了

67
00:03:27,207 --> 00:03:30,207
我们的视图会是什么样子？假设我们能够设立那个

68
00:03:30,210 --> 00:03:34,210
‘@ movie’（电影）变量，从而在视图中

69
00:03:34,214 --> 00:03:38,214
显示电影的详细信息，我们可以使用‘@ movie’变量

70
00:03:38,218 --> 00:03:40,218
并解引用它的标题。我们可以解引用它的上映时间

71
00:03:40,220 --> 00:03:43,220
并漂亮地打印出来。我们可以解引用它的

72
00:03:43,223 --> 00:03:47,223
评级，这是Haml，我们如何达到这一点？

73
00:03:47,227 --> 00:03:49,227
我们如何找出我们需要用来这么做的

74
00:03:49,229 --> 00:03:53,229
控制器方法，路由等？

75
00:03:53,233 --> 00:03:56,233
Rails为我们带来的优点之一是基本上其内置的辅助函数

76
00:03:56,236 --> 00:03:59,236
会生成包含正确信息的URL。所以我们说

77
00:03:59,239 --> 00:04:02,239
当我们在‘index view’（索引视图）中生成那个电影名单

78
00:04:02,242 --> 00:04:04,242
那些能够自动生成的链接包含了

79
00:04:04,244 --> 00:04:07,244
正确的电影信息，包括电影的主关键字。

80
00:04:07,247 --> 00:04:10,247
这是从书本上复制下来的表格

81
00:04:10,250 --> 00:04:14,250
其中显示，新建应用程序时

82
00:04:14,254 --> 00:04:19,254
我们所得到的默认路由设置为，每一个模型你所得到的路径

83
00:04:19,259 --> 00:04:23,259
都将允许你为‘index action‘（索引动作）生成REST风格的URI

84
00:04:23,263 --> 00:04:26,263
也就是所有实例的列表，包括 ‘CRUD动作‘

85
00:04:26,266 --> 00:04:30,266
创建、重更新、删除以及称为'新建'和'编辑'的动作

86
00:04:30,270 --> 00:04:32,270
只在web浏览器中有必要使用，因为它们相当于

87
00:04:32,272 --> 00:04:37,272
操作了一半。当你考虑...

88
00:04:37,277 --> 00:04:39,277
当你创建一部新电影，从你作为人类的角度看

89
00:04:39,279 --> 00:04:41,279
涉及两个步骤，对吗你必须有一个能够填写数据的

90
00:04:41,281 --> 00:04:44,281
空白表单，然后提交表单

91
00:04:44,284 --> 00:04:47,284
表单中的数据用于创建电影。

92
00:04:47,287 --> 00:04:49,287
它看起来是这幅模样的原因，尽管我们只是在做

93
00:04:49,289 --> 00:04:52,289
‘CRUD动作’，但是看起来有七个动作

94
00:04:52,292 --> 00:04:55,292
其中之一就是‘索引动作’，并不真正属于‘CRUD动作’

95
00:04:55,295 --> 00:04:57,295
但是它列出了集合的所有要素，另外两个动作

96
00:04:57,297 --> 00:05:00,297
新建'和'编辑'，就像是需要两步完成的互动的前半部分

97
00:05:00,000 --> 00:05:03,300
我们将从

98
00:05:03,303 --> 00:05:08,303
书本上的索引视图开始，视图里显示的代码中

99
00:05:08,308 --> 00:05:11,308
我们会看到“链接到电影路径”的代码

100
00:05:11,311 --> 00:05:14,311
其中包含一个主关键字。‘Movie path’（电影路径）将生成

101
00:05:14,314 --> 00:05:18,314
这个URL的辅助函数。因此给‘Movie path’（电影路径）一个参数

102
00:05:18,318 --> 00:05:22,318
它会将它转变成一个这种URL，然后

103
00:05:22,322 --> 00:05:28,322
编出我们想看到的电影ID。在视图中

104
00:05:28,328 --> 00:05:30,328
它将会最终显示为可以点击的普通旧链接

105
00:05:30,330 --> 00:05:33,330
URL已经建立好了

106
00:05:33,333 --> 00:05:37,333
当它与不同的路径匹配时，它会将电影的ID路径与

107
00:05:37,337 --> 00:05:40,337
'GET method'（GET方法）匹配，这意味着

108
00:05:40,340 --> 00:05:44,340
这个ID是一个替代物，是一个通配符，对于路由的这个部分

109
00:05:44,344 --> 00:05:46,344
数字3，因此它将可用于

110
00:05:46,346 --> 00:05:49,346
[参数00:05:46]阵列，能够被我们的‘controller action’（控制器动作）所看见。

111
00:05:49,349 --> 00:05:51,349
因此我们正在逐一启动动态部分。

112
00:05:51,351 --> 00:05:55,351
第一个动态部分是找出“这个URI匹配什么样的路由？”还有

113
00:05:55,355 --> 00:05:57,355
如果有通配符嵌在该路由中，就将

114
00:05:57,357 --> 00:06:00,357
通配符参数取出，让它们可用于[ 参数00:06:00]散列

115
00:06:00,000 --> 00:06:05,360
现在我们还知道，它将从rake 路由，

116
00:06:05,365 --> 00:06:08,365
调用什么样的‘controller action’（控制器动作），我们是如何知道的呢？

117
00:06:08,368 --> 00:06:13,368
好的，我要看看…我的应用程序，

118
00:06:13,373 --> 00:06:17,373
目前是暂停状态。如果我运行'rake routes'（rake路由）

119
00:06:17,377 --> 00:06:20,377
它就会查找我的路由文件，显示出所有已经为我设置好的

120
00:06:20,380 --> 00:06:24,380
映射。所以也就是说，例如

121
00:06:24,384 --> 00:06:29,384
当我做一部电影的'GET'方法时，当我'GET'一个URL

122
00:06:29,389 --> 00:06:34,389
匹配‘movies/ ID’（电影ID），以‘ID’作为通配符

123
00:06:34,394 --> 00:06:38,394
它将尝试调用电影控制器里的‘show action’（显示动作）

124
00:06:38,398 --> 00:06:41,398
因此逻辑上我的代码应该去那里，才能

125
00:06:41,401 --> 00:06:53,401
处理该请求。让我们再次启动应用程序。好了，那么我们已经看到了

126
00:06:53,413 --> 00:06:57,413
URI匹配好了。通配符已经提取出来

127
00:06:57,417 --> 00:07:00,417
我们也知道应该调用哪个‘controller action’（控制器动作）

128
00:07:00,000 --> 00:07:03,420
在那个控制器动作中，我们案例中的这个真的很短

129
00:07:03,423 --> 00:07:06,423
它唯一需要，也只需要做的是从模型获得信息

130
00:07:06,426 --> 00:07:09,426
并通过调用‘movie. find’（电影查找）实现。我们知道

131
00:07:09,429 --> 00:07:12,429
用户想看的该电影的主关键字，因此

132
00:07:12,432 --> 00:07:14,432
我们可以直接查找。我们要将它指派给实例

133
00:07:14,434 --> 00:07:17,434
变量电影，然后该变量变得在视图中可用

134
00:07:17,437 --> 00:07:20,437
视图是什么？好的，记住我们说的，“根据惯例配置，

135
00:07:20,440 --> 00:07:22,440
你不需要担心名称问题，

136
00:07:22,442 --> 00:07:25,442
只要遵循几个规则。”这里的规则是

137
00:07:25,445 --> 00:07:28,445
当你完成执行一个‘controller action’（控制器动作），除非额外设置

138
00:07:28,448 --> 00:07:31,448
否则Rails将查找一个同名视图。

139
00:07:31,451 --> 00:07:35,451
只是带有HTML. erb或HTML. haml。在那个案例中

140
00:07:35,455 --> 00:07:39,455
我们将在视图的电影子目录中查找‘show. html. haml’

141
00:07:39,459 --> 00:07:42,459
我们会返回给它，如果视图中使用了任何变量

142
00:07:42,462 --> 00:07:44,462
比如‘@ movie’，我们会替换

143
00:07:44,464 --> 00:07:46,464
控制器计算出的值。基本上这就是

144
00:07:46,466 --> 00:07:50,466
应用程序的往返过程。我们也可以让用户回到‘movie list’

145
00:07:50,470 --> 00:07:55,470
我们可以，比如，命名集合的REST风格URI是什么？

146
00:07:55,475 --> 00:07:57,475
所有电影的名单？好的，有一个辅助函数

147
00:07:57,477 --> 00:08:01,477
名为‘movies path’（电影路径）将返回一个路由，映射到

148
00:08:01,481 --> 00:08:05,481
‘index action’（索引动作），然后由‘rake routes’（rake路由）显示出来。

149
00:08:05,485 --> 00:08:08,485
因此‘movies path’（电影路径）不带参数地连接到‘index action’（索引动作），因此我们

150
00:08:08,488 --> 00:08:11,488
在视图中写上“这里有文本，这是超链接”

151
00:08:11,491 --> 00:08:13,491
URL将通过调用这个方法生成

152
00:08:13,493 --> 00:08:16,493
然后还是一样，这些在路由系统中都是分离的原因

153
00:08:16,496 --> 00:08:19,496
是如果你更改路由名称

154
00:08:19,499 --> 00:08:21,499
或者某些路由的工作方式，你不需要手动

155
00:08:21,501 --> 00:08:24,501
将这些变更传送给所有HTML模板

156
00:08:24,504 --> 00:08:26,504
因为你是在运行期间基于该文件信息

157
00:08:26,506 --> 00:08:28,506
生成的路由。

