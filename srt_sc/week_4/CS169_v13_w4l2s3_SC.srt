1
00:00:00,000 --> 00:00:03,000
让我们开始Rails及其模型视图控制器的旋风之旅。

2
00:00:03,003 --> 00:00:05,003
我们多多少少会以这个顺序进行下去，

3
00:00:05,005 --> 00:00:07,005
所以我们会从分量最重的这部分开始讲。

4
00:00:07,007 --> 00:00:11,007
我会为大家介绍活动记录。

5
00:00:11,011 --> 00:00:13,011
活动记录实际上就是设计模式。它不单单是

6
00:00:13,013 --> 00:00:16,013
作为Rails组成部分这个程序库的名称。想我们之前说过的那样， 

7
00:00:16,016 --> 00:00:19,016
它是一种思考方式。考虑这个问题：对象储存在类似于永久

8
00:00:19,019 --> 00:00:23,019
数据库的东西里时，你怎样连接内存对象

9
00:00:23,023 --> 00:00:25,023
与该对象的表示？这些对象就是Ruby类的实例。

10
00:00:25,025 --> 00:00:30,025
活动记录想要为我们回答的问题是， 

11
00:00:30,030 --> 00:00:32,030
我们怎样使用一些有趣儿的语言功能，

12
00:00:32,032 --> 00:00:35,032
像我们看过的反射与元编程，从而进行简化，

13
00:00:35,035 --> 00:00:39,035
怎样像我们提供这个设计模式，还有怎样执行它？

14
00:00:39,039 --> 00:00:42,039
在此情况下，讨论中的设计模式是活动记录，

15
00:00:42,042 --> 00:00:45,042
它填补了定义的Ruby类实例与存储的

16
00:00:45,045 --> 00:00:49,045
表示间的差距，即SQL内的CRUD。

17
00:00:49,049 --> 00:00:52,049
让我们立刻从一些缩写词开始讲。结构化查询语言，

18
00:00:52,052 --> 00:00:55,052
如果你从未听过它的缩写SQL，

19
00:00:55,055 --> 00:00:57,055
大概是因为多数人发音成“SQL”，不过我认为从技术上讲这

20
00:00:57,057 --> 00:01:00,057
不对，SQL是关系数据库使用的查询语言，

21
00:01:00,000 --> 00:01:03,060
如果算不上最重要，大概也是最为重要的内容之一，

22
00:01:03,063 --> 00:01:07,063
它推动了计算机科学发展， 

23
00:01:07,067 --> 00:01:10,067
从而使我们理解怎样组织与查询

24
00:01:10,070 --> 00:01:13,070
并讲解不同数据类型间的关系。事实上

25
00:01:13,073 --> 00:01:16,073
特德•科德因为他在关系代数方面的贡献

26
00:01:16,076 --> 00:01:19,076
获得图灵奖，而这是操作数据的形式方法，

27
00:01:19,079 --> 00:01:22,079
SQL语言实际上是在工程方面将关系代数实例化的

28
00:01:22,082 --> 00:01:25,082
方法，进而构建可按照上述规则操纵数据的

29
00:01:25,085 --> 00:01:29,085
引擎。活动记录的工作方式是Rails基于

30
00:01:29,089 --> 00:01:32,089
你的Ruby代码生成运行时

31
00:01:32,092 --> 00:01:35,092
需要的SQL语句，我会使用这个图标来引起大家注意，

32
00:01:35,095 --> 00:01:38,095
这是我们查看运行时生成代码的

33
00:01:38,098 --> 00:01:42,098
诸多示例中的一个。有时在运行时，

34
00:01:42,102 --> 00:01:45,102
其他时候在编译时，不过代码编写其他代码

35
00:01:45,105 --> 00:01:47,105
这个理念在Ruby中无处不在。我们已经借助像

36
00:01:47,107 --> 00:01:51,107
method_missing 与 attr_accessor 之类的工具看过一些内容，

37
00:01:51,111 --> 00:01:54,111
在此我们可以在运行时创建新代码。

38
00:01:54,114 --> 00:01:57,114
这是另一个示例。对于位于永久存储系统， 

39
00:01:57,117 --> 00:02:00,117
而不仅仅是关系数据库，真实存在于

40
00:02:00,000 --> 00:02:03,120
任何永久存储内的数据段，你可以做四件事情。

41
00:02:03,123 --> 00:02:06,123
你可以在那里创建新的数据段。你可以读取那里已有的数据。

42
00:02:06,126 --> 00:02:09,126
你可以就现有数据段更新内容，又或者

43
00:02:09,129 --> 00:02:12,129
你可以删除数据段。我们不会过多处理该类的原始SQL。

44
00:02:12,132 --> 00:02:15,132
我们实际上无需这样做，不过

45
00:02:15,135 --> 00:02:18,135
这至少值得读几本SQL指导手册

46
00:02:18,138 --> 00:02:21,138
学习一些基础内容，然后熟悉一下它的外观，

47
00:02:21,141 --> 00:02:24,141
这完全因为在像所有提取之类的一些情况中，活动记录

48
00:02:24,144 --> 00:02:27,144
是存在漏洞的抽象概念。有时它不会以你预计的方式运作，

49
00:02:27,147 --> 00:02:30,147
而有时又符合预计，这是因为你自己有所误解，

50
00:02:30,150 --> 00:02:33,150
你会不小心误用它，这样就无法表达你以为

51
00:02:33,153 --> 00:02:35,153
自己正在表达的查询。这在一定程度上

52
00:02:35,155 --> 00:02:38,155
可用于查看生成的SQL，然后说“噢，这就是我的查询

53
00:02:38,158 --> 00:02:40,158
为什么不起作用的原因。”

54
00:02:40,160 --> 00:02:43,160
{如果你正在用原始SQL编写，创建看起来是什么样子的}，这儿有一个简单示例。

55
00:02:43,163 --> 00:02:46,163
在此假设用户是表格的名称，而我

56
00:02:46,166 --> 00:02:49,166
要针对至少这三列插入数值，

57
00:02:49,169 --> 00:02:51,169
这会被认为是该纲要的一部分。该表格中的列。

58
00:02:51,171 --> 00:02:54,171
这儿有我要插入这些列的数值。

59
00:02:54,174 --> 00:02:57,174
我握有一个元组，这是关于我自己的信息，

60
00:02:57,177 --> 00:03:00,177
还有另一个元组，是关于Dave的信息。我已经在数据库增加了两行。

61
00:03:00,000 --> 00:03:03,180
我没有明确规定在表格内

62
00:03:03,183 --> 00:03:05,183
是否有有其他列，不过我自然假设表格内有三列。

63
00:03:05,185 --> 00:03:08,185
我还可以从表格读取信息。

64
00:03:08,188 --> 00:03:12,188
我可以说选择，然后星号表示在你找到符合我条件各行时，

65
00:03:12,192 --> 00:03:15,192
再将这些行中每行的所有相关属性返给我。

66
00:03:15,195 --> 00:03:19,195
特定条件为真的用户表格内

67
00:03:19,199 --> 00:03:22,199
选定星号。简单条件的示例为找出两个

68
00:03:22,202 --> 00:03:24,202
特殊日期间的生日。

69
00:03:24,204 --> 00:03:28,204
要匹配SQL的各项，你还可以使用许多其他方法。

70
00:03:28,208 --> 00:03:33,208
我可以进行更新。我可以这么说，在用户表格内更新，这样

71
00:03:33,213 --> 00:03:36,213
对于用户名称等于Fox的任何用户，你应进行替换，

72
00:03:36,216 --> 00:03:41,216
应设定新值，所以电子邮箱的属性就会变成这样。

73
00:03:41,221 --> 00:03:44,221
在一些情况下，如果我们假定用户名称在我们的示例中是独一无二的，

74
00:03:44,224 --> 00:03:47,224
那么在这种情况下，更新只会影响单行。

75
00:03:47,227 --> 00:03:50,227
这很有可能，事实上Rails依赖于这样的事实，即你能够

76
00:03:50,230 --> 00:03:52,230
编写更新可影响多行的语句。

77
00:03:52,232 --> 00:03:55,232
你掌握着符合某个标准的行集合，在其中每行上，

78
00:03:55,235 --> 00:03:58,235
你可以就地更新一个或多个属性。

79
00:03:58,238 --> 00:04:02,238
最后，你可以使用DELETE FROM（从中删除），这样

80
00:04:02,242 --> 00:04:05,242
你就可以提供多种方式匹配作为WHERE条件的内容。

81
00:04:05,245 --> 00:04:07,245
这是四项基本操作。我们可将

82
00:04:07,247 --> 00:04:12,247
这些功能作为讲解活动记录的起点。我们会从Ruby的方面简单

83
00:04:12,252 --> 00:04:15,252
讨论下模型是如何从活动记录库演变而来，同时这就是你

84
00:04:15,255 --> 00:04:17,255
连接模型与数据库的方式。

85
00:04:17,257 --> 00:04:20,257
在活动记录完成的许多工作中间， 

86
00:04:20,260 --> 00:04:22,260
这自然有助于就模型完成这些CRUD操作。

87
00:04:22,262 --> 00:04:26,262
让我们切换到代码视图。这儿有一小块Ruby代码。

88
00:04:26,266 --> 00:04:31,266
我在这儿都做了什么？我声明类电影是由活动记录库

89
00:04:31,271 --> 00:04:35,271
演化而来。这就是它了。我没有在这类内

90
00:04:35,275 --> 00:04:38,275
加入任何代码。因为大家都知道面向对象的

91
00:04:38,278 --> 00:04:41,278
编程，你会意识到这根本不重要，可以说这是

92
00:04:41,281 --> 00:04:43,281
因为在该类内已经有大量代码存在。

93
00:04:43,283 --> 00:04:46,283
这是原型具有的代码，活动记录数据库。

94
00:04:46,286 --> 00:04:48,286
我刚说了我要创建类电影对象，

95
00:04:48,288 --> 00:04:50,288
它们要继承活动记录数据库的所有行动。

96
00:04:50,290 --> 00:04:53,290
关于它们中的部分内容，有几个例子。我要创建

97
00:04:53,293 --> 00:04:57,293
新电影，请记住我们看见类名称的大写字母：Movie. NEW时，

98
00:04:57,297 --> 00:05:01,297
这表示新增就是类方法。

99
00:05:01,301 --> 00:05:04,301
这就有道理了。你还没有对象，所以你也不能对它做什么。

100
00:05:04,304 --> 00:05:07,304
你需要使用类方法为自己创建对象。

101
00:05:07,307 --> 00:05:11,307
你一完成对象，我就推定该对象具有这样的

102
00:05:11,311 --> 00:05:13,311
属性：标题与等级。很快我们会看到，并非

103
00:05:13,313 --> 00:05:17,313
在Ruby内宣称属性是什么，然后

104
00:05:17,317 --> 00:05:19,317
另行确保你有相匹配的数据库表格；

105
00:05:19,319 --> 00:05:22,319
其实Ruby会通过查看数据库表格切实推断出

106
00:05:22,322 --> 00:05:25,322
属性是什么。这就省得你打字了。

107
00:05:25,325 --> 00:05:28,325
另一种创建新电影的方法是我会借助这样的事实，即

108
00:05:28,328 --> 00:05:32,328
New可选择性地使用块，然后针对该块产生新创建的对象。

109
00:05:32,332 --> 00:05:35,332
如果我不得不针对对象做一些复杂的初始化操作，

110
00:05:35,335 --> 00:05:38,335
相比于用大量行建立单个东西， 

111
00:05:38,338 --> 00:05:44,338
这样做要往往容易得多。在Rails内，

112
00:05:44,344 --> 00:05:46,344
我们会经常注意到另一件事情，就是这儿的握手图标，

113
00:05:46,346 --> 00:05:49,346
即约定优于配置，这意味着

114
00:05:49,349 --> 00:05:52,349
你坚持一定的命名规格，

115
00:05:52,352 --> 00:05:55,352
你就可以省下大量的工作，免得告诉Rails

116
00:05:55,355 --> 00:05:58,355
不同类别的对象间有怎样的对应关系。在此情况下，

117
00:05:58,358 --> 00:06:01,358
假定数据库表格的名称来自模型的名称。

118
00:06:01,361 --> 00:06:04,361
如果模型名称是具有大写字母M的电影，那么

119
00:06:04,364 --> 00:06:09,364
数据库表格就是小写的电影，注意这里的电影是复数。为什么它是复数？

120
00:06:09,369 --> 00:06:11,369
因为一个表格含有一个以上的多部电影，这是理所当然的，所以

121
00:06:11,371 --> 00:06:14,371
名为单数电影的表格没有多大意义。

122
00:06:14,374 --> 00:06:17,374
变成复数只是为了让人更满意而已。万一你有疑问，

123
00:06:17,377 --> 00:06:19,377
如果你有表格，或者一个名为个人的模型， 

124
00:06:19,379 --> 00:06:22,379
这是不是意味着表格就应名为人们？是的，确实如此。

125
00:06:22,382 --> 00:06:25,382
如果你的模型名为绵羊，

126
00:06:25,385 --> 00:06:28,385
这是不是表示表格也该名为绵羊？没错，Ruby中

127
00:06:28,388 --> 00:06:30,388
有一部分只关注如何将单词复数化。这称为转换器。

128
00:06:30,390 --> 00:06:34,390
为什么会这样？因为这才有意义。你有一部电影，

129
00:06:34,394 --> 00:06:38,394
表格含有大量电影。这非常合理。

130
00:06:38,398 --> 00:06:41,398
数据库表格中的列名称成为模型属性的设值函数与获得者。

131
00:06:41,401 --> 00:06:43,401
这真的很重要，因为截至目前我们看到的都是

132
00:06:43,403 --> 00:06:47,403
我们定义过的，例如使用attr_accessor，我们想要的属性

133
00:06:47,407 --> 00:06:50,407
是什么。我会想大家展示，你们使用attr_accessor时，

134
00:06:50,410 --> 00:06:52,410
它切实做到的唯一一件事是，创建出

135
00:06:52,412 --> 00:06:55,412
世界上最简单的设值函数与获得者。真的只是

136
00:06:55,415 --> 00:06:58,415
围绕设定实例变量的包裹而已。现在这会变得不同，

137
00:06:58,418 --> 00:07:01,418
这向你说明，从某种意义上说，它之所以良好的优势在于

138
00:07:01,421 --> 00:07:05,421
这是通过设值函数与获得者存取数据对象属性的唯一方法。

139
00:07:05,425 --> 00:07:08,425
活动记录定义了设值函数与获得者， 

140
00:07:08,428 --> 00:07:12,428
它们实际借助向数据库对话实现运转。

141
00:07:12,432 --> 00:07:14,432
你是用这些模型的方式，Ruby看上去就像是使用

142
00:07:14,434 --> 00:07:18,434
attr_ accessor的普通原有模型，不过

143
00:07:18,438 --> 00:07:21,438
实施运转的方式已彻底变了。就像我们看到的那样，

144
00:07:21,441 --> 00:07:24,441
设值函数与获得者未切实改变实例变量。

145
00:07:24,444 --> 00:07:27,444
{不存在强调的实例变量}，例如，就电影的标题而言，

146
00:07:27,447 --> 00:07:32,447
作为替代，存在内部操纵，即Ruby

147
00:07:32,452 --> 00:07:35,452
操纵同时Rails导致数据库的变化。

148
00:07:35,455 --> 00:07:39,455
这是怎样起作用的呢？我们已经创建过新电影，不过我们

149
00:07:39,459 --> 00:07:41,459
尚未将其放入数据库。我们做的所有操作其实就是创建新的

150
00:07:41,461 --> 00:07:45,461
Ruby对象，然后对其设定一些属性。

151
00:07:45,465 --> 00:07:48,465
如果我们就这个对象调用保存，或保存加叹号{，或进行保存，又或者

152
00:07:48,468 --> 00:07:51,468
视你所想调用另一个}，一旦你就模型调用这个，

153
00:07:51,471 --> 00:07:53,471
这实际上就是变更发生的时机。就是你针对模型设定新属性后， 

154
00:07:53,473 --> 00:07:56,473
使用该属性切实更新数据库的时机。

155
00:07:56,476 --> 00:07:59,476
要记住我们之前说过的内容，

156
00:07:59,479 --> 00:08:01,479
在方法名称结尾有叹号时，这通常表示危险方法，

157
00:08:01,481 --> 00:08:05,481
使用时应多加注意。在运用末尾有叹号的

158
00:08:05,485 --> 00:08:07,485
活动记录方法情况下，这表示相比于非叹号方法， 

159
00:08:07,487 --> 00:08:11,487
如他们出现故障，就会引起异常，

160
00:08:11,491 --> 00:08:14,491
在他们故障时，会直接归零，所以大家要检查一番。

161
00:08:14,494 --> 00:08:16,494
哪一个更适合使用要视你想要实现的内容而定。

162
00:08:16,496 --> 00:08:20,496
一旦已创建完成一个对象，

163
00:08:20,500 --> 00:08:24,500
就会获得一个主键。要记住，我们说过，借助约定，

164
00:08:24,504 --> 00:08:29,504
Rails对象的主键是整数。它是整个表格内独一无二的ID。

165
00:08:29,509 --> 00:08:32,509
显然在保存对象前，

166
00:08:32,512 --> 00:08:34,512
它不能有ID，只能在数据库第一次保存时获取一个。

167
00:08:34,514 --> 00:08:39,514
如果你有活动记录模型且其ID属性为0，

168
00:08:39,519 --> 00:08:42,519
又或者如果你就此调用新记录并恢复真值，

169
00:08:42,522 --> 00:08:45,522
这就意味着从未保存该模型。

170
00:08:45,525 --> 00:08:47,525
你已经在内存中操作过了，不过并未在数据库内

171
00:08:47,527 --> 00:08:51,527
切实保存。所有这些行为都源自活动记录数据库。

172
00:08:51,531 --> 00:08:53,531
总的说来，它们不是Ruby对象中

173
00:08:53,533 --> 00:08:55,533
的真实项。

