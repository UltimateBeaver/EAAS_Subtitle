1
00:00:00,000 --> 00:00:03,000
这是计划与文档的观点。我们正在做这件事的

2
00:00:03,003 --> 00:00:08,003
部分原因是，在过去我们教这门课程的时候；

3
00:00:08,008 --> 00:00:11,008
我们从同学那里获得很多关于课程的好建议。

4
00:00:11,011 --> 00:00:17,011
这改变了我的生活。我得到一份工作。

5
00:00:17,017 --> 00:00:20,017
人们说，“我以前做过实习。没人构建软件， 

6
00:00:20,020 --> 00:00:22,020
在实际生活中，我们可不会这样做。”即便是关于[无声00:00:23]评论。

7
00:00:22,022 --> 00:00:25,022
他们说，“我永远不会用敏捷

8
00:00:25,025 --> 00:00:28,025
构建的软件。这太疯狂了。

9
00:00:28,028 --> 00:00:31,028
别人才这么做。”我想我们应该告诉大家

10
00:00:31,031 --> 00:00:35,031
官方的替代方法看上去是什么样的，这是因为，如果你们成了软件工程师。

11
00:00:35,035 --> 00:00:37,035
你可能这样做项目，所以你需要知道这些知识。

12
00:00:37,037 --> 00:00:41,037
这有助于你理解敏捷从何而来，还有助于你

13
00:00:41,041 --> 00:00:44,041
体会它正做的事情。你需要一段时间的学习才能这样做。

14
00:00:44,044 --> 00:00:47,044
他们不用用户故事、点数或速度。

15
00:00:47,047 --> 00:00:51,047
那他们用什么替代呢？这是之前……敏捷之前的事情。

16
00:00:51,051 --> 00:00:55,051
你怎样估算这些成本？你怎样制定这些计划？

17
00:00:55,055 --> 00:00:58,055
这就是所有步骤。如果你成为项目经理，

18
00:00:58,058 --> 00:01:01,058
你要在功能捕获、需求、文档、成本估算

19
00:01:01,061 --> 00:01:05,061
方面作出要求。你会

20
00:01:05,065 --> 00:01:08,065
安排并监控项目进度。你要做的是，

21
00:01:08,068 --> 00:01:13,068
改变管理，像是根据计划进行的版本控制、

22
00:01:13,073 --> 00:01:17,073
成本以及需求文档。你要确保

23
00:01:17,077 --> 00:01:20,077
实施情况切实符合合同、文档内规定的功能。

24
00:01:20,080 --> 00:01:26,080
然后去增加达到计划、

25
00:01:26,086 --> 00:01:28,086
达到预算目标的机会， 

26
00:01:28,088 --> 00:01:32,088
你要做风险分析与风险管理。这就是你要完成的全部任务。

27
00:01:32,092 --> 00:01:34,092
过上一遍会费点时间。让我们

28
00:01:34,094 --> 00:01:37,094
来处理需求捕获。你要寻找两方面内容，

29
00:01:37,097 --> 00:01:39,097
我把这称为功能性与非功能性需求。功能性需求就像

30
00:01:39,099 --> 00:01:43,099
我们之前已经看到的。新增电影以运行数据库。非功能性需求

31
00:01:43,103 --> 00:01:47,103
可以是……这是个很奇怪的说法，不过这与性能有关。

32
00:01:47,107 --> 00:01:50,107
非功能性；它不是功能。而应该是非功能的内容。

33
00:01:50,110 --> 00:01:55,110
非功能性需求表示99%的响应时间低于一秒钟或4/9的

34
00:01:55,115 --> 00:01:59,115
可靠性之类。你要怎样捕获这些信息？这同样

35
00:01:59,119 --> 00:02:02,119
源于客户，所以主要由项目经理完成这项工作。

36
00:02:02,122 --> 00:02:05,122
项目经理要试着面见客户。

37
00:02:05,125 --> 00:02:08,125
你想要知道实际怎样完成这个工作，

38
00:02:08,128 --> 00:02:10,128
而不是它应该采用的方式方法。也许你可以向所有

39
00:02:10,130 --> 00:02:13,130
利益相关方发送调查问卷，让他们填写好，

40
00:02:13,133 --> 00:02:15,133
或者你可以采用非正式的讨论。

41
00:02:15,135 --> 00:02:20,135
你想要试着感受实际应该怎样完成这项工作，或现如今怎样做这个工作。

42
00:02:20,140 --> 00:02:23,140
你可以与客户合作创建这些场景。

43
00:02:23,143 --> 00:02:27,143
可以从初始状态开始工作。你展示成功或失败的路径，

44
00:02:27,147 --> 00:02:30,147
可以同时做哪些事，以及最终状态。

45
00:02:30,150 --> 00:02:34,150
另一个方法又称用例法，实际上有个程序……

46
00:02:34,154 --> 00:02:36,154
有种语言，名为统一建模语言，

47
00:02:36,156 --> 00:02:39,156
可帮助你描述这些用例。

48
00:02:39,159 --> 00:02:43,159
其中有小的简图可以向客户展示

49
00:02:43,163 --> 00:02:48,163
系统为完成目标的所有步骤。这些是产品的方法……用户产品

50
00:02:48,168 --> 00:02:52,168
捕获，客户想要什么？你捕获需求后，

51
00:02:52,172 --> 00:02:56,172
就要编写文档。这是非常重要的文档。

52
00:02:56,176 --> 00:03:00,176
行话称其为SRS，代表

53
00:03:00,000 --> 00:03:04,180
软件需求规格说明书。非常大，约有数百页。

54
00:03:04,184 --> 00:03:09,184
关于如何编写SRS甚至还有IEEE标准。

55
00:03:09,189 --> 00:03:13,189
对于构建此文件的标准，你可以阅读标准的阐释文件。

56
00:03:13,193 --> 00:03:17,193
要记住的是，这是从无法运行的软件得来的灵感；

57
00:03:17,197 --> 00:03:19,197
我们要像土木工程一样进行处理。

58
00:03:19,199 --> 00:03:22,199
土木工程就有许多文件。我们也要做许多文件。

59
00:03:22,202 --> 00:03:28,202
你怎样判断SRS是否良好呢？

60
00:03:28,208 --> 00:03:31,208
我要告诉你有四件事要留意。你做这件事的方法， 

61
00:03:31,211 --> 00:03:34,211
让客户阅读这数百页的东西，然后给你反馈，又或者你

62
00:03:34,214 --> 00:03:37,214
构建具有数个功能的原型，借此获得反馈， 

63
00:03:37,217 --> 00:03:41,217
又或者生成测试用例以测试SRS。

64
00:03:41,221 --> 00:03:45,221
这里你要查看什么呢？四件事：有效性：

65
00:03:45,225 --> 00:03:49,225
是否所有需求都是必需的。一致性：那可太糟糕了。

66
00:03:49,229 --> 00:03:51,229
如果需求彼此冲突，听上去就很难成功。

67
00:03:51,231 --> 00:03:55,231
完整性：是否涵盖各项内容，是否包含所有限制条件？ 

68
00:03:55,235 --> 00:03:59,235
最后，是否可实施？你在构建

69
00:03:59,239 --> 00:04:02,239
项目前，就要编写这本项目的说明册。

70
00:04:02,242 --> 00:04:06,242
这是需求文件。成本估算如何呢？

71
00:04:06,246 --> 00:04:12,246
管理者要做的是将软件需求规格说明书分解成

72
00:04:12,252 --> 00:04:17,252
任务。你就要像使用的点数或任务的存储

73
00:04:17,257 --> 00:04:20,257
那样略作限制，你要将任务的时间

74
00:04:20,260 --> 00:04:23,260
限制在一至八周期间，如果时间超过八周，

75
00:04:23,263 --> 00:04:27,263
这个任务太大了；不足一周的话就很难做计划。

76
00:04:27,267 --> 00:04:31,267
你的经理会关注任务，分解这些事项，

77
00:04:31,271 --> 00:04:35,271
然后提供给任务估算。你可以通过工资与间接费用， 

78
00:04:35,275 --> 00:04:38,275
把这转化成钱。这相当简单。

79
00:04:38,278 --> 00:04:41,278
你什么时候这样做？在你得到合同之前做这件事

80
00:04:41,281 --> 00:04:44,281
这样在你拿到合同之后，你肯定喜欢

81
00:04:44,284 --> 00:04:48,284
这些成本估算彼此相似；我要做什么才能拿到手呢，还有哪些事项

82
00:04:48,288 --> 00:04:51,288
会让公司拨款构建呢。有个想法是你要设个安全余量。

83
00:04:51,291 --> 00:04:54,291
你们，也许是你和你的团队要工作数周。

84
00:04:54,294 --> 00:04:57,294
要耗费时间去做这些任务，然后你乘一个值， 

85
00:04:57,297 --> 00:05:01,297
像是1.3或1.5。还有个想法是你可以做三次估算。

86
00:05:01,301 --> 00:05:05,301
你做最好情况估算、预期情况与最差情况估算，

87
00:05:05,305 --> 00:05:08,305
在你看到这些估算结果后，

88
00:05:08,308 --> 00:05:11,308
你就可以猜到个大概了。这是成本模型。

89
00:05:11,311 --> 00:05:16,311
对于怎样做这件事有两种方法，

90
00:05:16,316 --> 00:05:19,316
一个叫做经验法，基本上以项目经理的

91
00:05:19,319 --> 00:05:21,319
经验与该公司的经验为基础得出。

92
00:05:21,321 --> 00:05:24,321
这是我们猜测的结果，要完成

93
00:05:24,324 --> 00:05:27,324
所有这些任务要费多少周时间。他们试着使得软件工程 

94
00:05:27,327 --> 00:05:30,327
和土木工程相似，这样他们就可

95
00:05:30,330 --> 00:05:32,330
得到定量方法。第一个很简单，

96
00:05:32,332 --> 00:05:35,332
“让我们估计每个任务的代码行数， 

97
00:05:35,335 --> 00:05:38,335
为公司计算每人每月要完成的代码行数， 

98
00:05:38,338 --> 00:05:40,338
然后进行划分，这样你就会知道这项工作需要多少人月

99
00:05:40,340 --> 00:05:43,340
月才能完成。”这里的问题是代码行数类似于……

100
00:05:43,343 --> 00:05:45,343
比尔•盖茨掌握着关于代码行数的代码， 

101
00:05:45,345 --> 00:05:48,345
不过要衡量这些东西的话，这是个错误的方法。

102
00:05:48,348 --> 00:05:51,348
这不太管用。研究人员决定，我们要看看……

103
00:05:51,351 --> 00:05:54,351
测量一堆项目。我们要使用更好的定量模型。

104
00:05:54,354 --> 00:05:57,354
他们称其为科科默模型，即建设性成本模型。

105
00:05:57,357 --> 00:06:02,357
其中有两个因数和一个指数。

106
00:06:02,362 --> 00:06:06,362
他们观察一堆项目，这儿有三个显著数字。

107
00:06:06,366 --> 00:06:12,366
我想要付出的努力应该是2.942的代码行数尺寸与代码行因数，

108
00:06:12,372 --> 00:06:18,372
1.23的损失值与1.07的产品因数。

109
00:06:18,378 --> 00:06:20,378
你把这几个数值相乘，就会知道在你的成本

110
00:06:20,380 --> 00:06:23,380
中要付出多少努力。

111
00:06:23,383 --> 00:06:26,383
大家会遇到科科默模型；不过这不太管用，

112
00:06:26,386 --> 00:06:31,386
所以他们提出了科科默二号，其中涉及17个因数。

113
00:06:31,391 --> 00:06:33,391
随时间推移软件变得越来越复杂。他们试图……

114
00:06:33,393 --> 00:06:36,393
我们可以对此做定量分析，这样我就知道我们是不是够努力。

115
00:06:36,396 --> 00:06:40,396
毫不奇怪的是，调查显示有92%的时间，客户

116
00:06:40,400 --> 00:06:44,400
只依赖他们的经验制作此模型。这就是成本估算。

117
00:06:44,404 --> 00:06:49,404
那么进度计划安排呢？你要试着了解的是，

118
00:06:49,409 --> 00:06:52,409
哪些代码的任务是可以并行完成的，

119
00:06:52,412 --> 00:06:56,412
大家或许听过PERT图表。让我向你们展示什么是PERT图表。

120
00:06:56,416 --> 00:06:59,416
这是航空航天工业开发出来的。它可以说明

121
00:06:59,419 --> 00:07:03,419
工作会耗费多少时间，要完成太空发射需要多长时间。

122
00:07:03,423 --> 00:07:08,423
这里每个节点都是一个里程碑。这些小方块，

123
00:07:08,428 --> 00:07:13,428
这个项目有11个里程碑，然后在这些弧线上的

124
00:07:13,433 --> 00:07:16,433
这些名称表示进行中的工作。这是需求捕获。

125
00:07:16,436 --> 00:07:21,436
弧线上的这些小数字表示以每人周为

126
00:07:21,441 --> 00:07:25,441
单位工作量有多少，这就是打个比方。然后

127
00:07:25,445 --> 00:07:29,445
箭头表示依存关系。人们制定PERT图表的一个原因是

128
00:07:29,449 --> 00:07:32,449
为了确认关键路径是什么；

129
00:07:32,452 --> 00:07:37,452
给定所有这些箭头，什么是……

130
00:07:37,457 --> 00:07:43,457
通过工作直到我们抵达最终的里程碑最长耗时多少。

131
00:07:43,463 --> 00:07:46,463
在此示例中，这儿有关键路径，这样你就可以

132
00:07:46,466 --> 00:07:50,466
沿这些线条划分所有工作量。然后这就会告诉你， 

133
00:07:50,470 --> 00:07:52,470
然后是某个生产率系数，显示完成项目

134
00:07:52,472 --> 00:07:55,472
要耗费多长时间。它还可显示你可以同时

135
00:07:55,475 --> 00:07:59,475
开展的工作。如果你是项目经理，

136
00:07:59,479 --> 00:08:02,479
你可以制定SRS将项目分解成任务；你加入对成本的考虑，

137
00:08:02,482 --> 00:08:06,482
然后借助像PERT图表之类的东西，使用那些来创建计划。

138
00:08:06,486 --> 00:08:09,486
现在你已经制成PERT图表，你要做什么才能开展所有项目？

139
00:08:09,489 --> 00:08:13,489
现在你要比较你预计的情况与事项实际消耗的时间，

140
00:08:13,493 --> 00:08:16,493
因此你要比对PERT图表同时跟踪实际支出与

141
00:08:16,496 --> 00:08:20,496
这些任务的耗时。他们发现的是

142
00:08:20,500 --> 00:08:22,500
通过分享这些中间里程碑；

143
00:08:22,502 --> 00:08:27,502
幻灯片上是他们的11个里程碑；每个人都清楚你是否

144
00:08:27,507 --> 00:08:31,507
符合预算或计划；构建项目的人员与客户。

145
00:08:31,511 --> 00:08:39,511
这样你就能在预算范围内及时完成任务，

146
00:08:39,519 --> 00:08:42,519
不过作为项目经理你的事情还没完。这切实达到你的预期了吗，

147
00:08:42,522 --> 00:08:45,522
客户要的是什么？

148
00:08:45,525 --> 00:08:49,525
这就叫做需求可追溯性，有些工具被开发出来可以

149
00:08:49,529 --> 00:08:53,529
在软件需求规格说明书内将这些片段结合在一起。

150
00:08:53,533 --> 00:08:57,533
后面的哪些软件需求

151
00:08:57,537 --> 00:09:00,537
与实施需求的代码片段有关联，

152
00:09:00,000 --> 00:09:03,540
哪个又与测试验证需求有关联？

153
00:09:03,543 --> 00:09:06,543
你可以借助这些工具将这些放在一起，从而自问，

154
00:09:06,546 --> 00:09:08,546
“我是否切实实施了客户要求的所有事项？让我看看测试一下。”

155
00:09:08,548 --> 00:09:13,548
是否测试合格？很好，因为这时，

156
00:09:13,553 --> 00:09:16,553
它会处理需求片段。测试与SRS内的相应代码

157
00:09:16,556 --> 00:09:20,556
是否涵盖数百页文件的所有内容？

158
00:09:20,560 --> 00:09:24,560
如果代码片段发生变化，

159
00:09:24,564 --> 00:09:28,564
你想要回头重新测试。为试验增加

160
00:09:28,568 --> 00:09:32,568
切中目标的机会，可以向商业学校借鉴

161
00:09:32,572 --> 00:09:36,572
风险分析管理。基本上，

162
00:09:36,576 --> 00:09:39,576
可以使这个更准确。你要试着想想

163
00:09:39,579 --> 00:09:43,579
在开始执行前会出现什么样的风险。如你确定了风险， 

164
00:09:43,583 --> 00:09:47,583
接下来要做什么？你可以多做些工作降低风险，

165
00:09:47,587 --> 00:09:50,587
多做些工作以自行修复，或改变计划，这样风险自会消失。

166
00:09:50,590 --> 00:09:55,590
有个技术挑战；关系数据库规模

167
00:09:55,595 --> 00:09:58,595
不能足够大。也许我们能找到更大设备以支持更大的关系数据库，

168
00:09:58,598 --> 00:10:03,598
这样我们就能消除该风险。

169
00:10:03,603 --> 00:10:06,603
我们的组织很熟悉J2EE，这是我们进行构建使用的东西。

170
00:10:06,606 --> 00:10:12,606
我们能做什么来消除那个风险？

171
00:10:12,612 --> 00:10:15,612
我们可以采取指导；在线指导可以使他们改善J2EE，这样

172
00:10:15,615 --> 00:10:19,615
就可消除风险。噢孩子们，商业风险是，

173
00:10:19,619 --> 00:10:22,619
对市场来说这太迟了。也许我们应该删减功能，

174
00:10:22,622 --> 00:10:26,622
这样我们就能让产品及时上市，所以这是可行的。

175
00:10:26,626 --> 00:10:32,626
如这真的很糟，那么我们根本就不该这么做。你们可以想象一下，

176
00:10:32,632 --> 00:10:35,632
你正在推想风险，你应该采取哪些建议？

177
00:10:35,635 --> 00:10:40,635
试着猜猜看有哪些风险。大家要尽全力预测

178
00:10:40,640 --> 00:10:44,640
这个风险发生的可能性，然后运用你自己的十分制，

179
00:10:44,644 --> 00:10:49,644
如这种事发生，给定一个冲击系数。

180
00:10:49,649 --> 00:10:52,649
对项目来说这会有多糟？你可以将意外次数乘以冲击系数，

181
00:10:52,652 --> 00:10:55,652
这就得出一个数值，你可以将此上浮

182
00:10:55,655 --> 00:11:00,655
前20%排定风险顺序，你希望这就是大部分风险。

183
00:11:00,000 --> 00:11:03,660
风险分析在试着保证你符合进度。

184
00:11:03,663 --> 00:11:06,663
这就是你作为经理要做的所有事项。

185
00:11:06,666 --> 00:11:09,666
我们把这些并列任务填入表格以方便你阅读。

186
00:11:09,669 --> 00:11:13,669
在左边有七步：

187
00:11:13,673 --> 00:11:17,673
需求文件、需求捕获、变更管理、

188
00:11:17,677 --> 00:11:20,677
进度、预算、确保需求、功能、进度安排及

189
00:11:20,680 --> 00:11:23,680
监控。这就是相应于用户故事、点数与速度的所有内容。

190
00:11:23,683 --> 00:11:26,683
我刚讲的用户故事、点数及速度

191
00:11:26,686 --> 00:11:31,686
在之前的几节课中讲过，

192
00:11:31,691 --> 00:11:35,691
它们比较直观。这是敏捷的替代方法。

193
00:11:35,695 --> 00:11:38,695
成本估算我们讲过，多少没有什么压力。

194
00:11:38,698 --> 00:11:41,698
你说你尽全力、各种方法实现它，而没有

195
00:11:41,701 --> 00:11:45,701
尝试符合并确保它、交付功能，然后做

196
00:11:45,705 --> 00:11:48,705
广泛的风险管理以便更可能实现要求。

197
00:11:48,708 --> 00:11:55,708
这儿就是备选方案的汇总，

198
00:11:55,715 --> 00:11:58,715
许多人使用这些方案处理很多项目，你自己也可能使用这些，

199
00:11:58,718 --> 00:12:02,718
它可以助你观察到敏捷的不同之处。让我们接着往下看。

200
00:12:02,722 --> 00:12:07,722
关于计划与文件需求和成本估算， 

201
00:12:07,727 --> 00:12:11,727
哪个表述有误？最接近计划与

202
00:12:11,731 --> 00:12:14,731
规划监控任务的文档的是敏捷的速度点数。

203
00:12:14,734 --> 00:12:17,734
最接近计划与软件需求规格说明书的是

204
00:12:17,737 --> 00:12:22,737
敏捷的用户故事。在确保需求方面，例如

205
00:12:22,742 --> 00:12:26,742
可追溯性，敏捷不存在对等内容。实际上，他们全部正确。

206
00:12:26,746 --> 00:12:31,746
他们中没有错误表述。我想让你们在这一个表述上停一下。

207
00:12:31,751 --> 00:12:37,751
让我们看看它们。首先在那里投票，各就各位，预备，投票。

208
00:12:37,757 --> 00:12:42,757
哇噻，颜色真不少，让我们讨论一下这个问题。让我们试着再次投票。

209
00:12:42,762 --> 00:12:48,762
各就各位，预备分组投票。喔，意见统一了，

210
00:12:48,768 --> 00:12:52,768
不错，真是法宝。让我们逐个讲讲。最接近计划与

211
00:12:52,772 --> 00:12:54,772
规划监控任务的文档的是敏捷的速度点数。

212
00:12:54,774 --> 00:12:59,774
是的。在回顾环节中可以使用敏捷。

213
00:12:59,779 --> 00:13:01,779
你们团队的经验是什么，分配点数，然后你可以

214
00:13:01,781 --> 00:13:04,781
多快使用它们预测未来？是的，相对于提前行动，是做计划。

215
00:13:04,784 --> 00:13:08,784
这有很大不同。最接近计划与软件

216
00:13:08,788 --> 00:13:11,788
需求规格说明书的是敏捷用户故事。

217
00:13:11,791 --> 00:13:14,791
没错，那些小小的3×5卡片就是你的书面

218
00:13:14,794 --> 00:13:18,794
文件规格说明书，相对于100页的程序簿或数百页的

219
00:13:18,798 --> 00:13:21,798
程序簿及IEEE标准，这是你与客户协作得出的结果。

220
00:13:21,801 --> 00:13:26,801
在确保需求方面，例如可追溯性，敏捷没有对等内容。

221
00:13:26,806 --> 00:13:31,806
是的，这就是BDD的含义。BDD将需求融入

222
00:13:31,811 --> 00:13:35,811
用户故事，然后我们很快看到

223
00:13:35,815 --> 00:13:38,815
我们得到那些3×5卡片，然后将他们变为验收测试。

224
00:13:38,818 --> 00:13:41,818
我们直接去客户那里请他们填写卡片，

225
00:13:41,821 --> 00:13:45,821
我们想要什么功能、实施它们。

226
00:13:45,825 --> 00:13:47,825
这就是验收测试，由此可确定虽然这不是

227
00:13:47,827 --> 00:13:50,827
计划与文档的组成部分，但存在这些功能，

228
00:13:50,830 --> 00:13:54,830
由此他们具有这些可追溯性工具，可测试并确保你完成了这一点。

229
00:13:54,834 --> 00:14:00,834
实际上存在三四个故障，不过这本来是种智慧。

230
00:14:00,000 --> 00:14:06,840
关于这点有问题吗？大家有问题吗？好。嗯，这就是

231
00:14:06,846 --> 00:14:08,846
总体替代顺序看上去的样子。

232
00:14:08,848 --> 00:14:11,848
同学们会做出这样的评价，“噢，我知道怎样在实际中构建软件。”

233
00:14:11,851 --> 00:14:13,851
没问题，是呀，还有别的方法可以构建软件。

234
00:14:13,853 --> 00:14:16,853
这是唯一的方法。它可实现积极的结果，

235
00:14:16,856 --> 00:14:19,856
如果我在做航天飞机之类的东西，我可能会使用包含所有东西的

236
00:14:19,859 --> 00:14:23,859
计划与文档，不过并不适用于许多东西。

237
00:14:23,863 --> 00:14:27,863
让我们继续讲课，这样就有时间

238
00:14:27,867 --> 00:14:30,867
再讲讲注释了。编写美丽的代码是另一回事。

239
00:14:30,870 --> 00:14:35,870
有趣的是，我的两个好朋友阿曼多•福克斯与约翰•奥斯特霍特。

240
00:14:35,875 --> 00:14:37,875
约翰•奥斯特霍特过去是这儿的教员，

241
00:14:37,877 --> 00:14:42,877
也是我见过的最优秀的程序员之一。他与阿曼多大体上

242
00:14:42,882 --> 00:14:47,882
都不赞成注释，阿曼多坚信代码本身就是文档描述，

243
00:14:47,887 --> 00:14:51,887
而奥斯特霍特认为这种代码有害。用自身来做文档的是有害的。

244
00:14:51,891 --> 00:14:55,891
让我们查看奥斯特霍特的建议，

245
00:14:55,895 --> 00:14:58,895
然后我们稍稍讲讲他们认同的部分，他们认同的部分。

246
00:14:58,898 --> 00:15:02,898
不良意见的示例，他们对此都表赞同。

247
00:15:02,902 --> 00:15:07,902
这儿有个有用的好注释。向i加1。谢谢， 

248
00:15:07,907 --> 00:15:12,907
我很高兴你们没做任何注释。没有这个注释，我不知道

249
00:15:12,912 --> 00:15:15,912
我到底弄明白了什么，好啦。这儿有另一个。

250
00:15:15,915 --> 00:15:21,915
锁定避免并行存取。自旋锁检测。好啦，这是……

251
00:15:21,921 --> 00:15:25,921
你写下它做了什么。此函数交换面板无效

252
00:15:25,925 --> 00:15:31,925
交换面板，面板1、面板2。很好。谢谢你这样做。

253
00:15:31,931 --> 00:15:35,931
对于良好注释的想法如何呢，阿曼多认为这些注释没那么好。

254
00:15:35,935 --> 00:15:39,935
奥斯特霍特说缺失的是你为什么这么做的原因。

255
00:15:39,939 --> 00:15:43,939
动机是什么？不要将注释写成它是什么。

256
00:15:43,943 --> 00:15:47,943
写下原因。你无法从代码中

257
00:15:47,947 --> 00:15:49,947
搞明白原因，为什么，也就是你这么做的原因。

258
00:15:49,949 --> 00:15:53,949
那应该在这儿。你想要注释具有较高水平，如果你改动的话就可以了；

259
00:15:53,953 --> 00:15:55,953
你改动代码时，

260
00:15:55,955 --> 00:15:57,955
你最终不得不这么做，这不会打破注释。

261
00:15:57,957 --> 00:16:05,957
这儿有个例子。如果我们要扫描序列

262
00:16:05,965 --> 00:16:07,965
看看是否存在指定符号，要那样做，而不是在注释内基本实施代码。

263
00:16:07,967 --> 00:16:12,967
这个注释就好多了，

264
00:16:12,972 --> 00:16:16,972
这样做。

265
00:16:16,976 --> 00:16:21,976
关于注释困难的是，没有多少好例子。打开源代码，就有糟糕的注释。

266
00:16:21,981 --> 00:16:24,981
如果这是你的示例，你就这很难看到好注释。

267
00:16:24,984 --> 00:16:27,984
在奥斯特霍特的代码中，注释的数量就

268
00:16:27,987 --> 00:16:30,987
和代码行数一样多。这确实对它有所帮助。

269
00:16:30,990 --> 00:16:35,990
我认为阿曼多认同为什么这部分，

270
00:16:35,995 --> 00:16:38,995
写下原因是件好事。他倒是愿意相信

271
00:16:38,998 --> 00:16:42,998
Ruby的优雅与良好的变量名称及其他类似的东西。

272
00:16:42,1002 --> 00:16:46,1002
即便没有注释，代码也是可以理解的。他赞同

273
00:16:46,1006 --> 00:16:52,1006
你们无法在那里写下原因。你想要弄明白

274
00:16:52,1012 --> 00:16:54,1012
正在发生什么事。关于遗留代码， 

275
00:16:54,1014 --> 00:16:57,1014
重要的一点是通常没有注释。

276
00:16:57,1017 --> 00:17:04,1017
他们想要处理这个问题。我跟朋友奥斯特霍特提起这个事时，

277
00:17:04,1024 --> 00:17:07,1024
我想他也认同这一点。这节课我最喜欢的是，

278
00:17:07,1027 --> 00:17:10,1027
基本上每次我都会告诉你们一个好主意。

279
00:17:10,1030 --> 00:17:14,1030
要执行这一点有个好工具。好主意。ABC复杂度怎么样呢？

280
00:17:14,1034 --> 00:17:22,1034
对于复杂度我们有Flog。循环复杂度怎么样呢？

281
00:17:22,1042 --> 00:17:27,1042
这是Seguro或Smells。哦，这是Reek。

282
00:17:27,1047 --> 00:17:31,1047
好注释。我们没有工具。对此的问题是，

283
00:17:31,1051 --> 00:17:33,1051
如果有理解工具的自然语言称这是个

284
00:17:33,1053 --> 00:17:36,1053
不赖的注释，那就很有用了。这节课我喜欢的是， 

285
00:17:36,1056 --> 00:17:39,1056
我们给大家的意见。你们按照意见操作，这样我们就知道你们是否

286
00:17:39,1059 --> 00:17:42,1059
使用指导老师的工具完成这一点。借助注释，

287
00:17:42,1062 --> 00:17:45,1062
大家可以通读代码看看你编写的注释是否良好，

288
00:17:45,1065 --> 00:17:48,1065
这并非可扩展的，所以他可以讲授高年级学生

289
00:17:48,1068 --> 00:17:54,1068
喜欢的课程。让我把这个总结一下。我们接下来要开始

290
00:17:54,1074 --> 00:17:56,1074
就如何编写美丽的代码与SOFA给些建议：简短、

291
00:17:56,1076 --> 00:18:00,1076
只做一件事、减少参数以及提取一致，

292
00:18:00,000 --> 00:18:02,1080
这样在这儿就不会有任何不优雅的代码。这些指标会指向问题区。

293
00:18:02,1082 --> 00:18:05,1082
虽不能保证万无一失，但它们都是

294
00:18:05,1085 --> 00:18:10,1085
很好的指示符。重大的创意、行为不同的设计是

295
00:18:10,1090 --> 00:18:14,1090
用户故事与Lo-Fi用户界面，这样就可立即与客户协作， 

296
00:18:14,1094 --> 00:18:16,1094
从而确定他们想要什么，以及你需要做什么。

297
00:18:16,1096 --> 00:18:18,1096
怎样做好这些；它们应当具有具体性、可测量性、

298
00:18:18,1098 --> 00:18:22,1098
可实现性、相关性及时间限制。

299
00:18:22,1102 --> 00:18:26,1102
追踪器很有用，可用于计算进度。

300
00:18:26,1106 --> 00:18:31,1106
其他总体涉及项目经理。他们工资很高，

301
00:18:31,1111 --> 00:18:34,1111
不过还有许多不确定，需要尝试并保证成功。

302
00:18:34,1114 --> 00:18:36,1114
就这样，我们下次再见。
