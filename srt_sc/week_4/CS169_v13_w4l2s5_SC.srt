1
00:00:00,000 --> 00:00:04,000
到目前为止，我只假设存在一个表，以便提供简单的例子。

2
00:00:04,004 --> 00:00:06,004
我没有交代这个表从何而来，

3
00:00:06,006 --> 00:00:09,006
为什么会有这些列。我们接下来要讲的是

4
00:00:09,009 --> 00:00:13,009
你要如何做到这件事情。

5
00:00:13,013 --> 00:00:15,013
我们对数据库的讨论将围绕迁移展开，

6
00:00:15,015 --> 00:00:18,015
迁移在其他编程框架中也许不会这么常用。

7
00:00:18,018 --> 00:00:21,018
{我想Rails将它放到表格上，这样

8
00:00:21,021 --> 00:00:24,021
多个程序员都可访问使用}。我们在此要解决的问题是一旦你的

9
00:00:24,024 --> 00:00:26,024
应用程序启动运行，如果

10
00:00:26,026 --> 00:00:29,026
有人关注这个应用程序，那么

11
00:00:29,029 --> 00:00:32,029
使用者就会想该应用程序中的个人数据

12
00:00:32,032 --> 00:00:34,032
非常重要。你测试或开发新功能时，如果该功能要求改变

13
00:00:34,034 --> 00:00:37,034
数据库结构，那你一定不想把这搞砸了。

14
00:00:37,037 --> 00:00:40,037
更改数据库结构时，

15
00:00:40,040 --> 00:00:43,040
你需要跟踪这些变更。显然，如果你不

16
00:00:43,043 --> 00:00:46,043
借助任何版本控制直接开发代码文件， 

17
00:00:46,046 --> 00:00:50,046
你就是个傻瓜，这样你就没办法倒回之前的代码版本。

18
00:00:50,050 --> 00:00:53,050
我们为什么认定同样的问题在数据库结构上

19
00:00:53,053 --> 00:00:56,053
就不一定发生呢？管理这两者的解决办法都是自动操作，

20
00:00:56,056 --> 00:01:00,056
像萌萌的跳舞机器人一样。

21
00:01:00,000 --> 00:01:02,060
总的说来，如果你将某个东西自动化处理，这就表示你可以

22
00:01:02,062 --> 00:01:04,062
做到操作具有一致性。我们会反反复复地讲到这个问题。

23
00:01:04,064 --> 00:01:08,064
你在软件工程中取得成功的几乎每个事项

24
00:01:08,068 --> 00:01:11,068
在一定程度上均依赖于自动化， 

25
00:01:11,071 --> 00:01:13,071
以便解决其中的部分愚蠢错误。事实上，

26
00:01:13,073 --> 00:01:18,073
我们稍后讲到部署时，我在今天上课前确切说

27
00:01:18,078 --> 00:01:21,078
课前15分钟刚从一个会议回来。会上有个运行

28
00:01:21,081 --> 00:01:24,081
游戏服务器后端的工作人员做了一个非常非常

29
00:01:24,084 --> 00:01:28,084
了不起的演讲。他说部署

30
00:01:28,088 --> 00:01:32,088
应该非常容易。发布应该也没什么难度。

31
00:01:32,092 --> 00:01:34,092
数据库结构变更，虽说稍稍难了点，但我们会试着

32
00:01:34,094 --> 00:01:38,094
借助自动化把这变成小事一桩。Rails处理的方式

33
00:01:38,098 --> 00:01:40,098
实际上并不只有一个数据库；

34
00:01:40,100 --> 00:01:42,100
而是很多个。你使用哪一个取决于环境。

35
00:01:42,102 --> 00:01:46,102
什么是环境？开发，这就是你在笔记本

36
00:01:46,106 --> 00:01:49,106
上敲着代码时的环境。

37
00:01:49,109 --> 00:01:51,109
生产，这是严禁碰触的环境，因为

38
00:01:51,111 --> 00:01:55,111
如果你弄坏它，人们就要气疯了。测试也是一种环境，

39
00:01:55,115 --> 00:01:57,115
只有为了运行自动测试方才存在此环境。

40
00:01:57,117 --> 00:02:00,117
千万不要把这个和你手动处理测试的

41
00:02:00,000 --> 00:02:03,120
环境混为一谈；这是开发。

42
00:02:03,123 --> 00:02:05,123
存在测试环境，使用测试工具才能彻底管理该环境。

43
00:02:05,125 --> 00:02:08,125
顺便说一下，你可以在这三种外定义更多环境。

44
00:02:08,128 --> 00:02:11,128
例如，很多公司会定义工作台环境， 

45
00:02:11,131 --> 00:02:14,131
这是处于生产环境中的服务，

46
00:02:14,134 --> 00:02:18,134
不过实际用户无法看到它们。如果除非它不存在，否则

47
00:02:18,138 --> 00:02:21,138
就存在于方方面面，虽然它最接近用户， 

48
00:02:21,141 --> 00:02:24,141
终端用户却看不见，所以与现场部署相同的条件

49
00:02:24,144 --> 00:02:27,144
到位情况下，这会在系统上运行。

50
00:02:27,147 --> 00:02:30,147
我们怎样变更数据库内容呢？

51
00:02:30,150 --> 00:02:33,150
有一个问题是，如果你说我们有多个数据库，

52
00:02:33,153 --> 00:02:37,153
那就要确保它们同步。开发中做出的任何结构变化、

53
00:02:37,157 --> 00:02:39,157
最终都会付诸生产，

54
00:02:39,159 --> 00:02:42,159
也许还要在工作台服务器内测试一番，

55
00:02:42,162 --> 00:02:45,162
同时，我的测试工具应该知道这些变化。

56
00:02:45,165 --> 00:02:48,165
我们通过迁移这样做。迁移实际上

57
00:02:48,168 --> 00:02:51,168
就是对你要做的变更进行描述的脚本。

58
00:02:51,171 --> 00:02:54,171
我们不会使用你最喜欢的SQL数据库添加列或四处移动列，

59
00:02:54,174 --> 00:02:57,174
而是编写代码描述我们要做的变更。

60
00:02:57,177 --> 00:03:00,177
我们可以确定该代码的版本， 

61
00:03:00,000 --> 00:03:03,180
因为这实际上就是Ruby。一旦我们确定变更合法，

62
00:03:03,183 --> 00:03:06,183
我们就得对生产环境采用相同变更，

63
00:03:06,186 --> 00:03:08,186
为此我们要做的就是在那儿运行同一脚本。

64
00:03:08,188 --> 00:03:12,188
这就是基本想法。你为什么要这么做？首先，

65
00:03:12,192 --> 00:03:14,192
你可以确认每次迁移。你知道每次应适时

66
00:03:14,194 --> 00:03:17,194
在哪些点完成纲要变更。不像代码，你可以标注为什么

67
00:03:17,197 --> 00:03:20,197
完成此次迁移。为什么我们要增加这一列？

68
00:03:20,200 --> 00:03:23,200
为什么我们选择删除那一列？有些迁移创建后是可逆的，

69
00:03:23,203 --> 00:03:26,203
这表示，这儿有我想完成的一组变更， 

70
00:03:26,206 --> 00:03:29,206
不过实际上所有变更都可以撤销。

71
00:03:29,209 --> 00:03:32,209
在开发中如果采用迁移，你可以做一件事， 

72
00:03:32,212 --> 00:03:34,212
就是在结果表明情况一塌糊涂时，你可以说，“哦， 

73
00:03:34,214 --> 00:03:38,214
撤销所有变更。”你会以规范的方式而非手动方式完成撤销，

74
00:03:38,218 --> 00:03:40,218
如果是手动方式的话，你就要记得我为

75
00:03:40,220 --> 00:03:43,220
做出此项变更而点击的八个地方？

76
00:03:43,223 --> 00:03:46,223
你可以借助版本控制管理他们，因为你可以对它们进行自动化处理，

77
00:03:46,226 --> 00:03:48,226
这很可靠。你可以重复。你可以在数台设备

78
00:03:48,228 --> 00:03:50,228
多次运行迁移，这会产生相同效果。

79
00:03:50,230 --> 00:03:53,230
我们借助快乐的跳舞机器人在此看到的主题是

80
00:03:53,233 --> 00:03:56,233
不要这么做，而要自动化处理。如你

81
00:03:56,236 --> 00:03:59,236
想要这么做，停下来想想我可以使用哪类工具

82
00:03:59,239 --> 00:04:02,239
自动化处理我要做的任务，

83
00:04:02,242 --> 00:04:05,242
这样我就能重复处理，然后追踪每次做的变更，

84
00:04:05,245 --> 00:04:08,245
为什么我要做这个变更，变更内容是什么。让我们看看迁移。

85
00:04:08,248 --> 00:04:13,248
要记住，我们说过生成代码的想法

86
00:04:13,253 --> 00:04:15,253
贯穿整个Rails。还有另一类代码生成器。

87
00:04:15,255 --> 00:04:19,255
这不会在运行时编写新代码。

88
00:04:19,259 --> 00:04:22,259
这类生成器会在文件内生成代码，然后该文件

89
00:04:22,262 --> 00:04:26,262
成为开发环境的组成部分。我们发布命令时Rails会

90
00:04:26,266 --> 00:04:29,266
生成迁移，而我们会给迁移名称，

91
00:04:29,269 --> 00:04:31,269
希望能表现迁移要做的事情。我们会

92
00:04:31,271 --> 00:04:34,271
创建迁移，而这会创建一个叫做"Movie"的表格，

93
00:04:34,274 --> 00:04:36,274
我就是把这个表用作示例，真是个简单的表格版本。

94
00:04:36,276 --> 00:04:47,276
让我们看看这个代码是什么样子的。你命令

95
00:04:47,287 --> 00:04:51,287
Rails生成迁移时，你会得到的是到处基本上都是空方法。

96
00:04:51,291 --> 00:04:55,291
你要填充这些方法的内容。我们在这个方法内做什么呢？

97
00:04:55,295 --> 00:04:59,295
我们会创建一个名为电影的表格。

98
00:04:59,299 --> 00:05:02,299
在该表格内，我们会有电影标题的字符串、

99
00:05:02,302 --> 00:05:05,302
等级的字符串、供描述使用的较长文本字段、

100
00:05:05,305 --> 00:05:08,305
关于发布时间的日期时间字段，等等，等等，

101
00:05:08,308 --> 00:05:12,308
我们即将就会看到的时间戳是一个字段，

102
00:05:12,312 --> 00:05:15,312
如果你添加它，Rails就会为你自动管理从而

103
00:05:15,315 --> 00:05:20,315
表明每条记录上次更新的时间，或是

104
00:05:20,320 --> 00:05:24,320
添加该记录的时间。这是向上迁移。

105
00:05:24,324 --> 00:05:27,324
所谓向上迁移，就是我做个从旧版本到

106
00:05:27,327 --> 00:05:30,327
新版本的数据库结构变更。现在，

107
00:05:30,330 --> 00:05:32,330
对我们来说，当前版本在数据库上没有任何内容。

108
00:05:32,332 --> 00:05:34,332
这不是更简单吗，对吧？在本次迁移结束时，会有

109
00:05:34,334 --> 00:05:38,334
一个表格，其中含有这些相关类型的这些列。

110
00:05:38,338 --> 00:05:42,338
相反情况是怎样的？我们要怎么做才能逆转该迁移？

111
00:05:42,342 --> 00:05:45,342
由于该迁移在创建表格方面保持一致，

112
00:05:45,345 --> 00:05:47,345
删除表格，意味着删除整个表格就是相反情况。

113
00:05:47,347 --> 00:05:51,347
这就是核心。你会删除表格。SQL给你

114
00:05:51,351 --> 00:05:53,351
造成很多麻烦，这就会成为删除表的SQL。

115
00:05:53,353 --> 00:05:57,353
表格会被毁灭殆尽。当然，你可以备份处理应用程序，

116
00:05:57,357 --> 00:05:59,357
你也可以每晚备份数据库，就像我们稍后课上讲的那样。

117
00:05:59,359 --> 00:06:02,359
如果发生这种事，你就仍未完全掌控情况。

118
00:06:02,362 --> 00:06:08,362
现在看，这就是代码的样子。我已经创建了迁移。

119
00:06:08,368 --> 00:06:10,368
我会填写上下方法，说明我要怎样变更数据库，

120
00:06:10,370 --> 00:06:12,370
我要如何撤销这一变化？

121
00:06:12,372 --> 00:06:15,372
我们实际上还没有做任何事。

122
00:06:15,375 --> 00:06:21,375
我们要以数据库更新的顺序运行此代码。

123
00:06:21,381 --> 00:06:23,381
我们刚刚创建了迁移，不过我们说的是

124
00:06:23,383 --> 00:06:27,383
我们尚未运用该迁移。我们处于开发环境的小盒子里。

125
00:06:27,387 --> 00:06:30,387
我们说rake db：迁移。这就会运行脚本， 

126
00:06:30,390 --> 00:06:33,390
按理想来说，会以无错误的方式，对数据库做这些变更。

127
00:06:33,393 --> 00:06:36,393
我们会展示非常简单的迁移，不过随着课程继续， 

128
00:06:36,396 --> 00:06:38,396
我们会展示较为复杂的迁移，其中会涉及添加新列、

129
00:06:38,398 --> 00:06:41,398
基于现有列值创建列以及

130
00:06:41,401 --> 00:06:44,401
其他许许多多的事项。请大家记住，我们还处于开发环境中。

131
00:06:44,404 --> 00:06:47,404
我们已经测试过代码了。我们知道，

132
00:06:47,407 --> 00:06:49,407
没错，迁移会运转，会完成应该做的事项。

133
00:06:49,409 --> 00:06:52,409
现在，我们做什么？我们要将它部署到生产环境。没问题。

134
00:06:52,412 --> 00:06:54,412
你刚刚运行了相同的命令，不过你在远程的heroku上了

135
00:06:54,414 --> 00:06:57,414
运行它。这就是了。你已经通过它完成的工作

136
00:06:57,417 --> 00:06:59,417
调试过程序了，然后你按下按钮，自动化就会接手。

137
00:06:59,419 --> 00:07:03,419
关于Rails管理迁移的方式，优点是

138
00:07:03,423 --> 00:07:06,423
迁移成功运行时，它同样会在专用数据库

139
00:07:06,426 --> 00:07:09,426
表格内记录已经采用了哪些迁移。

140
00:07:09,429 --> 00:07:12,429
事实上，你可以运行rake db：反复迁移且其项目有效。

141
00:07:12,432 --> 00:07:15,432
多次运行与运行一次相同。

142
00:07:15,435 --> 00:07:20,435
在你运行它时，实际意味着尚未看到采用

143
00:07:20,440 --> 00:07:22,440
本数据库副本的所有待决迁移。

144
00:07:22,442 --> 00:07:26,442
数据库本身知道那些已经看过了。

145
00:07:26,446 --> 00:07:29,446
这实在是无需持续跟踪的好方法，“哦， 

146
00:07:29,449 --> 00:07:31,449
我有工作台环境与生产。我是否已在工作台内

147
00:07:31,451 --> 00:07:33,451
运用过迁移了呢？我不无法确定。”

148
00:07:33,453 --> 00:07:36,453
这不要紧。只要运行rake db：迁移，如果

149
00:07:36,456 --> 00:07:41,456
你在那之前已经应用过了，它就什么都不做。节约时间。

150
00:07:41,461 --> 00:07:44,461
我们要开始编制如何在Rails SaaS应用程序内处理各种 

151
00:07:44,464 --> 00:07:47,464
事项的说明书，然后第一条就是你如何添加新模型？

152
00:07:47,467 --> 00:07:50,467
为向你的应用程序添加功能， 

153
00:07:50,470 --> 00:07:52,470
你应当添加模型、视图和/或控制器， 

154
00:07:52,472 --> 00:07:56,472
且模型是我们最先讨论的对象。你想添加新模型时或

155
00:07:56,476 --> 00:07:58,476
如你想要针对你现有的模型变更或添加属性，

156
00:07:58,478 --> 00:08:02,478
这表示已经含有对应的数据库表格，

157
00:08:02,482 --> 00:08:04,482
不过你想要对此做些变更。无论是哪种方式，

158
00:08:04,484 --> 00:08:08,484
你最初都要创建迁移，其中描述你想要做出的变更。

159
00:08:08,488 --> 00:08:11,488
如果可以，给它一个一半含义完整名称。使用rake db:migration

160
00:08:11,491 --> 00:08:14,491
实施迁移。确保一切都好，所有测试合格等等。

161
00:08:14,494 --> 00:08:19,494
如果这是个新模型，这就表示你

162
00:08:19,499 --> 00:08:21,499
之前从未使用过这类型的模型，你同样需要创建文件夹，

163
00:08:21,501 --> 00:08:24,501
其中包含模型的实际代码。我们展示一个非常

164
00:08:24,504 --> 00:08:27,504
简单的示例。你能掌握的最简单的活动记录是什么？

165
00:08:27,507 --> 00:08:29,507
这是从活动记录继承所有的项目，

166
00:08:29,509 --> 00:08:32,509
同时它不含自有逻辑。现在，如果你得应用程序含有这种模型，

167
00:08:32,512 --> 00:08:34,512
也许你不该使用Rails。

168
00:08:34,514 --> 00:08:38,514
对于你想做的事，Rails太笨重了。一般说来，

169
00:08:38,518 --> 00:08:40,518
你应至少在模型目录中的某处设

170
00:08:40,520 --> 00:08:44,520
实为B文件的模型，它的名称是单数版本的

171
00:08:44,524 --> 00:08:47,524
数据库表格。这儿存在对应关系。

172
00:08:47,527 --> 00:08:50,527
单数名称可用于类的大写。单一名称可用于

173
00:08:50,530 --> 00:08:53,530
文件名小写，然后复数化的版本

174
00:08:53,533 --> 00:08:57,533
小写字母可用于数据库表格。人们

175
00:08:57,537 --> 00:08:59,537
经常忘记做一件事，以至于他们刚刚

176
00:08:59,539 --> 00:09:02,539
成功运用迁移，现在试着重新运行测试， 

177
00:09:02,542 --> 00:09:05,542
可测试却突然开始发生故障时他们会非常困惑。请记住

178
00:09:05,545 --> 00:09:08,545
我说过作为标准至少切实存在三种环境。

179
00:09:08,548 --> 00:09:11,548
其中之一是测试环境。测试可以获取

180
00:09:11,551 --> 00:09:13,551
数据库本身的副本，而这完全独立于开发， 

181
00:09:13,553 --> 00:09:17,553
完全独立于生产。对此原因是由其性质而定， 

182
00:09:17,557 --> 00:09:20,557
测试可具有破坏性。

183
00:09:20,560 --> 00:09:22,560
你需要这样一个数据库，在其内测试不必担心损毁

184
00:09:22,562 --> 00:09:26,562
重要数据。无论何时更改结构，你都应单独予以确定。

185
00:09:26,566 --> 00:09:29,566
db:test prepare基本上就等同于说，

186
00:09:29,569 --> 00:09:32,569
“嘿，测试环境。我已经向我的数据库运用新迁移， 

187
00:09:32,572 --> 00:09:36,572
所以只克隆我的纲要就好，同时确保所有

188
00:09:36,576 --> 00:09:37,576
测试也看过那个新纲要与测试数据库。”

189
00:09:37,577 --> 00:09:41,577
再说一次，这是自动化的片段， 

190
00:09:41,581 --> 00:09:43,581
有它你就不必担心手动完成这件事， 

191
00:09:43,583 --> 00:09:45,583
切实保证各项一致。

