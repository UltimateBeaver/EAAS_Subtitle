1
00:00:00,000 --> 00:00:06,000
记住这一点后，假设我们已经完成一个简单的‘where’（位置）动作，并且

2
00:00:06,006 --> 00:00:08,006
已经看到‘movie’（电影），这里没有什么不清楚的，对吗？

3
00:00:08,008 --> 00:00:11,008
‘movie’（电影）存在了，它不会抛出异常。现在

4
00:00:11,011 --> 00:00:14,011
在我们做完这个之后，有另一个应用程序直接写入数据库

5
00:00:14,014 --> 00:00:16,014
也许它是另一个与我们的应用程序并行的应用

6
00:00:16,016 --> 00:00:21,016
在数据库表单中，它更改了

7
00:00:21,021 --> 00:00:24,021
‘movie’（电影）’的某个属性。假设更改的是标题。那么

8
00:00:24,024 --> 00:00:28,024
这个实例之后，‘movie’（电影）的值是什么？

9
00:00:28,028 --> 00:00:30,028
它会因为ActiveRecord

10
00:00:30,030 --> 00:00:34,030
连接内存数据对象与数据库的方式而自动更新吗？

11
00:00:34,034 --> 00:00:37,034
它会因为ActiveRecord能够使用

12
00:00:37,037 --> 00:00:40,037
元编程而自动更新吗？它是否不会自动更新

13
00:00:40,040 --> 00:00:43,040
但如果你重新执行‘where’（位置）动作，也就是

14
00:00:43,043 --> 00:00:47,043
重新载入后，就能得到更新后的值。或者这个行为

15
00:00:47,047 --> 00:00:50,047
是否在某种程度上取决于底层数据库？

16
00:00:50,050 --> 00:00:53,050
结果是否并不明确，只是这些你不该做的事情之一？

17
00:00:53,053 --> 00:00:58,053
初选结果..初选结果显示...初选结果...

18
00:00:58,058 --> 00:01:04,058
大多数人选择了红色，少部分人，我想说

19
00:01:04,064 --> 00:01:07,064
选择了橙色，还有一些其他选择。好的，我们来看看

20
00:01:07,067 --> 00:01:10,067
是否有人改变主意了。二次选择，二次选择

21
00:01:10,070 --> 00:01:16,070
二次选择，二次选择，二次选择…我想说

22
00:01:16,076 --> 00:01:19,076
选择红色的人增多了，但还远未达到全体一致。我们来仔细看看这些选项。

23
00:01:19,079 --> 00:01:23,079
自动更新，因为ActiveRecord模型

24
00:01:23,083 --> 00:01:26,083
将你的应用连接到数据库。好的，它尝试这么做，对吗？

25
00:01:26,086 --> 00:01:29,086
但它们依旧是两回事，没有…

26
00:01:29,089 --> 00:01:31,089
如果有人绕过我们的应用直接进入数据库

27
00:01:31,091 --> 00:01:34,091
也就是问题所假设的情况

28
00:01:34,094 --> 00:01:36,094
我们的应用不可能神奇般地知道这件事，对吗？

29
00:01:36,096 --> 00:01:39,096
数据库真的就像一个我们与之对话的被动储藏室

30
00:01:39,099 --> 00:01:42,099
所以如果我们的应用正在使用ActiveRecord与数据库对话

31
00:01:42,102 --> 00:01:44,102
但又有另一个别的应用单独与数据库对话

32
00:01:44,104 --> 00:01:47,104
那么我们的应用根本不可能了解

33
00:01:47,107 --> 00:01:50,107
正在发生的情况，对吗？数据库被直接更新后

34
00:01:50,110 --> 00:01:54,110
我们并不知道这个事实

35
00:01:54,114 --> 00:01:56,114
据我们所知，什么事也没发生。另一个选项，会自动更新因为

36
00:01:56,116 --> 00:01:59,116
ActiveRecord使用元编程？

37
00:01:59,119 --> 00:02:01,119
它当然会使用元编程，这样做可以更容易地实现

38
00:02:01,121 --> 00:02:05,121
多线连接，但还是一样，总体而言

39
00:02:05,125 --> 00:02:07,125
数据库不可能神奇般地通知我们，说，“看，这个已经改变了。”

40
00:02:07,127 --> 00:02:10,127
如果另一个应用从根本上在我们不知晓的情况下

41
00:02:10,130 --> 00:02:13,130
做了更改，但是当然，如果我们重新载入

42
00:02:13,133 --> 00:02:16,133
重新载入记录有很多种方法，但是

43
00:02:16,136 --> 00:02:19,136
‘movie.reload’(电影.重新载入)也能够做到，但是在这个实例中

44
00:02:19,139 --> 00:02:22,139
这样做确实会让我们获得新值，但同时又会带来不良后果

45
00:02:22,142 --> 00:02:27,142
如果我们对值做了本地更改又没有

46
00:02:27,147 --> 00:02:29,147
将更改返回数据库。如果我们这么做，我们的本地值

47
00:02:29,149 --> 00:02:32,149
会受到影响，从这里所得出的经验是

48
00:02:32,152 --> 00:02:36,152
数据库是独立于应用之外的{机构}。

49
00:02:36,156 --> 00:02:38,156
我们努力让它们二者接近，但是如果

50
00:02:38,158 --> 00:02:41,158
另一个应用瞒着我们直接在数据库里做修改

51
00:02:41,161 --> 00:02:44,161
除非我们采取特别的外部措施

52
00:02:44,164 --> 00:02:48,164
来了解这件事，否则我们不可能知道。我们来

53
00:02:48,168 --> 00:02:50,168
稍微讨论一下这一点，因为我看到人们对此有疑问。

54
00:02:50,170 --> 00:02:53,170
我们开始吧…好的，我们从后面开始。

55
00:02:53,173 --> 00:02:56,173
说话者2：我原以为‘movie. where’（电影.位置）

56
00:02:56,176 --> 00:02:58,176
没有从数据库返回数据库对象或任何信息

57
00:02:58,178 --> 00:03:02,178
但实际上它指向一个SQL查询语句

58
00:03:02,182 --> 00:03:05,182
在你将‘movie’（电影）解引用之后

59
00:03:05,185 --> 00:03:08,185
它会最终访问数据库。说话者1：事实上你说对了

60
00:03:08,188 --> 00:03:11,188
你是对的，技术上而言，我会…是的

61
00:03:11,191 --> 00:03:14,191
有人不选红色是因为这个原因吗？人群：

62
00:03:14,194 --> 00:03:17,194
有。说话者1：好的，你们都比我聪明多了。

63
00:03:17,197 --> 00:03:22,197
没错，顺便一提，讽刺的是，在2.X及更早的Rails框架版本中

64
00:03:22,202 --> 00:03:25,202
情况并不是这样。 事实上2. X版本的Rails查询不是惰性的。

65
00:03:25,205 --> 00:03:29,205
因此串联所有懒惰做法的好处已经不再凑效

66
00:03:29,209 --> 00:03:33,209
但是，是的，技术上而言，那是…我本应该做的…

67
00:03:33,213 --> 00:03:36,213
你们将获得Schreid-bag一份免费礼物。

68
00:03:36,216 --> 00:03:38,216
这让我想起，我本应该做的是，你知道，写上‘s- movie’或其他

69
00:03:38,218 --> 00:03:40,218
能强制求值的代码

70
00:03:40,220 --> 00:03:44,220
不过是的，大家观察得非常仔细，但实际上查询并没有进行。

71
00:03:44,224 --> 00:03:46,224
实际上查询一直没有进行，直到

72
00:03:46,226 --> 00:03:49,226
我尝试以某种方式使用那个值。指出得非常好

73
00:03:49,229 --> 00:03:52,229
你们当中想同样指出这一点的人

74
00:03:52,232 --> 00:03:53,232
也做得非常好。

