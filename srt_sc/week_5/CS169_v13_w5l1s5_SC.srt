1
00:00:00,000 --> 00:00:04,000
好的，我们几乎介绍完CRUD了，我们已经完成创建

2
00:00:04,004 --> 00:00:07,004
以及读取，现在我们只需要做更新和删除。

3
00:00:07,007 --> 00:00:10,007
好消息是现在你几乎已经至少见过所有的基本结构了。

4
00:00:10,010 --> 00:00:12,010
我们只是将它以不同的方式组合在一起。

5
00:00:12,012 --> 00:00:17,012
当我们实现创建动作时，

6
00:00:17,017 --> 00:00:20,017
我们看到一个创建实际相当于二次交互，

7
00:00:20,020 --> 00:00:22,020
当谈论一个面向人类的web服务。我们有表单要填写，

8
00:00:22,022 --> 00:00:25,022
然后提交填写后的表单，

9
00:00:25,025 --> 00:00:28,025
这通常是两个不同的控制器动作。

10
00:00:28,028 --> 00:00:29,028
顺便一提，我要指出，我们稍后再回到这个问题上，

11
00:00:29,029 --> 00:00:33,029
创建是包含两个动作的概念，

12
00:00:33,033 --> 00:00:36,033
意识到制作面向人类的应用程序

13
00:00:36,036 --> 00:00:41,036
是一件工艺品很重要。

14
00:00:41,041 --> 00:00:45,041
如果你将Rotton Potatoes视为一个管理电影信息评论的远程服务，

15
00:00:45,045 --> 00:00:47,045
那么你会认为，

16
00:00:47,047 --> 00:00:51,047
从逻辑上说，创建一个新电影清单是一个动作。

17
00:00:51,051 --> 00:00:53,051
这里有一些数据能够创建一部新电影。创建一下，

18
00:00:53,053 --> 00:00:56,053
然后告诉我是否成功。我们很快将看到的是，

19
00:00:56,056 --> 00:00:58,056
基本上变更1行控制器代码，就可以在你的应用程序中为面向人类的网站

20
00:00:58,058 --> 00:01:03,058
制作相同的逻辑，

21
00:01:03,063 --> 00:01:06,063
用户必须做2次交互来实现创建

22
00:01:06,066 --> 00:01:08,066
面向服务的架构也是一样，只需要一个动作。

23
00:01:08,068 --> 00:01:11,068
基本上你可以非常轻易地让代码

24
00:01:11,071 --> 00:01:15,071
实现其他功能。说完这一切，编辑更新动作

25
00:01:15,075 --> 00:01:18,075
完全是类似的，如果我想要编辑已有电影的信息，

26
00:01:18,078 --> 00:01:21,078
我要做两件事：首先

27
00:01:21,081 --> 00:01:24,081
要将现有的信息摆出来，

28
00:01:24,084 --> 00:01:27,084
通常在一个已经提前填好值的表单内，

29
00:01:27,087 --> 00:01:29,087
然后我必须在修改信息后提交表单。

30
00:01:29,089 --> 00:01:32,089
我们将使用相同的技巧，第一个动作取回表单，

31
00:01:32,092 --> 00:01:36,092
第二个动作提交表单。

32
00:01:36,096 --> 00:01:39,096
和创建动作一样，在更新动作结束时，

33
00:01:39,099 --> 00:01:42,099
我们将使用重定向，在这个样例中，回到显示电影详情的动作。

34
00:01:42,102 --> 00:01:45,102
而不是展示一个仅仅表示更新成功的视图，

35
00:01:45,105 --> 00:01:48,105
然后无处可去。现在，

36
00:01:48,108 --> 00:01:51,108
这个案例的不同之处在于，当你创建一部新电影，

37
00:01:51,111 --> 00:01:54,111
最初的表单应该是空白的，但如果你编辑的是一部已有的电影，

38
00:01:54,114 --> 00:01:57,114
已有的值预先填好更合理一点。

39
00:01:57,117 --> 00:02:04,117
那么，我们如何做到？

40
00:02:04,124 --> 00:02:06,124
这对编辑更新组合真的非常类似于我们之前所见过的。

41
00:02:06,126 --> 00:02:10,126
不同之处在于动作。提供表单的编辑动作，

42
00:02:10,130 --> 00:02:14,130
首先要抓取正在编辑的现有电影的ID，

43
00:02:14,134 --> 00:02:19,134
它会用它来填充这个

44
00:02:19,139 --> 00:02:22,139
@movie变量，所以当我们第一次显示表单，

45
00:02:22,142 --> 00:02:24,142
已有信息将被提前填好。

46
00:02:24,144 --> 00:02:28,144
然后，更新动作看起来与创建动作很像。

47
00:02:28,148 --> 00:02:30,148
我们只是要抓取电影的ID进行更新，

48
00:02:30,150 --> 00:02:33,150
这是一个不同点，因为在我们创建一部全新的电影之前，

49
00:02:33,153 --> 00:02:36,153
我们将调用update_attributes，

50
00:02:36,156 --> 00:02:40,156
你们已经看到了。我们将传递用户在表单上填写的值的散列表，

51
00:02:40,160 --> 00:02:44,160
flash消息和重定向。

52
00:02:44,164 --> 00:02:47,164
因此，所有相同的机制，也适用于我们在创建动作中所做的操作。

53
00:02:47,167 --> 00:02:52,167
另一个区别是，

54
00:02:52,172 --> 00:02:55,172
我们使用post创建新电影，

55
00:02:55,175 --> 00:03:00,175
用put更新已有电影。

56
00:03:00,000 --> 00:03:02,180
首先，为什么，其次，我们如何做到这一点，

57
00:03:02,182 --> 00:03:06,182
因为web浏览器通常只支持get和post，

58
00:03:06,186 --> 00:03:10,186
但不支持put。发生了什么事吗？那么，其中一个原因是，

59
00:03:10,190 --> 00:03:12,190
还是一样，Rails首先考虑建立一个REST风格的应用程序，

60
00:03:12,192 --> 00:03:16,192
其次再考虑如何制作

61
00:03:16,196 --> 00:03:19,196
一个面向人类的接口。在你的设计过程中，

62
00:03:19,199 --> 00:03:21,199
你真的应该从REST风格的动作考虑。

63
00:03:21,201 --> 00:03:24,201
区分不同种类的REST风格动作的一种方式，

64
00:03:24,204 --> 00:03:27,204
比如post和put之间，日益成为一个常见的语义，

65
00:03:27,207 --> 00:03:31,207
put用来更新已有信息

66
00:03:31,211 --> 00:03:34,211
而post用来提交全新的信息。

67
00:03:34,214 --> 00:03:38,214
这是一个新兴的共识。

68
00:03:38,218 --> 00:03:42,218
拥有不同的REST风格路由没什么问题，唯一的区别在于

69
00:03:42,222 --> 00:03:45,222
使用哪个动词，是使用put还是post。现在，第二个问题怎么样，

70
00:03:45,225 --> 00:03:48,225
web浏览器只能生成get或post动作，

71
00:03:48,228 --> 00:03:51,228
它们不能生成put。我们如何做到？

72
00:03:51,231 --> 00:03:59,231
幸运的是，事实证明，预测这一问题，

73
00:03:59,239 --> 00:04:03,239
如果我们指定put方法，

74
00:04:03,243 --> 00:04:06,243
也就是我们需要对这个表单所做的，在Rails世界中将会发生什么？

75
00:04:06,246 --> 00:04:08,246
我们说我们想要触发REST风格动作，

76
00:04:08,248 --> 00:04:12,248
就地更新现有信息。但是，这里实际上发生的是，

77
00:04:12,252 --> 00:04:16,252
当html从这里被生成，它将作为post被生成，

78
00:04:16,256 --> 00:04:19,256
这个方法web浏览器知道该如何处理，

79
00:04:19,259 --> 00:04:22,259
但是将会有一个额外的隐藏表单字段，

80
00:04:22,262 --> 00:04:25,262
基本上是嵌在表单内的，触发Rails说，

81
00:04:25,265 --> 00:04:28,265
这个应该是put，但web浏览器不知道如何做put，

82
00:04:28,268 --> 00:04:31,268
所以在你通向控制器方法的途中，

83
00:04:31,271 --> 00:04:34,271
将post变为了put。这样做很有趣，所以所有这一切的效果

84
00:04:34,274 --> 00:04:38,274
是在你的控制器动作中，你可以问哪种HTTP方法

85
00:04:38,278 --> 00:04:42,278
被用于提交此表格，答案是put，

86
00:04:42,282 --> 00:04:44,282
即使一开始在web浏览器用的是post。

87
00:04:44,284 --> 00:04:47,284
还是一样，你为什么要设计Rails来支持这个行为；

88
00:04:47,287 --> 00:04:51,287
这是因为你要设计一个REST风格服务接口，

89
00:04:51,291 --> 00:04:53,291
你希望控制器方法说，

90
00:04:53,293 --> 00:04:56,293
好吧，我有put，我有这个动词：我知道它意味着什么，

91
00:04:56,296 --> 00:04:58,296
意味着更新。我唯一真正需要知道的是

92
00:04:58,298 --> 00:05:01,298
结果能被看到，

93
00:05:01,301 --> 00:05:05,301
或将结果送往另一个服务。我希望put的语义相同，

94
00:05:05,305 --> 00:05:08,305
不论是这两个中的哪一个。这强化了一个事实，

95
00:05:08,308 --> 00:05:10,308
稍后，我将向你们展示如何做到这一点。

96
00:05:10,310 --> 00:05:14,310
因此你们可以相信我说的，

97
00:05:14,314 --> 00:05:19,314
put能够被转变为post，我们唯一还没有做的事是销毁，

98
00:05:19,319 --> 00:05:22,319
简单明了。记得我们说销毁是一种实例方法，

99
00:05:22,322 --> 00:05:26,322
销毁的原因是你调用…在一个电影集合上，

100
00:05:26,326 --> 00:05:29,326
说把这个销毁掉。

101
00:05:29,329 --> 00:05:32,329
但是不对，你真正想做的是销毁实例，

102
00:05:32,332 --> 00:05:35,332
因为你想给它一个机会去清理自己。

103
00:05:35,335 --> 00:05:37,335
这个话题，等我们开始谈论

104
00:05:37,337 --> 00:05:40,337
关联和高级Rails方法时再细谈。

105
00:05:40,340 --> 00:05:43,340
因为销毁是一个实例方法，我们采用相同的策略，

106
00:05:43,343 --> 00:05:47,343
我们可以先基于参数映射找到电影。我们可以调用destroy，

107
00:05:47,347 --> 00:05:50,347
然后可以加入flash消息，

108
00:05:50,350 --> 00:05:53,350
以确认一切有效，并重定向到某个有趣的地方。

109
00:05:53,353 --> 00:05:56,353
重定向是一种普遍机制，表达我已经完成你所要求的，

110
00:05:56,356 --> 00:05:58,356
而不是只给你展示一个无聊的页面

111
00:05:58,358 --> 00:06:01,358
显示一个事实，我会为你节省一步，带你回到

112
00:06:01,361 --> 00:06:05,361
可能更有趣的一些地方。但是，就这样了，

113
00:06:05,365 --> 00:06:08,365
你们现在已经基本上见到所有你们能做的CRUD动作，

114
00:06:08,368 --> 00:06:10,368
和操作过程中要求的不算多的机制。
