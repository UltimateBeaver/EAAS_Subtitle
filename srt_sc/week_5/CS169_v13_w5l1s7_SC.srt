1
00:00:00,000 --> 00:00:05,000
现在圆满完成了。谬论、陷阱、视角…

2
00:00:05,005 --> 00:00:09,005
我们已经花了一些时间观察机制、代码行，

3
00:00:09,009 --> 00:00:11,009
我觉得我们的课上得很顺利。

4
00:00:11,011 --> 00:00:14,011
你们能频繁地观察细节和代码行，。

5
00:00:14,014 --> 00:00:16,014
然后也尝试退后，观察大画面。

6
00:00:16,016 --> 00:00:20,016
让我先从几个陷阱开始，{胖控制器和胖视图}。

7
00:00:20,020 --> 00:00:23,020
当我说胖控制器，

8
00:00:23,023 --> 00:00:25,023
并不是指处于某个特定职业的人类。

9
00:00:25,025 --> 00:00:29,025
而是指那些方法开始变得很长很长的控制器。

10
00:00:29,029 --> 00:00:31,029
在我所展示的一个简单样例中，

11
00:00:31,031 --> 00:00:34,031
控制器方法就只有四行。

12
00:00:34,034 --> 00:00:37,034
在实际中，它会比这稍微长一点，但是不应该长太多。

13
00:00:37,037 --> 00:00:40,037
变成这样的原因是因为当你开始考虑

14
00:00:40,040 --> 00:00:43,040
在我的映射中编写新的动作，

15
00:00:43,043 --> 00:00:46,043
你的应用程序中第一位是什么，是与用户联系吗？

16
00:00:46,046 --> 00:00:49,046
是控制器，对吗？这就是模型-视图-控制器的工作方法。

17
00:00:49,049 --> 00:00:53,049
你所写的能打动用户的第一个代码，

18
00:00:53,053 --> 00:00:56,053
就是控制器代码。

19
00:00:56,056 --> 00:01:00,056
它是你无法避免的开始编码的地方，它就是你一直编码的地方。

20
00:01:00,000 --> 00:01:01,060
还有一件事，只多添加几行，

21
00:01:01,061 --> 00:01:04,061
你就会很快写出一页那么长的控制器方法。

22
00:01:04,064 --> 00:01:06,064
你发现控制器的工作，其实真正应该

23
00:01:06,066 --> 00:01:09,066
属于模型。如果这个工作很有趣，

24
00:01:09,069 --> 00:01:12,069
模型应该自己做。这是一个巨大的诱惑，

25
00:01:12,072 --> 00:01:15,072
你应该避免开始。只要把代码扔到你的控制器方法里，

26
00:01:15,075 --> 00:01:18,075
因为它恰好是你编写新应用程序代码时

27
00:01:18,078 --> 00:01:23,078
看的第一个地方。{Fav}的使用也是类似的问题，

28
00:01:23,083 --> 00:01:26,083
HAML做一些社会工程，试图让在视图中添加代码变得很奇怪。

29
00:01:26,086 --> 00:01:30,086
但是人们得以绕过它。

30
00:01:30,090 --> 00:01:33,090
它的初衷很天真：“我有一个物品集，

31
00:01:33,093 --> 00:01:35,093
所以我只需要一个简单的循环来遍历这个集合，

32
00:01:35,095 --> 00:01:39,095
并打印出一个表格或项目。”好吧，

33
00:01:39,099 --> 00:01:41,099
这是合理的。但这不是我想要的方式，

34
00:01:41,101 --> 00:01:44,101
所以在我显示表格之前

35
00:01:44,104 --> 00:01:46,104
我要添加几行代码来做一下分类。

36
00:01:46,106 --> 00:01:49,106
如果用户没有登录，而且他们不该看到一些选择呢？”

37
00:01:49,109 --> 00:01:51,109
还是一样，你正处于滑坡上，决定真的应该在别的地方做。

38
00:01:51,111 --> 00:01:55,111
视图只是为了展示，

39
00:01:55,115 --> 00:01:58,115
如果你需要一些代码来美化视图所呈现的内容，

40
00:01:58,118 --> 00:01:59,118
那就是辅助函数的功能。你可以将辅助方法放入第一个内容里。

41
00:01:59,119 --> 00:02:04,119
我说过这个真的很容易，

42
00:02:04,124 --> 00:02:07,124
因为它的理念就是首先决定RESTful服务,

43
00:02:07,127 --> 00:02:10,127
其次是面向用户的服务.实际上很容易，

44
00:02:10,130 --> 00:02:12,130
只要使用相同的控制器代码来匹配二者的意图。

45
00:02:12,132 --> 00:02:16,132
我将展示一个实际操作的例子。

46
00:02:16,136 --> 00:02:19,136
通常如果你作为面向服务的架构的服务被调用。

47
00:02:19,139 --> 00:02:22,139
{颜色可能会认为你会用XML或JSON. XML发送成果。}

48
00:02:22,142 --> 00:02:27,142
我们已经通过Osmosis. JSON看过，

49
00:02:27,147 --> 00:02:30,147
等我们稍后谈论JavaScript的时候再细说。

50
00:02:30,150 --> 00:02:33,150
基本上我将给你们展示的是琐碎的控制器变更。

51
00:02:33,153 --> 00:02:36,153
我们来重设，不论重设为哪种方式。

52
00:02:36,156 --> 00:02:45,156
我们来看，这里有一个创建动作的版本，

53
00:02:45,165 --> 00:02:48,165
在面向服务的架构或者

54
00:02:48,168 --> 00:02:51,168
我们刚刚建立的面向人的架构中都能正常使用。我在这里改变了什么？

55
00:02:51,171 --> 00:02:56,171
前面两行是一样的，更新属性。

56
00:02:56,176 --> 00:02:59,176
这两者都不…这里所改变的是

57
00:02:59,179 --> 00:03:02,179
我们在返回步骤中的做法。我所做的是将返回步骤

58
00:03:02,182 --> 00:03:06,182
放入这个方法所响应的模块里。

59
00:03:06,186 --> 00:03:11,186
这个响应的模块，Ruby或者

60
00:03:11,191 --> 00:03:14,191
Rails称为收集器。基本上收集器的职责

61
00:03:14,194 --> 00:03:18,194
是找出客户可能想要的格式及制作那个格式应该执行的操作。

62
00:03:18,198 --> 00:03:21,198
在我们的样例中，

63
00:03:21,201 --> 00:03:24,201
我们将关心两种格式。如果客户想要HTML，

64
00:03:24,204 --> 00:03:27,204
这是一个用户定向请求。这意味着我们必须生成

65
00:03:27,207 --> 00:03:30,207
一个合理的HTML页面呈现给人看。

66
00:03:30,210 --> 00:03:33,210
另一方面，如果客户要求XML，意味着

67
00:03:33,213 --> 00:03:36,213
我们作为面向服务架构中的服务被调用。

68
00:03:36,216 --> 00:03:39,216
我们需要生成的是XML来表示操作的结果。

69
00:03:39,219 --> 00:03:44,219
响应已经在Rails中完成。

70
00:03:44,224 --> 00:03:47,224
路由子系统中的逻辑已经允许你用一行代码

71
00:03:47,227 --> 00:03:50,227
改变你的路由文件，这些动作

72
00:03:50,230 --> 00:03:53,230
应该在面向服务的架构模式下有效。

73
00:03:53,233 --> 00:03:57,233
它们应该是可调用的，当客户想要相同动作的XML版本。

74
00:03:57,237 --> 00:03:59,237
这就是这部分的工作原理。你不必担心这个问题，

75
00:03:59,239 --> 00:04:02,239
它们都会为你设置好。你所要做的是

76
00:04:02,242 --> 00:04:05,242
提供一个模块，指明每个情况的正确做法。

77
00:04:05,245 --> 00:04:08,245
在HTML情况下，和我们之前遇到过的一样。

78
00:04:08,248 --> 00:04:13,248
我们只要重定向到不同的动作。

79
00:04:13,253 --> 00:04:19,253
在XML情况下，我们将返回…返回“:XML”意味着

80
00:04:19,259 --> 00:04:23,259
以这种方式交付输出，在另一端的客户将看到

81
00:04:23,263 --> 00:04:26,263
一个XML编码的文档。我们要返回什么内容？

82
00:04:26,266 --> 00:04:30,266
为方便起见，Rails定义了一个默认值，

83
00:04:30,270 --> 00:04:33,270
或者我该说活动记录，为你定义了一个XML方法的默认值。

84
00:04:33,273 --> 00:04:37,273
它做的最简单的事情就是如果你的模型包含基本的属性类型

85
00:04:37,277 --> 00:04:39,277
如字符串和{端点}，它将正确地转化成XML。

86
00:04:39,279 --> 00:04:42,279
你可以随意覆盖它，

87
00:04:42,282 --> 00:04:45,282
以便自定义字段或做任何你想做的事。在大多数情况下都可以这样做。

88
00:04:45,285 --> 00:04:48,285
如果我在这里为JSON添加第三行，

89
00:04:48,288 --> 00:04:52,288
它也同样可行。还是一样，这里的消息是控制器在做什么。

90
00:04:52,292 --> 00:04:55,292
这是来自外界的第一个联系点。

91
00:04:55,295 --> 00:04:58,295
它可以找出请求来自什么样的实体。

92
00:04:58,298 --> 00:05:00,298
模型是完成工作的真正地点，

93
00:05:00,000 --> 00:05:03,300
一旦工作已经完成，控制器也可以决定最合适的显示方式。

94
00:05:03,303 --> 00:05:06,303
如果你希望它成为你的定制化特殊工具，

95
00:05:06,306 --> 00:05:08,306
用于移动应用之类的，

96
00:05:08,308 --> 00:05:10,308
这是另一个可以让你编辑逻辑的地方，

97
00:05:10,310 --> 00:05:12,310
完全正交而且非常出色。
