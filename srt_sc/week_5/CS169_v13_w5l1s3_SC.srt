1
00:00:00,000 --> 00:00:03,000
所以，我们做到一半了。我们说我们需要两个动作

2
00:00:03,003 --> 00:00:06,003
来处理表单。我们需要服务表单本身。

3
00:00:06,006 --> 00:00:09,006
我们已经看到如何做到这一点。当用户填好后提交表单，

4
00:00:09,009 --> 00:00:11,009
我们还需要得到结果。

5
00:00:11,011 --> 00:00:15,011
这就是我们接下来将要讨论的。

6
00:00:15,015 --> 00:00:18,015
当我们收到表单，我们来花时间做个一举两得的事。

7
00:00:18,018 --> 00:00:21,018
我们将使用调试器检查用户发来的内容。

8
00:00:21,021 --> 00:00:23,021
所以，现在我要打开一个浏览器，

9
00:00:23,023 --> 00:00:26,023
找到我们刚才看到的表单。填好信息，

10
00:00:26,026 --> 00:00:29,026
提交，然后停留在。

11
00:00:29,029 --> 00:00:32,029
接收表单提交的动作，

12
00:00:32,032 --> 00:00:44,032
看看会发生什么事。好的，那么，这里是—我要启动Rails服务器，

13
00:00:44,044 --> 00:00:54,044
同时打开调试。打开Rotten Potatoes主页，

14
00:00:54,054 --> 00:01:02,054
我要添加一部新电影。

15
00:01:02,062 --> 00:01:04,062
顺便说一句，这是一部伟大的电影。现在，在我点击“保存更改”，

16
00:01:04,064 --> 00:01:07,064
实际上就是即将提交表单，我希望你们注意，

17
00:01:07,067 --> 00:01:10,067
在“电影”控制器里，我插入了一个"debugger"语句，

18
00:01:10,070 --> 00:01:13,070
在create动作里。

19
00:01:13,073 --> 00:01:16,073
create动作将会接收表单提交，

20
00:01:16,076 --> 00:01:20,076
因为我们已经看到，基于rake routes命令，

21
00:01:20,080 --> 00:01:23,080
我们能看到该表单的去向。向下滚动屏幕，在这里找到它。

22
00:01:23,083 --> 00:01:25,083
表单在这里。还有很多其他事情

23
00:01:25,085 --> 00:01:28,085
不需要你担心的，但这部分很重要，对吗？

24
00:01:28,088 --> 00:01:32,088
我们现在要用URI的post方法去创建电影，

25
00:01:32,092 --> 00:01:37,092
rake routes命令会告诉我们它要去的地方

26
00:01:37,097 --> 00:01:40,097
就是这里这个创建动作。所以，我们来看看按下按钮会发生什么。

27
00:01:40,100 --> 00:01:45,100
虽然我的浏览器里什么也没有发生，

28
00:01:45,105 --> 00:01:48,105
但在我的终端窗口，你们可以看到，我们已经进入调试器。

29
00:01:48,108 --> 00:01:50,108
所以，如果你以前使用过任何交互式调试器，

30
00:01:50,110 --> 00:01:53,110
这就是我们正要面对的。我真正想看的，

31
00:01:53,113 --> 00:01:57,113
是这个参数散列的情况，对吗？

32
00:01:57,117 --> 00:02:00,117
任何由用户输入或在URI中传入的参数通过params散列表被捕捉，

33
00:02:00,000 --> 00:02:04,120
我们可以在这里看到该散列的值。

34
00:02:04,124 --> 00:02:06,124
在之后的课程中，我们将讨论这个

35
00:02:06,126 --> 00:02:08,126
身份验证令牌。它是防止网站遭受某些恶意攻击的

36
00:02:08,128 --> 00:02:11,128
一种方法。但我们真正感兴趣的

37
00:02:11,131 --> 00:02:16,131
是params[:movie]的值。现在，还记得我提到过的，

38
00:02:16,136 --> 00:02:19,136
我们为什么要将表单元素命名为诸如

39
00:02:19,139 --> 00:02:24,139
“movie[:title]”、“movie[:rating]”之类的名字吗？

40
00:02:24,144 --> 00:02:28,144
原因是，如果你这样做，params[:movie]的值本身就是一个散列。

41
00:02:28,148 --> 00:02:32,148
这样说得通吗？因为我们实际上

42
00:02:32,152 --> 00:02:35,152
正在集合所有名字以params[:movie]开始的表单元素。

43
00:02:35,155 --> 00:02:40,155
它成为散列更为有用的原因是，

44
00:02:40,160 --> 00:02:42,160
还记得，当我们谈论使用Active record

45
00:02:42,162 --> 00:02:46,162
来做创建时，调用create动作的一种方式

46
00:02:46,166 --> 00:02:48,166
是传递一个希望创建的对象的属性的散列。

47
00:02:48,168 --> 00:02:51,168
你瞧，params[:movie]是什么？

48
00:02:51,171 --> 00:02:54,171
它正巧是我们想创建的电影的属性的散列。

49
00:02:54,174 --> 00:02:58,174
所以，这就是Rails视图使用这种工作方式的原因。

50
00:02:58,178 --> 00:03:01,178
那些我们使用的form-tag辅助函数，

51
00:03:01,181 --> 00:03:04,181
让我们不用手动生成每个元素，默认情况下，

52
00:03:04,184 --> 00:03:06,184
它们将生成合适的名字的表单元素。所以，当它们到达你的控制器方法时，

53
00:03:06,186 --> 00:03:09,186
你已经准备好将它移交给create动作。

54
00:03:09,189 --> 00:03:13,189
因此，我们目前到了这部分代码。

55
00:03:13,193 --> 00:03:18,193
当我继续下去，我们将结束这种方法，

56
00:03:18,198 --> 00:03:20,198
这将令我们陷入两难境地，

57
00:03:20,200 --> 00:03:23,200
因为记住，每个控制器动作最终

58
00:03:23,203 --> 00:03:25,203
都必须生成一些东西，按照“惯例胜于配置”原则，

59
00:03:25,205 --> 00:03:28,205
因为我们没有特别指明其他方式，它会寻找一个名为

60
00:03:28,208 --> 00:03:32,208
create.html.haml的视图模板，

61
00:03:32,212 --> 00:03:35,212
而我们目前没有。这个动作没有地方可去。

62
00:03:35,215 --> 00:03:37,215
所以，我要继续吊你们的胃口，不再继续运行调试器。

63
00:03:37,217 --> 00:03:44,217
但是别担心，我们很快就会回到调试器朋友身边。

64
00:03:44,224 --> 00:03:47,224
需要注意的重要的一点是，

65
00:03:47,227 --> 00:03:49,227
由于我们对表单字段的命名方式，

66
00:03:49,229 --> 00:03:52,229
params[:movie]已经是一个散列了。所以很方便地，这正是

67
00:03:52,232 --> 00:03:57,232
Movie.create!函数所需要的参数。所以，现在回到这个问题，

68
00:03:57,237 --> 00:03:59,237
当我们结束控制器方法时会发生什么？

69
00:03:59,239 --> 00:04:02,239
我们将生产一个视图。因此，我们来从用户的角度思考一下。

70
00:04:02,242 --> 00:04:07,242
如果你想得到有关一部电影的信息，

71
00:04:07,247 --> 00:04:08,247
好吧，我们相当清楚

72
00:04:08,248 --> 00:04:10,248
应该生成什么，对吗？这是你所要求的实际信息。

73
00:04:10,250 --> 00:04:14,250
但如果你是想创建一部新电影，

74
00:04:14,254 --> 00:04:16,254
我们应该生成什么来显示

75
00:04:16,256 --> 00:04:19,256
你所做事情的结果才合适呢？我们可能会向你展示一个页面，

76
00:04:19,259 --> 00:04:21,259
上面写着：“感谢你创建一部新电影”，

77
00:04:21,261 --> 00:04:24,261
然后你不得不点击去别的地方，或者，鉴于那几乎没什么用，

78
00:04:24,264 --> 00:04:28,264
你可以说，一旦成功，

79
00:04:28,268 --> 00:04:31,268
我们会将用户重定向至一个更有用的页面。换句话说，

80
00:04:31,271 --> 00:04:33,271
我们将完成这个http请求，我们会创建电影，

81
00:04:33,273 --> 00:04:36,273
但我们会立刻带你去另一个有用的，

82
00:04:36,276 --> 00:04:39,276
且代表合理的用户体验的页面。非常常见的一种选择是，

83
00:04:39,279 --> 00:04:42,279
如果我正在看电影列表，我创建了一部新电影。

84
00:04:42,282 --> 00:04:44,282
如果成功，我将回到电影列表，瞧瞧，

85
00:04:44,284 --> 00:04:47,284
我能看到我刚刚创建的这部电影。所以，

86
00:04:47,287 --> 00:04:52,287
这就是我们将要实现的方式。记住，我们说过

87
00:04:52,292 --> 00:04:55,292
http是无状态的协议。每个请求都是独立的。

88
00:04:55,295 --> 00:04:58,295
我刚刚已经告诉你们，我们可以将用户重定向。这样

89
00:04:58,298 --> 00:05:00,298
将会触发一个全新的http请求，

90
00:05:00,000 --> 00:05:03,300
让我们陷入两难，因为我们希望告诉用户

91
00:05:03,303 --> 00:05:05,303
“创建电影成功。”我们希望给他们一些

92
00:05:05,305 --> 00:05:09,305
对结果的反馈。如果有一个全新的http请求，

93
00:05:09,309 --> 00:05:12,309
这意味着，根据定义，我们不能包含来自前一个请求的实例变量。

94
00:05:12,312 --> 00:05:15,312
那么，我们如何记住

95
00:05:15,315 --> 00:05:18,315
我们需要告诉用户一声？当然，

96
00:05:18,318 --> 00:05:21,318
因为这是SaaS应用程序中的一个常见问题，

97
00:05:21,321 --> 00:05:24,321
Rails有一个办法解决，称为flash。它看起来像一个散列。

98
00:05:24,324 --> 00:05:27,324
这意味着你可以指望它做所有普通散列会做的事。

99
00:05:27,327 --> 00:05:30,327
但是，它的特殊之处在于，

100
00:05:30,330 --> 00:05:33,330
它会一直持续到下一个请求结束，而不仅是这个请求。

101
00:05:33,333 --> 00:05:36,333
因此，如果我完成这个请求，在我完成之前，

102
00:05:36,336 --> 00:05:40,336
我在flash里放点东西。在下一个请求时，

103
00:05:40,340 --> 00:05:42,340
我就可以在flash中寻找并获取那一段信息，

104
00:05:42,342 --> 00:05:44,342
在那之后它将被自动清除。

105
00:05:44,344 --> 00:05:48,344
根据惯例，通常我们用flash[:notice]来表示提示信息，

106
00:05:48,348 --> 00:05:50,348
用flash[:warning]来表示错误消息，但这只是惯例而已。

107
00:05:50,350 --> 00:05:56,350
所以，把这些组合在一起，

108
00:05:56,356 --> 00:06:00,356
我们想放进去的内容可能是这样的。请注意，

109
00:06:00,000 --> 00:06:03,360
我正在使用危险版本的创建。我衷心祈祷不要出错。

110
00:06:03,363 --> 00:06:05,363
用在课程例子里没关系

111
00:06:05,365 --> 00:06:08,365
用在应用程序里就不太好了。用于开发没关系。

112
00:06:08,368 --> 00:06:10,368
不要在现实生产中使用。

113
00:06:10,370 --> 00:06:13,370
但是我把一条可爱的小消息填进去，然后必须重定向到某个地方。

114
00:06:13,373 --> 00:06:18,373
我可以重定向到哪里？重定向是一个全新的动作，对吗？

115
00:06:18,378 --> 00:06:21,378
所以，让我们只将用户发送回

116
00:06:21,381 --> 00:06:26,381
显示所有电影列表的页面。这点太容易了，

117
00:06:26,386 --> 00:06:30,386
我有URI辅助函数来帮助我做到。好了，现在我要继续，

118
00:06:30,390 --> 00:06:35,390
我会得到一个错误信息吗？为什么，

119
00:06:35,395 --> 00:06:39,395
是的，因为在我改变应用程序时，

120
00:06:39,399 --> 00:06:41,399
我们已经掉入有调试器的那个方法。

121
00:06:41,401 --> 00:06:43,401
但是请放心，如果我们重复做这个—顺便一提，这个错误我们早就想到了，对吗？

122
00:06:43,403 --> 00:06:47,403
默认情况下，创建将结束创建动作，

123
00:06:47,407 --> 00:06:48,407
并去寻找一个名为create的模板，

124
00:06:48,408 --> 00:06:51,408
肯定的，它找遍了所有能找的地方，

125
00:06:51,411 --> 00:06:53,411
包括沙发底下，也找不到，

126
00:06:53,413 --> 00:06:56,413
所以我们得到了错误信息。但是请放心，

127
00:06:56,416 --> 00:07:06,416
如果我们再次这样做—添加新电影，我不知道这部电影什么时候上映。

128
00:07:06,426 --> 00:07:12,426
我们仍然在调试器里。那里。但这次，

129
00:07:12,432 --> 00:07:17,432
没有错误信息，因为我们添加了—我们添加了什么？

130
00:07:17,437 --> 00:07:20,437
我们添加了这个flash消息，由我的模板输出的，

131
00:07:20,440 --> 00:07:23,440
而且我们添加了一个重定向，将我们带回到电影列表。

132
00:07:23,443 --> 00:07:26,443
这是一个非常标准的习语。当你执行

133
00:07:26,446 --> 00:07:29,446
最终将导致数据库变更的操作时，

134
00:07:29,449 --> 00:07:31,449
我们不要显示一个被动的页面，它唯一的人生目标就是说，

135
00:07:31,451 --> 00:07:35,451
“变更成功”。而是通常认可一条消息，

136
00:07:35,455 --> 00:07:37,455
比如flash中的消息，然后将用户发送回一个更有用的页面。

137
00:07:37,457 --> 00:07:43,457
所以，我们谈到了flash。

138
00:07:43,463 --> 00:07:47,463
flash事实上是一种更通用机制的一个特例。

139
00:07:47,467 --> 00:07:50,467
在这个案例中，session机制，请把它想成一个散列，

140
00:07:50,470 --> 00:07:52,470
或多或少永远存在的散列。现在，围绕“永远”有很多限定符，

141
00:07:52,472 --> 00:07:54,472
但基本上，如果我为这个用户在session中放点东西，

142
00:07:54,474 --> 00:07:57,474
我也能够为这个用户将该信息取出来，

143
00:07:57,477 --> 00:08:00,477
在与应用程序持续交互的整个期间都可以做到。

144
00:08:00,000 --> 00:08:03,480
我可以重置session或取消整个过程。

145
00:08:03,483 --> 00:08:06,483
我可以删除我放在session中的具体内容，

146
00:08:06,486 --> 00:08:10,486
默认情况下，cookie将存储session和flash中的全部内容。

147
00:08:10,490 --> 00:08:12,490
现在，有一件很重要的事情需要了解，

148
00:08:12,492 --> 00:08:15,492
因为cookie的大小实际上是有限制的，对吗？

149
00:08:15,495 --> 00:08:17,495
记住，cookie是http协议规范的一部分。

150
00:08:17,497 --> 00:08:20,497
因此，如果一个cookie被规定

151
00:08:20,500 --> 00:08:24,500
只能包含特定长度的字符，而session就像其他任何Ruby散列一样，

152
00:08:24,504 --> 00:08:26,504
你可以将任意大小的东西放进去。

153
00:08:26,506 --> 00:08:29,506
你可以看到，这是一起即将发生的事故,

154
00:08:29,509 --> 00:08:31,509
对吗？我一直说，所有这些框架都在尝试提供抽象概念来帮助你，

155
00:08:31,511 --> 00:08:34,511
但这些抽象概念是有漏洞的。

156
00:08:34,514 --> 00:08:37,514
它们并非完美，这是抽象概念有漏洞的另一个例子。

157
00:08:37,517 --> 00:08:39,517
session看起来就像一个永远可用的

158
00:08:39,519 --> 00:08:42,519
持续散列。但如果你

159
00:08:42,522 --> 00:08:45,522
将大到无法反序列化的内容放入session，

160
00:08:45,525 --> 00:08:48,525
就可能会出现问题，内容溢出cookie。

161
00:08:48,528 --> 00:08:50,528
现在，你可以将session存储在数据库中。

162
00:08:50,530 --> 00:08:53,530
我们有的办法可以做到。如果你已经忘记如何使用谷歌，

163
00:08:53,533 --> 00:08:56,533
从句子中挑出重要的词语键入谷歌。

164
00:08:56,536 --> 00:09:00,536
有些人使用很大很大的系统，

165
00:09:00,000 --> 00:09:02,540
session太多以致使用NoSQL系统来存储会话，比如Memcached。

166
00:09:02,542 --> 00:09:06,542
但实际上，你要自问的是，

167
00:09:06,546 --> 00:09:09,546
你为什么要把复杂的内容放在session里？

168
00:09:09,549 --> 00:09:11,549
如果你将对象ID以外的内容放进session，

169
00:09:11,551 --> 00:09:14,551
你需要问自己，你的应用程序为什么没有达到REST的要求。

170
00:09:14,554 --> 00:09:15,554
因为如果你将它们放进session里，

171
00:09:15,555 --> 00:09:18,555
那必定意味着你在某种程度上依赖它

172
00:09:18,558 --> 00:09:21,558
从一个操作执行到另一个操作，

173
00:09:21,561 --> 00:09:24,561
不利于制作REST风格应用程序。

