1
00:00:00,000 --> 00:00:03,000
好，我们都知道下一步我们该做什么了。

2
00:00:03,003 --> 00:00:05,003
是的，我们需要实现一个控制器方法，

3
00:00:05,005 --> 00:00:09,005
这个方法是用户输入最先触及的方法。

4
00:00:09,009 --> 00:00:11,009
下面我们开始写代码，这给了我们一个

5
00:00:11,011 --> 00:00:15,011
体会大家写作业过程的机会，

6
00:00:15,015 --> 00:00:18,015
一般会经历一个“红”，“绿”和“重构”这样状态的循环。

7
00:00:18,018 --> 00:00:20,018
这是基本的方法，我们来讨论一下这段代码需要实现什么功能。

8
00:00:20,020 --> 00:00:23,020
事实上，在最后这里，

9
00:00:23,023 --> 00:00:26,023
我们看到这段代码应该实现三个功能。

10
00:00:26,026 --> 00:00:29,026
我们想要用一个测试用例去描述这些功能，这个测试不会通过

11
00:00:29,029 --> 00:00:31,029
因为我们现在还没有代码，然后我们会写一段我们能想到的

12
00:00:31,031 --> 00:00:34,031
最简单的代码，来使得这些测试通过。

13
00:00:34,034 --> 00:00:37,034
在进行下一步之前，我们先要来看看

14
00:00:37,037 --> 00:00:40,037
是否能简化或重构或美化一下

15
00:00:40,040 --> 00:00:42,040
我们的代码。

16
00:00:42,042 --> 00:00:46,042
这门课后续我们还会有专门讨论代码重构的内容，

17
00:00:46,046 --> 00:00:48,046
但其实我们一直都会做代码重构。

18
00:00:48,048 --> 00:00:51,048
我们应该抓住每一个机会来美化代码。

19
00:00:51,051 --> 00:00:54,051
我们之前提到了一个状态的循环，这三种状态分别是：红，绿，重构。

20
00:00:54,054 --> 00:00:57,054
红代表代码没有通过测试。绿代表代码通过了测试。

21
00:00:57,057 --> 00:01:00,057
重构代表代码通过了所有测试后我们还会进行代码完善，

22
00:01:00,000 --> 00:01:03,060
使其有一个更好的代码质量和结构。这个过程将

23
00:01:03,063 --> 00:01:05,063
一直持续到所有测试通过。我们的目标就是

24
00:01:05,065 --> 00:01:08,065
随时都有能够运行的代码。当你写一个新测试的时候，

25
00:01:08,068 --> 00:01:11,068
这个测试起初不会通过。我们希望避免像这样的不稳定状态。

26
00:01:11,071 --> 00:01:14,071
我们希望一直能够在“绿”的状态

27
00:01:14,074 --> 00:01:17,074
这也是为什么需要一段不论风格和质量的简单代码，

28
00:01:17,077 --> 00:01:20,077
我们至少保证需求的功能都会实现。事实上，我们会有其他机会

29
00:01:20,080 --> 00:01:23,080
进行代码优化和代码重构，但其实最重要的事还是

30
00:01:23,083 --> 00:01:27,083
保证需求功能的实现。如果代码能实现功能，

31
00:01:27,087 --> 00:01:32,087
那就不要去修改它。问题是，如果我们要做单元测试，

32
00:01:32,092 --> 00:01:34,092
那么我们就要单独测试每一部分。对吧？

33
00:01:34,094 --> 00:01:37,094
我们知道测试的层级是

34
00:01:37,097 --> 00:01:40,097
从一个方法或一个类开始，一直到

35
00:01:40,100 --> 00:01:43,100
测试集成的系统，通过这个过程我们能够测试几乎全部的代码。

36
00:01:43,103 --> 00:01:46,103
所以下面我们要讨论的一个基本问题就是，

37
00:01:46,106 --> 00:01:49,106
如何能够将某一部分独立出来进行测试。鉴于几乎所有的代码

38
00:01:49,109 --> 00:01:52,109
都会和其他的部分有联系，这些联系

39
00:01:52,112 --> 00:01:59,112
将会影响你的测试。所以这里有一个强大的工具，

40
00:01:59,119 --> 00:02:01,119
那就假想你“期望的代码”。

41
00:02:01,121 --> 00:02:04,121
或许也是我们希望有的代码。开个玩笑。

42
00:02:04,124 --> 00:02:06,124
我们刚才提到“控制器方法接收到提交的搜索请求后应该做什么呢？”

43
00:02:06,126 --> 00:02:08,126
让我们从这个问题开始一点一点探索。

44
00:02:08,128 --> 00:02:10,128
这个问题的答案就是控制器应该调用一个方法，

45
00:02:10,130 --> 00:02:13,130
这个方法可以通过TMDb搜索具体的某一部电影。

46
00:02:13,133 --> 00:02:15,133
现在我们还不知道被调用的这个方法大致是什么样的，

47
00:02:15,135 --> 00:02:18,135
事实上，根据自测题的答案，

48
00:02:18,138 --> 00:02:20,138
我们只知道这个方法

49
00:02:20,140 --> 00:02:23,140
一定会被定义在模型中。所以

50
00:02:23,143 --> 00:02:26,143
控制器需要做的唯一的一件事，就是直接把这部分传递给对应的模型。

51
00:02:26,146 --> 00:02:29,146
对吧？我们需要保证的就是不管用户输入什么样的数据，

52
00:02:29,149 --> 00:02:31,149
控制器最终都会接收到这些数据，

53
00:02:31,151 --> 00:02:35,151
然后通过某些方式成功地将这些输入

54
00:02:35,155 --> 00:02:37,155
传递给实现真正功能的模型。是这样吗？

55
00:02:37,157 --> 00:02:41,157
我想我们在上一个选项中得出了这个结论。

56
00:02:41,161 --> 00:02:44,161
所以现在的问题就是，我们该怎么样独立测试代码

57
00:02:44,164 --> 00:02:47,164
如果一些控制器的方法确实和模型中

58
00:02:47,167 --> 00:02:50,167
我们还没有测试的部分相关。所以

59
00:02:50,170 --> 00:02:53,170
这就是“希望的代码”的强大力量所被需要的地方。

60
00:02:53,173 --> 00:02:56,173
首先我们需要在config/routes.rb文件中添加一个路由

61
00:02:56,176 --> 00:02:59,176
这很简单，我们可以写一条简单的指令，

62
00:02:59,179 --> 00:03:02,179
向search_tmdb提交一个表格

63
00:03:02,182 --> 00:03:04,182
其次，由于惯例胜于配置，

64
00:03:04,184 --> 00:03:07,184
Rails会将这个路由与Movie控制器中

65
00:03:07,187 --> 00:03:10,187
叫做search_tmdb的方法联系起来，这很好。

66
00:03:10,190 --> 00:03:13,190
这是Rails的方便之处。另外，

67
00:03:13,193 --> 00:03:15,193
因为最终一定要生成一个视图，所以我们暂时渲染了一个

68
00:03:15,195 --> 00:03:18,195
空的视图。这完全可以，虽然目前没有什么效果，但已经可以让我们通过测试。

69
00:03:18,198 --> 00:03:21,198
我们刚刚在合适的地方、以合适的名称

70
00:03:21,201 --> 00:03:23,201
创建了一个空的Haml文件。是吗？

71
00:03:23,203 --> 00:03:26,203
这只是最基础的框架，让我们不会在开始测试时崩溃。

72
00:03:26,206 --> 00:03:29,206
现在，我们要开始写里面的内容了。

73
00:03:29,209 --> 00:03:32,209
我们来看看Dave在他的例子中写的“hardwired”方法，

74
00:03:32,212 --> 00:03:34,212
我们用一个空的方法来替换掉他。

75
00:03:34,214 --> 00:03:38,214
好的，我们一点一点慢慢来。

76
00:03:38,218 --> 00:03:44,218
现在这个方法一定是会失效的。

77
00:03:44,224 --> 00:03:47,224
我们刚才提到，控制器会传递一些数据到模型，

78
00:03:47,227 --> 00:03:49,227
然后模型中会有一些方法对数据进行操作和处理。

79
00:03:49,229 --> 00:03:52,229
这些方法是什么呢？我们还没有实现这些方法。

80
00:03:52,232 --> 00:03:55,232
因此，如果控制器需要调用一些还不存在的方法，

81
00:03:55,235 --> 00:03:58,235
我们该怎样测试控制器呢？

82
00:03:58,238 --> 00:04:03,238
现在就是最神奇的部分。解决这个问题的方法就是：

83
00:04:03,243 --> 00:04:07,243
“让我们先假设我们已经实现了控制器要调用那部分的代码”

84
00:04:07,247 --> 00:04:11,247
也就是说，我们知道那部分代码还不存在，

85
00:04:11,251 --> 00:04:15,251
但我们假设他已经存在。然后怎么做？

86
00:04:15,255 --> 00:04:18,255
之后，我们会添加一个接缝（seam）。Seam是一个非常重要的概念。

87
00:04:18,258 --> 00:04:21,258
Seam可以让你无需做任何修改

88
00:04:21,261 --> 00:04:23,261
就可以达到改动程序行为的目的。我们之后还会单独再来谈论seam。

89
00:04:23,263 --> 00:04:26,263
现在让我们来先加入一个seam，

90
00:04:26,266 --> 00:04:29,266
然后让我们来测一下我们假设已经存在的代码

91
00:04:29,269 --> 00:04:31,269
好，这里就是假设我们有的代码。

92
00:04:31,271 --> 00:04:35,271
我们知道这里会是一个Movie的类方法。

93
00:04:35,275 --> 00:04:36,275
所以我假定这里会有一个叫“find_in_tmbd”的Movie类方法，

94
00:04:36,276 --> 00:04:40,276
他会接收到一些参数

95
00:04:40,280 --> 00:04:42,280
然后查询TMDB的数据库。

96
00:04:42,282 --> 00:04:45,282
我们需要这么做：

97
00:04:45,285 --> 00:04:48,285
我们要在测试中模拟当用户提交搜索表格后会发生什么。

98
00:04:48,288 --> 00:04:51,288
我们会检查控制器什么时候

99
00:04:51,291 --> 00:04:56,291
会调用find_in_tmbd的方法，

100
00:04:56,296 --> 00:04:58,296
并检查控制器是否正确从传递的表格中

101
00:04:58,298 --> 00:05:00,298
提取出参数。这些都是实际操作中非常重要的，

102
00:05:00,000 --> 00:05:04,300
对吧？我们并没有测试find_in_tmdb这个方法，

103
00:05:04,304 --> 00:05:07,304
我们也没有直接连接到数据库。

104
00:05:07,307 --> 00:05:09,307
我们唯一做的就是测试控制器，

105
00:05:09,309 --> 00:05:13,309
这部分并没有涉及到模型的内容。

106
00:05:13,313 --> 00:05:16,313
当然，如果控制器方法是空的话，测试是不会通过的。

107
00:05:16,316 --> 00:05:19,316
之后我们再回过头来实现控制器的方法

108
00:05:19,319 --> 00:05:22,319
使他能通过测试。我们可以在完全

109
00:05:22,322 --> 00:05:25,322
不实现模型方法的情况下来测试控制器。因此，我们该如何做呢

110
00:05:25,325 --> 00:05:31,325
让我们来看看，这里有一个控制器的说明

111
00:05:31,331 --> 00:05:34,331
我们有一个描述的部分，

112
00:05:34,334 --> 00:05:37,334
在这里我们可以描述整个类需要实现的功能。

113
00:05:37,337 --> 00:05:39,337
之后在这个描述部分中，我们可以嵌套

114
00:05:39,339 --> 00:05:43,339
这个类中不同功能的描述部分。

115
00:05:43,343 --> 00:05:47,343
我们这里有一个测试用例，

116
00:05:47,347 --> 00:05:50,347
控制器应该调用模型中的搜索方法。

117
00:05:50,350 --> 00:05:53,350
首先我们要确定我们期望实现的功能

118
00:05:53,353 --> 00:05:57,353
这个Movie类应该收到控制器发出的

119
00:05:57,357 --> 00:06:01,357
以电影名字为参数的find_in_tmdb调用。还记得么？

120
00:06:01,361 --> 00:06:03,361
我们将模拟用户提交带有数据的表格。

121
00:06:03,363 --> 00:06:06,363
之后需要确认控制器能够正确得到这些数据

122
00:06:06,366 --> 00:06:10,366
并把其传递出去。现在我们来模拟这个提交过程

123
00:06:10,370 --> 00:06:13,370
Post方法是Rails为specs内嵌的方法之一，

124
00:06:13,373 --> 00:06:16,373
所以我们很方便就能

125
00:06:16,376 --> 00:06:18,376
模拟一个与控制器相关的模型。所以Post

126
00:06:18,378 --> 00:06:21,378
表示……我们现在是在测试哪个控制器？

127
00:06:21,381 --> 00:06:26,381
对，是电影的控制器。所以对于这个控制器来说，

128
00:06:26,386 --> 00:06:28,386
用户提交表格之后他就可以查询routes.rb

129
00:06:28,388 --> 00:06:32,388
并将数据传递出去。

130
00:06:32,392 --> 00:06:35,392
所以，这个地方是我们必须要注意的，

131
00:06:35,395 --> 00:06:37,395
我们必须知道控制器

132
00:06:37,397 --> 00:06:41,397
接受提交的表格后传递出的数据是什么样的。

133
00:06:41,401 --> 00:06:44,401
有很多方式能够实现它。

134
00:06:44,404 --> 00:06:46,404
我这里说一种，你可以在代码中加入一条debugger指令。

135
00:06:46,406 --> 00:06:49,406
当代码运行到这里的时候

136
00:06:49,409 --> 00:06:51,409
看一下表格实际如何变化的。其他方法也可以。

137
00:06:51,411 --> 00:06:54,411
好的，我们现在该做什么呢？

138
00:06:54,414 --> 00:06:56,414
我们的两个步骤就是，首先我们需要设立一个期望，

139
00:06:56,416 --> 00:07:01,416
期望这段代码会实现什么功能。之后，我们要执行代码，

140
00:07:01,421 --> 00:07:07,421
看我们期望的是否会发生。为什么这样的方式可行呢？

141
00:07:07,427 --> 00:07:10,427
这里有一个练习题

142
00:07:10,430 --> 00:07:13,430
让我来看看在我带大家整体梳理一遍之前大家掌握了多少。

143
00:07:13,433 --> 00:07:18,433
大家直接凭感觉回答就好。

144
00:07:18,438 --> 00:07:22,438
Should_receive是一个之前涉及到的一个方法，

145
00:07:22,442 --> 00:07:25,442
我们来看看下面这道关于should_receive的题。

146
00:07:25,445 --> 00:07:28,445
下列关于should_receive的描述中，哪一项是错误的呢？

147
00:07:28,448 --> 00:07:32,448
选项一，实际的方法并没有实现，

148
00:07:32,452 --> 00:07:35,452
我们创建的should_receive方法替代了实际的方法。

149
00:07:35,455 --> 00:07:38,455
选项二，即使我们已经实现了实际的方法，

150
00:07:38,458 --> 00:07:42,458
为了这个测试我们也需要创建一个should_receive方法覆盖之前的方法。

151
00:07:42,462 --> 00:07:46,462
第三个描述是，should_receive

152
00:07:46,466 --> 00:07:50,466
在调用它的代码之前或之后出现都没问题。

153
00:07:50,470 --> 00:07:54,470
第四个描述是，我们需要利用

154
00:07:54,474 --> 00:07:56,474
Ruby中的开放类和元编程来

155
00:07:56,476 --> 00:08:00,476
实现should_receive这个seam，来创建一个

156
00:08:00,000 --> 00:08:03,480
可以改变和监控程序运行，而不需要

157
00:08:03,483 --> 00:08:06,483
实际改变程序代码的地方。

158
00:08:06,486 --> 00:08:09,486
四个之中有一个描述一定是错的

159
00:08:09,489 --> 00:08:11,489
这不是一道很难的题。

