1
00:00:00,000 --> 00:00:03,000
好，我们都知道下一步我们该做什么了。

2
00:00:03,003 --> 00:00:05,003
是的，我们需要实现一个控制器方法，这个方法是用户进行输入的第一个地方。

3
00:00:05,005 --> 00:00:09,005
下面我们开始写代码，大家可以体会一下，

4
00:00:09,009 --> 00:00:11,009
这个过程就像大家写作业的过程一样，一般会经历一个“红”，“绿”和“重构”这样状态的循环。

5
00:00:11,011 --> 00:00:15,011


6
00:00:15,015 --> 00:00:18,015
我们先来讨论一下这段代码需要实现什么功能。

7
00:00:18,018 --> 00:00:20,018


8
00:00:20,020 --> 00:00:23,020
在最后这里，我们看到这段代码应该实现三个功能。

9
00:00:23,023 --> 00:00:26,023


10
00:00:26,026 --> 00:00:29,026
我们想要用一个测试用例去验证一下这些功能，但我们现在还完成代码，所以我们首先需要写一段能实现这些最基本功能的代码。

11
00:00:29,029 --> 00:00:31,029


12
00:00:31,031 --> 00:00:34,031


13
00:00:34,034 --> 00:00:37,034
在进行下一步之前，我们先要来看看是否能重构或美化一下我们的代码。

14
00:00:37,037 --> 00:00:40,037


15
00:00:40,040 --> 00:00:42,040
这门课后续我们还会有专门讨论代码重构的内容，但其实我们一直都会做代码重构。

16
00:00:42,042 --> 00:00:46,042


17
00:00:46,046 --> 00:00:48,046


18
00:00:48,048 --> 00:00:51,048
我们应该抓住每一个机会来美化代码。

19
00:00:51,051 --> 00:00:54,051
我们之前提到了一个状态的循环，这三种状态分别是：红，绿，重构。

20
00:00:54,054 --> 00:00:57,054
红代表代码没有通过测试。绿代表代码通过了测试。

21
00:00:57,057 --> 00:01:00,057
重构代表代码通过了所有测试后我们还会进行代码完善，使其有一个更好的代码质量和结构

22
00:01:00,000 --> 00:01:03,060


23
00:01:03,063 --> 00:01:05,063
我们的目标就是让代码正常的运行并顺利通过测试。

24
00:01:05,065 --> 00:01:08,065
我们都非常希望避免这样一个不稳定的状态，那就是不论何时我们添加了一个新的测试用例，测试都不能通过。

25
00:01:08,068 --> 00:01:11,068


26
00:01:11,071 --> 00:01:14,071
我们希望不论怎么添加测试用例，我们都一直能够在“绿”的状态

27
00:01:14,074 --> 00:01:17,074
这也是为什么一份代码不论风格和质量如何，首先我们至少保证需求的功能都会实现。

28
00:01:17,077 --> 00:01:20,077
事实上，我们会有很多机会进行代码优化和代码重构，但其实最重要的事还是保证需求功能的实现。

29
00:01:20,080 --> 00:01:23,080


30
00:01:23,083 --> 00:01:27,083
如果代码能实现功能，那就不要去修改它

31
00:01:27,087 --> 00:01:32,087
现在问题就来了，如果我们要做单元测试，那么我们就要单独测试每一部分。对吧？

32
00:01:32,092 --> 00:01:34,092


33
00:01:34,094 --> 00:01:37,094
我们知道直到我们可以从测试一个方法或一个类开始，之后慢慢到测试集成的系统，通过这个过程我们能够测试几乎全部的代码。

34
00:01:37,097 --> 00:01:40,097


35
00:01:40,100 --> 00:01:43,100


36
00:01:43,103 --> 00:01:46,103
所以下面我们首先要讨论的一个基本问题就是，如何能够将某一部分独立出来进行测试。

37
00:01:46,106 --> 00:01:49,106
鉴于几乎所有的代码都不是完全独立的部分，都会和其他的部分有联系，

38
00:01:49,109 --> 00:01:52,109
所以想要进行单元测试，我们这里有一个特别的办法，那就想象一下你“希望你有的代码”。

39
00:01:52,112 --> 00:01:59,112


40
00:01:59,119 --> 00:02:01,119
或许也是我们希望有的代码。

41
00:02:01,121 --> 00:02:04,121
开个玩笑。我们刚才提到“控制器方法接收到提交的搜索请求后应该做什么呢？”

42
00:02:04,124 --> 00:02:06,124


43
00:02:06,126 --> 00:02:08,126
让我们从这个问题开始一点一点探索。

44
00:02:08,128 --> 00:02:10,128
这个问题的答案就是控制器应该会调用一个方法，这个方法可以通过TMDb搜索具体的某一部电影。

45
00:02:10,130 --> 00:02:13,130


46
00:02:13,133 --> 00:02:15,133
现在我们还不知道他调用的这个方法大致是什么样的，

47
00:02:15,135 --> 00:02:18,135
我们只知道模型中以后一定会有这个方法。

48
00:02:18,138 --> 00:02:20,138


49
00:02:20,140 --> 00:02:23,140


50
00:02:23,143 --> 00:02:26,143
所以控制器需要做的唯一的一件事，就是直接把这部分传递给对应的模型。对吧？

51
00:02:26,146 --> 00:02:29,146
我们需要保证的就是不管用户输入什么样的数据，控制器最终都会接收到这些数据，并将他们传递给正确的模型。

52
00:02:29,149 --> 00:02:31,149


53
00:02:31,151 --> 00:02:35,151


54
00:02:35,155 --> 00:02:37,155


55
00:02:37,157 --> 00:02:41,157
我们在上一个选项中就得出了这个结论。

56
00:02:41,161 --> 00:02:44,161
所以现在的问题就是，如果一些控制器的方法确实和模型中我们还没有测试的部分相关，我们该怎么样独立出控制器的这些方法从而进行测试呢？

57
00:02:44,164 --> 00:02:47,164


58
00:02:47,167 --> 00:02:50,167
我们先来想想控制器都要事先什么功能。

59
00:02:50,170 --> 00:02:53,170


60
00:02:53,173 --> 00:02:56,173
首先我们需要写一条指令来配置routes.rb

61
00:02:56,176 --> 00:02:59,176
这很简单，我们可以写一条简单的指令，向search_tmdb请求一个表格

62
00:02:59,179 --> 00:03:02,179


63
00:03:02,182 --> 00:03:04,182
其次，我们知道他一定会调用电影控制器中的search_tmdb，

64
00:03:04,184 --> 00:03:07,184


65
00:03:07,187 --> 00:03:10,187


66
00:03:10,190 --> 00:03:13,190
另外，因为最终一定会生成一个视图，所以我们暂时渲染了一个空的视图。

67
00:03:13,193 --> 00:03:15,193


68
00:03:15,195 --> 00:03:18,195
虽然目前没有什么效果，但已经可以让我们通过测试。

69
00:03:18,198 --> 00:03:21,198
我们刚刚在合适的地方创建了一个空的Haml文件。

70
00:03:21,201 --> 00:03:23,201


71
00:03:23,203 --> 00:03:26,203
这就是最基础的框架。

72
00:03:26,206 --> 00:03:29,206
现在，我们要开始写里面的内容了。

73
00:03:29,209 --> 00:03:32,209
我们来看看Dave在他的例子中写的“hardwired”方法，我们用一个空的方法来替换掉他。

74
00:03:32,212 --> 00:03:34,212


75
00:03:34,214 --> 00:03:38,214
我们一点一点慢慢来。

76
00:03:38,218 --> 00:03:44,218
现在这个方法以后一定是会失效的。为什么呢？

77
00:03:44,224 --> 00:03:47,224
我们刚才提到，控制器会传递一些数据到模型，然后模型中会有一些方法对数据进行操作和处理。

78
00:03:47,227 --> 00:03:49,227
这些方法是什么呢？

79
00:03:49,229 --> 00:03:52,229
我们还没有实现这些方法。

80
00:03:52,232 --> 00:03:55,232
因此，如果控制器需要调用一些还不存在的方法，我们该怎样测试控制器呢？

81
00:03:55,235 --> 00:03:58,235


82
00:03:58,238 --> 00:04:03,238
现在就是最神奇的部分。解决这个问题的方法就是：

83
00:04:03,243 --> 00:04:07,243
“让我们先假设我们已经实现了控制器要调用那部分的代码”

84
00:04:07,247 --> 00:04:11,247
也就是说，我们知道那部分代码还不存在，但我们假设他已经存在。

85
00:04:11,251 --> 00:04:15,251


86
00:04:15,255 --> 00:04:18,255
之后，我们会添加一个接缝（seam）。Seam是一个非常重要的概念。

87
00:04:18,258 --> 00:04:21,258
他是一些特殊的点，在这些点上你无需做任何修改就可以达到改动程序行为的目的

88
00:04:21,261 --> 00:04:23,261
我们之后还会单独再来谈论seam。

89
00:04:23,263 --> 00:04:26,263
现在让我们来先加入一个seam。然后让我们来测一下我们假设已经存在的代码

90
00:04:26,266 --> 00:04:29,266


91
00:04:29,269 --> 00:04:31,269
好，这里就是就假设我们有的代码。

92
00:04:31,271 --> 00:04:35,271
我们知道这里会是一个电影的类。

93
00:04:35,275 --> 00:04:36,275
所以我假定这里会有一个叫“find_in_tmbd”的方法，他会接收到一些参数然后查询TMDB的数据库。

94
00:04:36,276 --> 00:04:40,276


95
00:04:40,280 --> 00:04:42,280


96
00:04:42,282 --> 00:04:45,282
我们需要这么做：

97
00:04:45,285 --> 00:04:48,285
我们要在测试中模拟当用户提交搜索表格后会发生什么。

98
00:04:48,288 --> 00:04:51,288
我们会检查控制器什么时候会调用find_in_tmbd的方法，并检查控制器传递的参数是否正确。

99
00:04:51,291 --> 00:04:56,291


100
00:04:56,296 --> 00:04:58,296


101
00:04:58,298 --> 00:05:00,298
这些都是实际操作中非常重要的，对吧？

102
00:05:00,000 --> 00:05:04,300
我们并没有测试调用find_in_tmdb这个方法，

103
00:05:04,304 --> 00:05:07,304
我们也没有直接连接到数据库。

104
00:05:07,307 --> 00:05:09,307
我们唯一做的就是测试控制器单独的部分，这部分并没有涉及到实际模型的内容。

105
00:05:09,309 --> 00:05:13,309


106
00:05:13,313 --> 00:05:16,313
当然，如果控制器方法是空的话，测试是不会通过的。

107
00:05:16,316 --> 00:05:19,316
之后我们再回过头来实现一下控制器的方法使他能通过测试。

108
00:05:19,319 --> 00:05:22,319
最重要的一点我希望大家了解的就是，我们可以在完全不实现模型方法的情况下来测试控制器

109
00:05:22,322 --> 00:05:25,322
因此，我们该如何做呢

110
00:05:25,325 --> 00:05:31,325
让我们来看看，这里有一个控制器的说明

111
00:05:31,331 --> 00:05:34,331
我们有一个描述的部分，在这里我们可以记录这个整个类需要实现的功能。

112
00:05:34,334 --> 00:05:37,334


113
00:05:37,337 --> 00:05:39,337
之后在这个描述部分中，我们可以嵌套其他功能相关的描述部分。

114
00:05:39,339 --> 00:05:43,339


115
00:05:43,343 --> 00:05:47,343
我们这里有一个测试用例，控制器应该调用模型中的搜索方法。

116
00:05:47,347 --> 00:05:50,347


117
00:05:50,350 --> 00:05:53,350
首先我们要确定我们期望他实现的功能

118
00:05:53,353 --> 00:05:57,353
这个电影的类应该收到控制器发出的带有电影名字作为参数的调用find_in_tmdb的申请

119
00:05:57,357 --> 00:06:01,357
还记得么？我们模拟的是用户会提交带有数据的表格

120
00:06:01,361 --> 00:06:03,361
之后需要确认控制器能够正确得到这些数据并把其传递出去

121
00:06:03,363 --> 00:06:06,363


122
00:06:06,366 --> 00:06:10,366
现在我们来模拟这个提交过程

123
00:06:10,370 --> 00:06:13,370
提交的方法是已经内置的

124
00:06:13,373 --> 00:06:16,373


125
00:06:16,376 --> 00:06:18,376
所以我们很方便就能模拟。

126
00:06:18,378 --> 00:06:21,378
我们现在是在测试哪个控制器？

127
00:06:21,381 --> 00:06:26,381
对，是电影的控制器。

128
00:06:26,386 --> 00:06:28,386
所以对于这个控制器来说，用户提交表格之后他就可以查询routes.rb并将数据传递出去。

129
00:06:28,388 --> 00:06:32,388


130
00:06:32,392 --> 00:06:35,392
所以，这个地方是我们必须要注意的，我们必须知道控制器接受提交的表格后传递出的数据是什么样的。

131
00:06:35,395 --> 00:06:37,395


132
00:06:37,397 --> 00:06:41,397


133
00:06:41,401 --> 00:06:44,401
有很多方式能够实现它。

134
00:06:44,404 --> 00:06:46,404
我这里说一种，你可以在代码中加入一条调试指令。

135
00:06:46,406 --> 00:06:49,406
当代码运行到这里的时候看一下表格实际如何变化的。

136
00:06:49,409 --> 00:06:51,409
除了这个方法以外，其他方法也都是可以的。

137
00:06:51,411 --> 00:06:54,411
我们现在该做什么呢？

138
00:06:54,414 --> 00:06:56,414
我们的两个步骤就是，首先我们需要设立一个期望，期望这段代码会实现什么功能。

139
00:06:56,416 --> 00:07:01,416
之后，我们要执行代码，看我们期望的是否会发生

140
00:07:01,421 --> 00:07:07,421
为什么这样的方式可行呢？

141
00:07:07,427 --> 00:07:10,427
这里有一个练习题

142
00:07:10,430 --> 00:07:13,430
让我来看看在我带大家整体梳理一遍之前大家掌握了多少。

143
00:07:13,433 --> 00:07:18,433
大家直接凭感觉回答就好。

144
00:07:18,438 --> 00:07:22,438
Should_receive是一个之前涉及到的一个方法，我们来看看下面这道关于should_receive的题。

145
00:07:22,442 --> 00:07:25,442


146
00:07:25,445 --> 00:07:28,445
下列关于should_receive的描述中，哪一项是错误的呢？

147
00:07:28,448 --> 00:07:32,448
选项一，实际的方法并没有实现，我们创建的should_receive方法替代了实际的方法。

148
00:07:32,452 --> 00:07:35,452


149
00:07:35,455 --> 00:07:38,455
选项二，即使我们已经实现了实际的方法，为了这个测试我们也需要创建一个should_receive方法覆盖之前的方法.

150
00:07:38,458 --> 00:07:42,458


151
00:07:42,462 --> 00:07:46,462
第三个描述是，should_receive在调用它的代码之前或之后出现都没问题。

152
00:07:46,466 --> 00:07:50,466


153
00:07:50,470 --> 00:07:54,470
第四个描述是，我们需要利用Ruby中的开放类和元编程来创建should_receive的seam。

154
00:07:54,474 --> 00:07:56,474


155
00:07:56,476 --> 00:08:00,476


156
00:08:00,000 --> 00:08:03,480


157
00:08:03,483 --> 00:08:06,483
四个之中有一个描述一定是错的

158
00:08:06,486 --> 00:08:09,486


159
00:08:09,489 --> 00:08:11,489
这不是一道很难的题。

