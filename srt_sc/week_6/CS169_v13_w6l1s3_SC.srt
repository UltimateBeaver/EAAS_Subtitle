1
00:00:00,000 --> 00:00:04,000
好的，那么马上来看下一个逻辑步骤，

2
00:00:04,004 --> 00:00:09,004
支架和对象工厂，即可回答接下来的问题。

3
00:00:09,009 --> 00:00:12,009
一旦掌握了模拟的知识，很容易会让大家开始疯狂运用模拟和存根，

4
00:00:12,012 --> 00:00:15,012
那么回过头再看你们的测试，那些大家所做的测试其实根本不值一提。

5
00:00:15,015 --> 00:00:19,015
实际上，有时你们真正需要的是真实对象。

6
00:00:19,019 --> 00:00:28,019
我们来看一个示例。

7
00:00:28,028 --> 00:00:33,028
这里的情况是，我设置的测试前提是

8
00:00:33,033 --> 00:00:35,033
我想测试“影片评级”的方法。

9
00:00:35,035 --> 00:00:37,035
也就是假设要罗列一些片名，再为影片评分，

10
00:00:37,037 --> 00:00:41,037
这是世界上最简单的事情了。我完成的是……对，我知道存根和模拟的用法。

11
00:00:41,041 --> 00:00:45,041
我将创建一个双存根，或是对影片进行模拟，

12
00:00:45,045 --> 00:00:48,045
但我知道这种影片评级法需要了解片名和评级属性。

13
00:00:48,048 --> 00:00:51,048
我需要存根该模拟的具体方法。

14
00:00:51,051 --> 00:00:54,051
这是存根的普通写法。

15
00:00:54,054 --> 00:00:58,054
首先，我创建模拟，另外，我并未将额外的参数赋予存根，

16
00:00:58,058 --> 00:01:00,058
而是另行单独完成这一步。

17
00:01:00,000 --> 00:01:03,060
这是同样的效果。基本上，我会对两个对象进行存根，

18
00:01:03,063 --> 00:01:07,063
并称其为“影片评级”。当我的任务完成得差不多时，

19
00:01:07,067 --> 00:01:10,067
我看着这些说道，“你看，我为什么不用一部真实的影片呢？”

20
00:01:10,070 --> 00:01:13,070
我是说，创建这个虚拟对象以及这些虚拟行为耗时耗力

21
00:01:13,073 --> 00:01:15,073
还不如直接创建真实对象，

22
00:01:15,075 --> 00:01:18,075
直接使用就好。

23
00:01:18,078 --> 00:01:22,078
当你们需要真实对象时，问题是去哪里拿到对象的真实拷贝？

24
00:01:22,082 --> 00:01:26,082
你们可以创建一个支架；

25
00:01:26,086 --> 00:01:29,086
这个术语来自制造业。

26
00:01:29,089 --> 00:01:32,089
基本上来说，支架可以用来固定一个机械装置，

27
00:01:32,092 --> 00:01:34,092
或是生成制造的物品。

28
00:01:34,094 --> 00:01:37,094
大家可以对其进行探测和刺戳，来完成各种测试。支架就是这类不会移动的部件，

29
00:01:37,097 --> 00:01:42,097
于是才有了这样的名称。

30
00:01:42,102 --> 00:01:44,102
在SAS编程世界中对应的意思是，因为模型常常是在列表中，

31
00:01:44,104 --> 00:01:48,104
这是说我们要将部分已知数据事先载入模型列表中。

32
00:01:48,108 --> 00:01:51,108
接着要对预期会找到的那些数据对象进行测试。

33
00:01:51,111 --> 00:01:53,111
我刚才展示的示例中，有这样一种可能性，

34
00:01:53,113 --> 00:01:56,113
你们可能需要创建两三部影片。

35
00:01:56,116 --> 00:01:59,116
要知道，影片会在那里，大家也了解它们的属性 。

36
00:01:59,119 --> 00:02:01,119
接着，当大家进行测试时，可以依赖数据库中的这些影片。

37
00:02:01,121 --> 00:02:04,121
这是其中的一种可能。

38
00:02:04,124 --> 00:02:08,124
还有一种可能是通过工厂模式，在构建抽象类的对象时，不要将之与工厂设计模式

39
00:02:08,128 --> 00:02:11,128
或工厂方式混淆。

40
00:02:11,131 --> 00:02:14,131
这里涉及创造的概念，

41
00:02:14,134 --> 00:02:17,134
大家在工厂模式中创造的理念仅仅是本次测试所需。

42
00:02:17,137 --> 00:02:21,137
如果我只是需要对两三部影片进行测试，

43
00:02:21,141 --> 00:02:25,141
我创建这两部影片时会按照该测试进行设置。

44
00:02:25,145 --> 00:02:28,145
也许大家已经猜到了，我们的规格足以对运行[rails 0:02:27]应用程序产生帮助……

45
00:02:28,148 --> 00:02:35,148
如果大家在具体的测试用例中创建数据库记录，

46
00:02:35,155 --> 00:02:44,155
因为该测试用例会用到这些，

47
00:02:44,164 --> 00:02:48,164
实际上，在这种情况下，测试运行完之后，这些数据库记录都会被清除。

48
00:02:48,168 --> 00:02:52,168
对于身处数据库领域的人们来说，

49
00:02:52,172 --> 00:02:54,172
如果大家对此真有兴趣了解，那么实际发生的情况是

50
00:02:54,174 --> 00:02:58,174
每个R规格测试都是在一个事务处理中运行。

51
00:02:58,178 --> 00:03:01,178
一旦测试结束，事物处理就会重新运行。

52
00:03:01,181 --> 00:03:05,181
你们可以在一个测试用例中创建全部临时数据；

53
00:03:05,185 --> 00:03:09,185
而且可以高度自信地认为

54
00:03:09,189 --> 00:03:12,189
该数据会在运行下一个测试用例时完全消失。

55
00:03:12,192 --> 00:03:15,192
这可以帮助大家的测试具备独立性的特点。

56
00:03:15,195 --> 00:03:19,195
这会提升支架和工厂模式之间的紧张度。在各规格之前，数据库都会清空和重新载入。

57
00:03:19,199 --> 00:03:23,199
如果我们将这行语句置于我们所描述的代码块伊始，

58
00:03:23,203 --> 00:03:25,203
那么基本上会是这样

59
00:03:25,205 --> 00:03:29,205
“在你们在本代码块上运行测试前，要事先载入本文件中描述的所有支架。”

60
00:03:29,209 --> 00:03:33,209
文件是“yml”格式，这是另一种标记语言。

61
00:03:33,213 --> 00:03:36,213
你们在rails框架中已经见到过“yml”文件，这些都无关紧要。

62
00:03:36,216 --> 00:03:39,216
你们基本上可以确定若干影片之类，

63
00:03:39,219 --> 00:03:41,219
并会将之载入影片列表。

64
00:03:41,221 --> 00:03:44,221
根据惯例优先原则，“通常，我看到文件名”

65
00:03:44,224 --> 00:03:47,224
就可以推断出这些支架将归入哪个数据库列表。”

66
00:03:47,227 --> 00:03:51,227
大家也可以这样做，其中的优点在于

67
00:03:51,231 --> 00:03:53,231
现在大家知道这些数据是什么。数据永远都不会改变；

68
00:03:53,233 --> 00:03:57,233
数据在每次测试前都会载入，大家也可以依赖这一点。

69
00:03:57,237 --> 00:03:59,237
另一方面，大家可能最后会在测试中引入偶然的依赖关系。

70
00:03:59,239 --> 00:04:03,239
例如，

71
00:04:03,243 --> 00:04:05,243
如果另外需要一个可以对满足某种标准的影片进行计数测试，

72
00:04:05,245 --> 00:04:08,245
如果大家开始对其他测试增减支架，

73
00:04:08,248 --> 00:04:12,248
这就可能影响到你们并未关注的测试计数表现。

74
00:04:12,252 --> 00:04:14,252
支架的缺点在于它会对所有测试产生影响，

75
00:04:14,254 --> 00:04:16,254
无论你们希望与否都是如此。

76
00:04:16,256 --> 00:04:20,256
与对象工厂相反，

77
00:04:20,260 --> 00:04:23,260
在这里会有辅助方法，使得大家可以轻松创建对象的各种版本，

78
00:04:23,263 --> 00:04:26,263
其中还会具备简单的默认属性。

79
00:04:26,266 --> 00:04:29,266
大家知道这些都是有效的。你们可以针对每个测试都这样做，

80
00:04:29,269 --> 00:04:31,269
因为这些都只在测试内部创建，在测试后都会清除。

81
00:04:31,271 --> 00:04:35,271
对于独立性问题，大家不必担心。

82
00:04:35,275 --> 00:04:36,275
这看上去是怎样的情况呢？

83
00:04:36,276 --> 00:04:40,276
不过，如果真要这么做，不要自己轻举妄动，去找一个不错的库 [或 gem 00:04:40 ]

84
00:04:40,280 --> 00:04:44,280
我用的这个叫做“FactoryGirl”，如果你们能找到的话，也可以用它。

85
00:04:44,284 --> 00:04:51,284
这里的示例就是怎样利用FactoryGirl创建影片的工厂模式。

86
00:04:51,291 --> 00:04:56,291
在我的工厂模式的一个定义中，

87
00:04:56,296 --> 00:04:59,296
我是这样表示的，“每当我想创建一个影片的默认版本时，

88
00:04:59,299 --> 00:05:01,299
只需提供片名，给出相应评级，再给出发行日期即可。”

89
00:05:01,301 --> 00:05:05,301
每次，如果我有具体测试，需要对之进行覆盖时，

90
00:05:05,305 --> 00:05:07,305
我自然可以这样操作。

91
00:05:07,307 --> 00:05:11,307
基本上，这意味着每当我需要某种真实的影片对象时，这里并不是替代物，

92
00:05:11,311 --> 00:05:14,311
而是货真价实的影片，

93
00:05:14,314 --> 00:05:17,314
我只需“生成”即可。这里有个示例，在本例中，我选择覆盖片名。

94
00:05:17,317 --> 00:05:20,317
我本意是让影片有个不同的片名。

95
00:05:20,320 --> 00:05:23,320
思路是要有个位置来放入基本的逻辑，

96
00:05:23,323 --> 00:05:26,323
以便创建这些对象。

97
00:05:26,326 --> 00:05:29,326
接下来，创建这些对象只需单行语句即可，不是么？

98
00:05:29,329 --> 00:05:31,329
只要获得了真实的对象，这几乎就像创建对象的模拟版本一样容易。

99
00:05:31,331 --> 00:05:34,331
正如我们开始接触更复杂的应用程序时所见，

100
00:05:34,334 --> 00:05:37,334
大家愿意这么做的原因是经常会有对象彼此间存在关系。

101
00:05:37,337 --> 00:05:40,337
例如，大家可以设想

102
00:05:40,340 --> 00:05:45,340
如果我有个电影爱好者对象，我还有门牌号这类地址。

103
00:05:45,345 --> 00:05:48,345
大家很难想象电影爱好者居然会没有有效的街道地址与之相配。

104
00:05:48,348 --> 00:05:50,348
的确，当大家创建电影爱好者时，

105
00:05:50,350 --> 00:05:53,350
还要创建这些与之相配的辅助对象。

106
00:05:53,353 --> 00:05:56,353
工厂模式可以让大家轻松实现这一点，

107
00:05:56,356 --> 00:05:58,356
因为大家可以把所有的逻辑放在一起，表示

108
00:05:58,358 --> 00:06:01,358
“这就是要创建该对象的有用版本。”

109
00:06:01,361 --> 00:06:04,361
即便其中会涉及临时创建将会用到的对象其他方面的内容时，也是如此。

110
00:06:04,364 --> 00:06:07,364
也许对象本身的有用版本

111
00:06:07,367 --> 00:06:11,367
依赖于所创建的用于完成这些辅助任务的模拟；

112
00:06:11,371 --> 00:06:13,371
所有这些内容都可以在对象工厂定义中的一个位置中得以涵盖。

113
00:06:13,373 --> 00:06:20,373
那么大家会选用哪个呢？正如我说过的那样，

114
00:06:20,380 --> 00:06:25,380
工厂模式存在一个潜在的问题，如果是要建立复杂的关系，

115
00:06:25,385 --> 00:06:28,385
工厂模式就可能非常复杂。

116
00:06:28,388 --> 00:06:30,388
另外，每当大家发现自己处于这种情况下时，

117
00:06:30,390 --> 00:06:33,390
这就意味着

118
00:06:33,393 --> 00:06:36,393
“代码未被良好分解。”如果完成一个简单测试需要

119
00:06:36,396 --> 00:06:39,396
设置许多复杂关系，

120
00:06:39,399 --> 00:06:42,399
那么必定会存在一个获悉了过多的关系内容的函数。

121
00:06:42,402 --> 00:06:44,402
那么大家就应思考该如何重构类，

122
00:06:44,404 --> 00:06:47,404
这样就不会有如此密集的交叉连接。

123
00:06:47,407 --> 00:06:49,407
在谈到重构问题时，还会讲到很多这方面内容。

124
00:06:49,409 --> 00:06:53,409
在对象工厂和支架对比时，怎样才能知道自己犯下大错呢？

125
00:06:53,413 --> 00:06:56,413
我最喜欢的功能叫做

126
00:06:56,416 --> 00:06:58,416
“mock train wreck”。若要激活这一功能，可以通过如下示例，

127
00:06:58,418 --> 00:07:02,418
我们将测试一个假设方法，

128
00:07:02,422 --> 00:07:05,422
这是通过影片导演或是它所获得的奥斯卡奖项，或是其他奖项来进行搜索。

129
00:07:05,425 --> 00:07:08,425
这些内容是

130
00:07:08,428 --> 00:07:15,428
我们想最终写入测试中的部分。

131
00:07:15,435 --> 00:07:17,435
我们同样希望从这一测试中查出导演的姓名。

132
00:07:17,437 --> 00:07:19,437
如果我们想将这些内容放入测试，也就意味着我们必须有影片对象。

133
00:07:19,439 --> 00:07:22,439
影片对象必须与导演对象相关联，

134
00:07:22,442 --> 00:07:26,442
而这也就有了姓名属性。

135
00:07:26,446 --> 00:07:28,446
实际上，我们将三者链接在一起则意味着

136
00:07:28,448 --> 00:07:31,448
影片对象了解自己的孙级对象的诸多内容。

137
00:07:31,451 --> 00:07:36,451
如果我们当真需要就此进行设置，

138
00:07:36,456 --> 00:07:38,456
则要模拟奖项，模拟导演，

139
00:07:38,458 --> 00:07:41,458
还要模拟具备这两项内容属性的影片。

140
00:07:41,461 --> 00:07:44,461
那么此刻，大家真应该问自己，“稍等一下。

141
00:07:44,464 --> 00:07:47,464
为什么奖项类型又是需要了解的影片重要内容，

142
00:07:47,467 --> 00:07:50,467
难道不该把表现为第一类属性的奖项对象

143
00:07:50,470 --> 00:07:53,470
作为第一类取值方法呢?”

144
00:07:53,473 --> 00:07:56,473
此外，若真如此，我们可以直接把取值 存根。

145
00:07:56,476 --> 00:07:59,476
这样就不必创建模拟序列，以及命名“mock train wreck”；

146
00:07:59,479 --> 00:08:02,479
它们都链接在了一起。

147
00:08:02,482 --> 00:08:05,482
真正的问题在于影片对象不应了解自己后代的内容。

148
00:08:05,485 --> 00:08:08,485
它应该了解的是奖项的相关内容，

149
00:08:08,488 --> 00:08:11,488
但不应了解子类对象或是奖项的属性，

150
00:08:11,491 --> 00:08:14,491
这些信息太过庞杂。当我们讲到重构时，会介绍更多相关内容。

151
00:08:14,494 --> 00:08:17,494
作为预习先提一点，这就是代码的“狎昵关系”。

152
00:08:17,497 --> 00:08:20,497
影片与奖项

153
00:08:20,500 --> 00:08:23,500
以及理解内部细节都毫无关系。先理解到这一步。

154
00:08:23,503 --> 00:08:28,503
现在大家学习了支架和对象工厂，

155
00:08:28,508 --> 00:08:32,508
这里有个很好的直觉性问题。

156
00:08:32,512 --> 00:08:35,512
能否举例说明哪些数据不应按照支架进行设置？

157
00:08:35,515 --> 00:08:38,515
如有，哪些不太适合作为支架处理的良好候选版本？

158
00:08:38,518 --> 00:08:42,518
影片及其评级；我们做过的TMDb示例中的TMDb API密钥；

159
00:08:42,522 --> 00:08:46,522
或是时区设置应用程序，

160
00:08:46,526 --> 00:08:50,526
一旦有这些在运行，都是不适用于支架的良好候选版本，

161
00:08:50,530 --> 00:08:54,530
当然，那么具体原因何在呢？

