1
00:00:00,000 --> 00:00:03,000
好的，那么目前看来，所有TDD都集中在控制器上，

2
00:00:03,003 --> 00:00:06,003
我们暂且搁置这个问题，

3
00:00:06,006 --> 00:00:08,006
等到模型中出现真正这类问题再说，我们目前还没有真正碰到这些内容，对不对？

4
00:00:08,008 --> 00:00:10,008
我们一直都是假设我们到处都会用到这个技术。

5
00:00:10,010 --> 00:00:13,010
那么现在，我们就开始学习吧。

6
00:00:13,013 --> 00:00:17,013
相当于预习，大家在培根甲骨文网站的作业中对此已经有所了解，

7
00:00:17,017 --> 00:00:20,017
即便在模型中出现了这种真实情况，

8
00:00:20,020 --> 00:00:23,020
部分真实任务是要涉及外部服务，

9
00:00:23,023 --> 00:00:27,023
正如我们所知，在测试套件中，

10
00:00:27,027 --> 00:00:31,027
这并不真正适合这么做。因此书中有一个示例

11
00:00:31,031 --> 00:00:34,031
向我们展示针对模型方法该如何处理TDD， 

12
00:00:34,034 --> 00:00:38,034
就是要将这一思路的显性和隐性要求进行对比。

13
00:00:38,038 --> 00:00:42,038
我们已经了解

14
00:00:42,042 --> 00:00:45,042
针对该假设模型方法应如何实施我们已经提出了显性要求。

15
00:00:45,045 --> 00:00:47,045
其中将调用RubyGem,相应也会调用TMDb服务。

16
00:00:47,047 --> 00:00:51,047
另外，如果我们并没有RubyGem,那该如何是好？

17
00:00:51,051 --> 00:00:53,051
那么，我们的做法将与

18
00:00:53,053 --> 00:00:56,053
培根甲骨文网站作业中的情况非常类似，对不对?

19
00:00:56,056 --> 00:00:58,056
我们需要构建正确类型的URI,获得响应，

20
00:00:58,058 --> 00:01:01,058
进行解析，并创建良好的Ruby对象。

21
00:01:01,061 --> 00:01:05,061
在这一具体示例中，TMDb RubyGem为我们做了很多这方面的工作。

22
00:01:05,065 --> 00:01:09,065
那么，这就是显性要求。

23
00:01:09,069 --> 00:01:11,069
可是隐形要求是来自那些如果不奏效会怎样的内容？

24
00:01:11,071 --> 00:01:14,071
可能会出现问题的原因是什么？

25
00:01:14,074 --> 00:01:18,074
有两种具体情况是说如果你提供了API密钥，却无法有效调用TMDb,

26
00:01:18,078 --> 00:01:21,078
或是在此处留了空格，或根本没有提供API密钥。

27
00:01:21,081 --> 00:01:24,081
正如书中所讲，

28
00:01:24,084 --> 00:01:27,084
如果是在本例中，这些就实际上是两种不同的失败模式，

29
00:01:27,087 --> 00:01:31,087
大家可以设想一下具体原因，对不对？

30
00:01:31,091 --> 00:01:34,091
如果密钥是空，显然这存在问题，因为没有任何合法密钥是空的。

31
00:01:34,094 --> 00:01:36,094
不过如果密钥不是空的，那么就无法认定这是有效形式，

32
00:01:36,096 --> 00:01:39,096
除非你们当真就以此作为密钥。

33
00:01:39,099 --> 00:01:42,099
那么，gem在这两种不同情况下的确会出现两种不同的问题，

34
00:01:42,102 --> 00:01:46,102
通过上下文和描述来分组测试是个很好的出发点。

35
00:01:46,106 --> 00:01:50,106
这是阻塞性测试的一个示例。

36
00:01:50,110 --> 00:01:53,110
另外，我应该指出的是描述和上下文从根本上而言

37
00:01:53,113 --> 00:01:56,113
是彼此的别名。

38
00:01:56,116 --> 00:01:59,116
二者都是调用相同底层的方法。那么，为什么要采用不同的措辞呢？

39
00:01:59,119 --> 00:02:02,119
因为这可以帮助表明意图，对不对？描述是指，

40
00:02:02,122 --> 00:02:07,122
“一般来说，我是在描述一种行为，通过关键词搜索TMDb,”

41
00:02:07,127 --> 00:02:10,127
而上下文是说，

42
00:02:10,130 --> 00:02:13,130
“在不同的情况下，可能会引发这种行为。”一种上下文是说如果我使用有效密钥会怎样。

43
00:02:13,133 --> 00:02:16,133
另一种上下文是说如果我使用无效密钥会怎样。

44
00:02:16,136 --> 00:02:20,136
另外，在无效密钥中，至少存在两种情况。

45
00:02:20,140 --> 00:02:23,140
根本未能提供密钥，因此此处是空的，

46
00:02:23,143 --> 00:02:29,143
另一种是提供了密钥，但是密钥不正确。

47
00:02:29,149 --> 00:02:32,149
基本上而言，我会对大量测试进行分组，

48
00:02:32,152 --> 00:02:35,152
基本是根据这组示例是否在测试相关行为来进行分组。

49
00:02:35,155 --> 00:02:39,155
同样，正如书中所解释，

50
00:02:39,159 --> 00:02:42,159
如果有可以适用于小组所有测试的共同前置条件，

51
00:02:42,162 --> 00:02:44,162
例如，它们都是将使用相同的stub，

52
00:02:44,164 --> 00:02:47,164
或是所有测试都将用到某个mock，那么大家可以插入一个适用于所有测试的前置代码块,

53
00:02:47,167 --> 00:02:49,167
这样就

54
00:02:49,169 --> 00:02:51,169
不必在每个示例中不断重复这些前置条件。

55
00:02:51,171 --> 00:02:57,171
那么，我们讲到哪里了？隐形要求是从显性要求导出，

56
00:02:57,177 --> 00:03:00,177
在TMDb示例中，

57
00:03:00,000 --> 00:03:03,180
我怎么才能知道gem会以两种不同的方式失败呢？

58
00:03:03,183 --> 00:03:06,183
对，一方面，我可以阅读文档。这是一个新概念。

59
00:03:06,186 --> 00:03:09,186
大部分内容都在文档中有很好的体现。

60
00:03:09,189 --> 00:03:13,189
实际上，良好的RubyGems的部分文档就在其规格当中。

61
00:03:13,193 --> 00:03:16,193
此外，如果大家用的是gem,在下载网站中并未找到相应的规格说明文件，

62
00:03:16,196 --> 00:03:19,196
则意味着它或是测试覆盖率不佳，

63
00:03:19,199 --> 00:03:21,199
或是已经过期，所以规格说明文件并未得到维护。

64
00:03:21,201 --> 00:03:24,201
大家当然不希望是这种情况，对不对？大家需要库可以得到积极支持和建设，

65
00:03:24,204 --> 00:03:26,204
并具备一套完整的规格说明文件，

66
00:03:26,206 --> 00:03:30,206
这实际上是体现该gem是否可靠的良好生态指标。

67
00:03:30,210 --> 00:03:33,210
大家也可以在设计自己的类并试验这些代码时，

68
00:03:33,213 --> 00:03:36,213
实际观察这些代码会如何发挥作用，

69
00:03:36,216 --> 00:03:39,216
接下来，大家就会在测试中捕捉到这种行为。

70
00:03:39,219 --> 00:03:41,219
当讲到遗留代码时，我们会介绍更多相关内容。

71
00:03:41,221 --> 00:03:44,221
我们在这一情况中使用两种不同的stub方法。

72
00:03:44,224 --> 00:03:48,224
在一种情况中，我们了解到TMDb gem将会立刻抛出错误， 

73
00:03:48,228 --> 00:03:51,228
因此我们必须创建的唯一测试是要确定

74
00:03:51,231 --> 00:03:53,231
我们是否捕捉到错误，并将之转换为正确的异常类型，

75
00:03:53,233 --> 00:03:57,233
因此，调用者总是会看到相同类的异常么？

76
00:03:57,237 --> 00:03:59,237
在第二种情况下，我们实际上需要从根本上防止gem和TMDb发生联系。

77
00:03:59,239 --> 00:04:03,239
现在，这种情况下，

78
00:04:03,243 --> 00:04:06,243
书中的示例所体现的方式

79
00:04:06,246 --> 00:04:09,246
再次和培根甲骨文网站的作业非常类似，

80
00:04:09,249 --> 00:04:16,249
我们使用FakeWeb来对整个互联网进行stub。那么，这就会引发一个普遍问题，

81
00:04:16,256 --> 00:04:19,256
当对在面向服务体系架构中运行的软件进行测试时，

82
00:04:19,259 --> 00:04:22,259
应该在哪里进行stub？

83
00:04:22,262 --> 00:04:25,262
记住，大家可以在一定程度上可以采取这种观点，

84
00:04:25,265 --> 00:04:29,265
我在编写将会有所帮助的测试，

85
00:04:29,269 --> 00:04:31,269
他们在测试对外部服务有所帮助的代码。

86
00:04:31,271 --> 00:04:35,271
因此在这种场景中，我是客户端，

87
00:04:35,275 --> 00:04:36,275
需要连接其他服务器编写测试，

88
00:04:36,276 --> 00:04:39,276
可我需要stub这个服务器，以确保测试快速独立进行。

89
00:04:39,279 --> 00:04:43,279
另一种情况在我们讲到JavaScript开发时会见到，

90
00:04:43,283 --> 00:04:45,283
在客户端运行JavaScript，

91
00:04:45,285 --> 00:04:48,285
大家常常想在隔离它所依赖的服务器代码的条件下进行测试。

92
00:04:48,288 --> 00:04:51,288
这样，这里的概念实际上会在多种不同场景下出现。

93
00:04:51,291 --> 00:04:55,291
在哪里stub？

94
00:04:55,295 --> 00:04:57,295
其实，我们已经见过大家可以直接在模型类中进行stub的方法，

95
00:04:57,297 --> 00:05:02,297
有学生曾给出一个类比，

96
00:05:02,302 --> 00:05:05,302
将stub比作是切断路径，

97
00:05:05,305 --> 00:05:07,305
在我看来，我们在此处正是这样考虑问题。

98
00:05:07,307 --> 00:05:11,307
我们切断了一条路径，对不对？如果我们表示“对影片stub”

99
00:05:11,311 --> 00:05:13,311
或在影片类中直接对TMDb方法生成stub，

100
00:05:13,313 --> 00:05:16,313
在某种意义上，我们是在最早的可能情况下切断了路径，对不对？

101
00:05:16,316 --> 00:05:18,316
我们甚至都不允许接受调用的真实方法出现。

102
00:05:18,318 --> 00:05:20,318
我们在这行语句下的所有内容都并非真实。

103
00:05:20,320 --> 00:05:23,320
我们佯装这些内容都会发挥功效，

104
00:05:23,323 --> 00:05:27,323
我们会返回一个固定值。

105
00:05:27,327 --> 00:05:30,327
我们还会在gem层以下进行stub。

106
00:05:30,330 --> 00:05:33,330
也就说，看，我们将调用我们的影片方法，我们将调用真实的对象，

107
00:05:33,333 --> 00:05:36,333
可我们知道，我们的影片方法实际上将调用这个gem中的某些内容，

108
00:05:36,336 --> 00:05:38,336
是在这个库中进行，

109
00:05:38,338 --> 00:05:41,338
因此这才是我们将stub的位置。我们实际上是对gem生成stub。

110
00:05:41,341 --> 00:05:44,341
也就是说，我很高兴实际上是对我这部分代码进行测试，

111
00:05:44,344 --> 00:05:48,344
可我希望把这个库stub出去。再进一步说，

112
00:05:48,348 --> 00:05:51,348
我们可以讲，如果最终TMDb gem可以调用外部服务，

113
00:05:51,351 --> 00:05:54,351
它最终将必须经过一个Ruby的类库，

114
00:05:54,354 --> 00:05:57,354
允许进行HTTP调用。

115
00:05:57,357 --> 00:06:01,357
因此，我们可以仅仅就此stub。我们可以对HTTP调用生成stub，

116
00:06:01,361 --> 00:06:04,361
并要确保通过正确的URI，我们还可以返回到页面内容。 

117
00:06:04,364 --> 00:06:08,364
这就是FakeWeb可以为大家实现的功能。

118
00:06:08,368 --> 00:06:13,368
那么，如果我们要实现这一点，我们真正在做的是对设计的请求进行解析。

119
00:06:13,373 --> 00:06:16,373
我们可以来看真实的服务，

120
00:06:16,376 --> 00:06:18,376
我们可以相应提出若干请求，

121
00:06:18,378 --> 00:06:21,378
我们可以捕获这些真实请求的具体结果，

122
00:06:21,381 --> 00:06:24,381
接下来，我们可以将这些固定值用于FakeWeb。

123
00:06:24,384 --> 00:06:27,384
这就是培根甲骨文网站作业中的内容，

124
00:06:27,387 --> 00:06:30,387
这也是当大家针对远程服务编码时的标准做法。

125
00:06:30,390 --> 00:06:33,390
大家已经就API及其返回内容学习了很多，

126
00:06:33,393 --> 00:06:36,393
最好能使用cURL这类命令行工具做些互动测试，

127
00:06:36,396 --> 00:06:40,396
来看当产生刺激时，实际会发生些什么，

128
00:06:40,400 --> 00:06:42,400
之后，大家会捕获结果，

129
00:06:42,402 --> 00:06:46,402
并对之进行类似“冻干”处理，还可使用FakeWeb这类 gem。 

130
00:06:46,406 --> 00:06:49,406
还有一种可能我们未曾接触，

131
00:06:49,409 --> 00:06:51,409
不过如果大家是面向服务体系架构中的服务提供商

132
00:06:51,411 --> 00:06:53,411
才有可能用到

133
00:06:53,413 --> 00:06:57,413
那么还可以建立一个开发版本。例如，如果你们要编写一个针对PayPal或Stripe的应用，

134
00:06:57,417 --> 00:07:00,417
这些都是接受大众钱款的服务商，

135
00:07:00,000 --> 00:07:03,420
那么有个相当重要的功能，

136
00:07:03,423 --> 00:07:06,423
两家服务商都具备开发人员沙箱技术，

137
00:07:06,426 --> 00:07:09,426
它在API角度下和真实生产现场下的表现都完全一致，

138
00:07:09,429 --> 00:07:12,429
令人欣喜的是，这种技术可以不造成任何转账行为。

139
00:07:12,432 --> 00:07:15,432
也就是说，大家可以在自己的应用程序中生成其他级别的stub，

140
00:07:15,435 --> 00:07:16,435
当大家准备真正对之进行测试时，

141
00:07:16,436 --> 00:07:20,436
还有一个级别的确认可供选择，

142
00:07:20,440 --> 00:07:23,440
即把自己的全栈框架在相应的沙箱服务器上进行测试，

143
00:07:23,443 --> 00:07:27,443
这并不需要提出真实的请求。

144
00:07:27,447 --> 00:07:30,447
并非所有服务都有自己的沙箱版本。

145
00:07:30,450 --> 00:07:33,450
在培根甲骨文的案例中，这并不重要。

146
00:07:33,453 --> 00:07:36,453
可是在付款或认证这类服务中，

147
00:07:36,456 --> 00:07:39,456
如果大家在编写脸书应用程序，脸书会有部分测试服务

148
00:07:39,459 --> 00:07:43,459
可供大家测试自己的应用程序。

149
00:07:43,463 --> 00:07:47,463
因此，在不同级别生成stub的想法非常普遍。

150
00:07:47,467 --> 00:07:49,467
经验法则说明，如果大家在从事更多单元测试，

151
00:07:49,469 --> 00:07:52,469
设法在少量代码上覆盖许多特殊代码路径，

152
00:07:52,472 --> 00:07:55,472
在旁边生成stub毫无问题，因为大家的目的是进行隔离，对不对？

153
00:07:55,475 --> 00:07:59,475
大家是想隔离受测试的代码，使其不受其他信息副作用的影响，

154
00:07:59,479 --> 00:08:02,479
不过随着大家更进一步，

155
00:08:02,482 --> 00:08:05,482
进入针对集成测试的测试栈环节，

156
00:08:05,485 --> 00:08:07,485
有了集成测试，大家就该甩掉越来越多的辅助措施，对不对？

157
00:08:07,487 --> 00:08:10,487
在这些情况下，大家可以尽可能远的生成stub，

158
00:08:10,490 --> 00:08:14,490
因为集成测试的目标是

159
00:08:14,494 --> 00:08:17,494
尽量接近事实情况。

160
00:08:17,497 --> 00:08:20,497
相当于是大家在不联系服务商时的最近似现实情况，对么？

161
00:08:20,500 --> 00:08:22,500
那么进行到这一地步，大家基本上可以stub互联网了，

162
00:08:22,502 --> 00:08:26,502
如果再有问题，还可能是实际的网络交互出现了问题。

163
00:08:26,506 --> 00:08:30,506
那么，我们可以再次提升我们对测试的相关内容的理解。

164
00:08:30,510 --> 00:08:36,510


165
00:08:36,516 --> 00:08:39,516
书中的示例提到了更多细节，

166
00:08:39,519 --> 00:08:43,519
出于时间的关系，我没有办法在讲座中详细介绍，

167
00:08:43,523 --> 00:08:46,523
但是与stub和should_receive一样，大家应该可以明确方法应该返回某些内容。

168
00:08:46,526 --> 00:08:49,526
大家还可明确在某些具体情况下，

169
00:08:49,529 --> 00:08:53,529
还应抛出异常，如果在括号中插入行动或lambda表达式，

170
00:08:53,533 --> 00:08:57,533
则可以允许对所抛出的错误进行测试。

171
00:08:57,537 --> 00:09:00,537
这一点相当重要，

172
00:09:00,000 --> 00:09:03,540
因为正如在本课的作业中大家可能有所发现，

173
00:09:03,543 --> 00:09:05,543
如果在测试用例中提出了异常，

174
00:09:05,545 --> 00:09:08,545
该测试就会结束，对不对？

175
00:09:08,548 --> 00:09:12,548
提出异常就会即刻失败。

176
00:09:12,552 --> 00:09:14,552
当你对该行为感兴趣时，怎样才能对正确提出异常的情况进行测试呢？

177
00:09:14,554 --> 00:09:18,554
基本上大家可以将该测试用例本身放入括号，

178
00:09:18,558 --> 00:09:21,558
就仿佛是个代码块，

179
00:09:21,561 --> 00:09:24,561
这就表示是在创建一个lambda表达式，

180
00:09:24,564 --> 00:09:27,564
基本上是在可控的环境下运行，对不对？我们的规格说明文件会执行它，

181
00:09:27,567 --> 00:09:30,567
还会处理异常，确认会提出正确的选择。

182
00:09:30,570 --> 00:09:36,570
这样我们就可以针对隐式和显式要求的比较提出问题。

183
00:09:36,576 --> 00:09:40,576
有关隐式要求，哪种说法是正确的呢？

184
00:09:40,580 --> 00:09:42,580
隐式要求多数但不一定都是从显式要求导出，

185
00:09:42,582 --> 00:09:45,582
隐式要求适用于单元测试和功能测试，

186
00:09:45,585 --> 00:09:48,585
但并不适用于集成测试，

187
00:09:48,588 --> 00:09:49,588
隐式测试的测试优先权较低，因为它们并非来自客户，

188
00:09:49,589 --> 00:09:53,589
上述说法是否都正确呢？

