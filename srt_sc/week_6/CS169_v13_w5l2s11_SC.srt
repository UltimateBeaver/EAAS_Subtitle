1
00:00:00,000 --> 00:00:03,000
Seam的概念是非常重要的，因此我现在要单独讲一下他。

2
00:00:03,003 --> 00:00:09,003
我觉得Michael Feathers的《Dealing Effectively with Legacy Code》书中对他的定义比较准确。

3
00:00:09,009 --> 00:00:12,009


4
00:00:12,012 --> 00:00:17,012
我们之前在书中看到的很多关于遗留代码的内容也都和他有很多相同的观点。

5
00:00:17,017 --> 00:00:20,017


6
00:00:20,020 --> 00:00:25,020
他在书中定义到，Seam指程序中的一些特殊的点，在这些点上你无需做任何修改就可以达到改动程序行为的目的。

7
00:00:25,025 --> 00:00:27,025


8
00:00:27,027 --> 00:00:31,027
这对于测试是非常有帮助的，因为单元测试中非常重要的一件事就是将依赖于代码部分的一部分代码段落独立出来

9
00:00:31,031 --> 00:00:34,031


10
00:00:34,034 --> 00:00:37,034


11
00:00:37,037 --> 00:00:40,037
通过之前的例子我们了解到，假设我们已经在电影模型中实现了find_in_tmdb方法，

12
00:00:40,040 --> 00:00:43,040


13
00:00:43,043 --> 00:00:47,043
可能会发生这样一件事，我们不再需要创建一个seam去“假装”这个方法还没有实现。

14
00:00:47,047 --> 00:00:51,047


15
00:00:51,051 --> 00:00:53,051
因为这部分代码其实已经都实现了。

16
00:00:53,053 --> 00:00:56,053
但其实，真正需要用到seam并不是因为一部分代码和功能还没有实现，

17
00:00:56,056 --> 00:00:59,056
而是因为如果这段代码是不完整的，或者有人曾经修改过这段代码，那么我们是没办法来测试需要调用这部分功能的代码的。

18
00:00:59,059 --> 00:01:02,059


19
00:01:02,062 --> 00:01:04,062


20
00:01:04,064 --> 00:01:08,064
Seam真正的作用就是即使这段代码与其他有问题的代码相关联

21
00:01:08,068 --> 00:01:10,068
我们仍可以通过加入seam将其独立出来。

22
00:01:10,070 --> 00:01:14,070
下面我们来看一个例子

23
00:01:14,074 --> 00:01:18,074
Should_receive是一个方法，我们用Ruby中的开放类来创建一个seam将他独立出来。

24
00:01:18,078 --> 00:01:24,078


25
00:01:24,084 --> 00:01:28,084
每次测试过用例之后，Rspec都会重置所有的seam

26
00:01:28,088 --> 00:01:30,088
像我们之前做的一样，我们为了监控一个电影类中并不存在的一个方法而临时创建了一个seam，

27
00:01:30,090 --> 00:01:33,090


28
00:01:33,093 --> 00:01:37,093
假设这个方法已经实现我仍然监控他。

29
00:01:37,097 --> 00:01:40,097
当下次在运行测试用例时，

30
00:01:40,100 --> 00:01:46,100
这个seam就会被移除掉。

31
00:01:46,106 --> 00:01:48,106
这意味着只要测试需要监控，我都需要重新建立一个seam。这个问题其实还是一个小问题。

32
00:01:48,108 --> 00:01:51,108
我们知道我们有办法可以在同一时间运行很多测试。

33
00:01:51,111 --> 00:01:54,111
重要的就是我们能通过这样的方式保持每个测试的部分都这样独立。

34
00:01:54,114 --> 00:01:57,114


35
00:01:57,117 --> 00:02:00,117
在一个指定的测试中，我们可以命令“我需要替代那些有依赖性的部分” 

36
00:02:00,000 --> 00:02:03,120
或“我需要一些可控的部分，因为这能够让我得测试结果可预测”

37
00:02:03,123 --> 00:02:06,123


38
00:02:06,126 --> 00:02:08,126


39
00:02:08,128 --> 00:02:10,128
这其实就是一些有独立性的并且可重复的对测试有利的东西。

40
00:02:10,130 --> 00:02:15,130


41
00:02:15,135 --> 00:02:17,135
我们已经知道我们可以编写…我们编写的还不会通过测试，因为虽然我们描述了这个控制器相关的功能，但我们已经清空了控制器的方法。

42
00:02:17,137 --> 00:02:21,137


43
00:02:21,141 --> 00:02:23,141
这里什么都没有，那么实现描述功能的最少需要多少代码呢？

44
00:02:23,143 --> 00:02:26,143
我们要记得我们的目标是我们用尽量少的代码让测试通过，

45
00:02:26,146 --> 00:02:28,146


46
00:02:28,148 --> 00:02:31,148
能够从状态“红”到状态“绿”

47
00:02:31,151 --> 00:02:34,151
我们认为控制器方法应该调用电影类中的find_in_tmdb，

48
00:02:34,154 --> 00:02:38,154
那就让我们实现它。

49
00:02:38,158 --> 00:02:42,158


50
00:02:42,162 --> 00:02:51,162
我是这样修改控制器方法的

51
00:02:51,171 --> 00:02:54,171
我在这里加了一行代码，做的就是测试用例描述的事

52
00:02:54,174 --> 00:02:59,174
他调用了find_in_tmdb方法，参数就是搜索词。

53
00:02:59,179 --> 00:03:01,179
现在可能有人会问“有什么实质的内容在这里进行了测试么？”

54
00:03:01,181 --> 00:03:05,181
是的。在这里我做了这样一个假设：搜索词中就包含了电影的名字，我们就把这个作为调用find_in_TMDb时传递的参数。

55
00:03:05,185 --> 00:03:09,185


56
00:03:09,189 --> 00:03:12,189


57
00:03:12,192 --> 00:03:15,192
如果我在测试用例中模拟的提交不符合这个，或者我误用了外国文字的名字或类似错误，

58
00:03:15,195 --> 00:03:16,195
那么这样简单地测试可以帮助找到这些很明显的错误。

59
00:03:16,196 --> 00:03:20,196


60
00:03:20,200 --> 00:03:23,200
即使我们没有实现movie中find_in_tmbd这个方法，这个测试还是可实现的。

61
00:03:23,203 --> 00:03:27,203
是的，我们还没有实现这个find_in_TMDb方法。

62
00:03:27,207 --> 00:03:29,207
但重要的是，我们验证了之前的一些想法。

63
00:03:29,209 --> 00:03:36,209
我们其实已经做了很多。

64
00:03:36,216 --> 00:03:40,216
这个过程引导了我们去编写控制器的代码。

65
00:03:40,220 --> 00:03:42,220


66
00:03:42,222 --> 00:03:44,222
他让我们去思考控制器需要去做些什么，

67
00:03:44,224 --> 00:03:48,224
让我们去思考控制器会和其他哪些方法有依存关系。

68
00:03:48,228 --> 00:03:50,228


69
00:03:50,230 --> 00:03:53,230
在这个例子中，他和其他的方法和模型都有联系，

70
00:03:53,233 --> 00:03:57,233
即使与他相关的其他的方法和模型可能都已经实现并能通过这个测试，

71
00:03:57,237 --> 00:03:59,237
为了进行测试，我们仍可以在控制器和模型之间找到一个衔接点，

72
00:03:59,239 --> 00:04:01,239
创建一个seam，把我们想要测试的代码部分独立出来。

73
00:04:01,241 --> 00:04:05,241


74
00:04:05,245 --> 00:04:08,245


75
00:04:08,248 --> 00:04:10,248
还有一点我们需要强调的就是，我们还没有实现find_in_tmdb这个方法，但我们知道这个方法会有返回值。

76
00:04:10,250 --> 00:04:15,250


77
00:04:15,255 --> 00:04:22,255
目前来说，我们只是调用它

78
00:04:22,262 --> 00:04:25,262
我们并没有明确调用它之后会返回什么

79
00:04:25,265 --> 00:04:27,265
我们想要用尽量少的代码让测试通过，但是现在我们还不需要编写实际的代码。

80
00:04:27,267 --> 00:04:30,267


81
00:04:30,270 --> 00:04:37,270
我们之后会再来实现他的代码。

82
00:04:37,277 --> 00:04:40,277
事实上，为了教学我举了一个非常简单的例子，因为我想让大家知道这么一点：

83
00:04:40,280 --> 00:04:42,280


84
00:04:42,282 --> 00:04:46,282
一个测试和一个行为应该是一一对应的。

85
00:04:46,286 --> 00:04:48,286
在这个例子中这个行为就是控制器调用find_in_tmdb方法。

86
00:04:48,288 --> 00:04:53,288
问题就是，find_in_tmdb这个方法是不是应该有返回值呢？

87
00:04:53,293 --> 00:04:57,293
如果有返回值的话，那些数据会发生什么呢？

88
00:04:57,297 --> 00:04:58,297
我们还没有讨论过这个问题，但这并不代表find_in_tmdb方法的返回值不重要。

89
00:04:58,298 --> 00:05:02,298
而这些应该是在测试find_in_tmdb这部分代码中着重考虑的。

90
00:05:02,302 --> 00:05:05,302


91
00:05:05,305 --> 00:05:08,305
如果确实有返回值那么会发生什么呢？

92
00:05:08,308 --> 00:05:11,308
当我们创建视图时会发生什么呢？

93
00:05:11,311 --> 00:05:14,311
调用模型的目的就是得到视图中需要展示的信息，

94
00:05:14,314 --> 00:05:17,314
我们一会就会来回答这个问题。

95
00:05:17,317 --> 00:05:20,317
下面我们会总结一下列出来如何做测试：

96
00:05:20,320 --> 00:05:24,320


97
00:05:24,324 --> 00:05:29,324
某些对象会被我其他方法调用，我们可以规定哪些参数应该传递进来。

98
00:05:29,329 --> 00:05:33,329


99
00:05:33,333 --> 00:05:36,333
在这个例子中，这一点的确十分重要。

100
00:05:36,336 --> 00:05:38,336
关注这一点的原因是因为我们想要测试的是，

101
00:05:38,338 --> 00:05:41,338
控制器需要从用户获取到数据并将数据传递到对应的模型中去。

102
00:05:41,341 --> 00:05:44,341


103
00:05:44,344 --> 00:05:47,344
在我们之前的例子中，我们不仅关注find_in_tmdb是否被调用

104
00:05:47,347 --> 00:05:51,347
我们还关注会传递什么参数

105
00:05:51,351 --> 00:05:54,351
这两点都和他调用的模型方法相关，之后模型方法会连接数据库并进行数据处理。

106
00:05:54,354 --> 00:05:57,354


107
00:05:57,357 --> 00:06:00,357
还有一些其他的例子，我们只关注这两点中其中的一项

108
00:06:00,000 --> 00:06:03,360
例如，如果一个方法没有任何参数，那么我只关注这个方法是否被调用。

109
00:06:03,363 --> 00:06:07,363


110
00:06:07,367 --> 00:06:09,367
或者因为其他的一些原因，这个测试用例就只关注整个的控制流而不关注数据流，

111
00:06:09,369 --> 00:06:13,369
我们就不需要关注传递的参数。

112
00:06:13,373 --> 00:06:16,373
这意味着只要正确的方法被调用了，不论传递什么参数，测试都会通过。

113
00:06:16,376 --> 00:06:19,376


114
00:06:19,379 --> 00:06:22,379
我们还有很多东西需要学习，关于测试中我们如何细化到具体的某一个点，什么时间应该发生，和如何实现代码最终通过我们的测试。

115
00:06:22,382 --> 00:06:26,382


116
00:06:26,386 --> 00:06:29,386


117
00:06:29,389 --> 00:06:34,389
现在我们都达成了共识

118
00:06:34,394 --> 00:06:36,394
最终，我们会实现find_in_tmdb方法

119
00:06:36,396 --> 00:06:40,396
当我们实现以后，我们需要做什么呢？

120
00:06:40,400 --> 00:06:43,400
我们可以调用实际实现的find_in_TMDb方法，而不再需要调用should_recerive这个方法

121
00:06:43,403 --> 00:06:46,403
我们只需要确保实际方法的调用接口和我们之前为了测试写的should_receive调用接口应该是一样的。

122
00:06:46,406 --> 00:06:50,406


123
00:06:50,410 --> 00:06:52,410


124
00:06:52,412 --> 00:06:56,412
我们还是需要seam但是seam会有些不同，因为他的调用接口会和之前有一些区别。

125
00:06:56,416 --> 00:06:59,416


126
00:06:59,419 --> 00:07:02,419


127
00:07:02,422 --> 00:07:05,422
或者我们可以直接移除整个的测试用例

128
00:07:05,425 --> 00:07:09,425
由于find_in_tmdb这个方法已经实现了，这个测试用例也就可以删除了

129
00:07:09,429 --> 00:07:15,429


130
00:07:15,435 --> 00:07:17,435


