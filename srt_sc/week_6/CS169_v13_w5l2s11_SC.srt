1
00:00:00,000 --> 00:00:03,000
Seam的概念是非常重要的，

2
00:00:03,003 --> 00:00:09,003
因此我现在要单独讲一下他。我觉得

3
00:00:09,009 --> 00:00:12,009
Michael Feathers的《Dealing Effectively with Legacy Code》

4
00:00:12,012 --> 00:00:17,012
对这一概念的定义比较准确。

5
00:00:17,017 --> 00:00:20,017
我们之前在书中看到的很多关于遗留代码的内容

6
00:00:20,020 --> 00:00:25,020
也都和他有很多相同的观点。他在书中定义到，

7
00:00:25,025 --> 00:00:27,025
Seam指程序中的一些特殊的点，在这些点上

8
00:00:27,027 --> 00:00:31,027
你无需做任何修改就可以达到改动程序行为的目的。

9
00:00:31,031 --> 00:00:34,031
这对于测试是非常有帮助的，因为单元测试中

10
00:00:34,034 --> 00:00:37,034
非常重要的一件事就是将依赖于其他部分

11
00:00:37,037 --> 00:00:40,037
的代码段落独立出来。通过之前的例子

12
00:00:40,040 --> 00:00:43,040
我们了解到，假设我们已经在Movie模型中

13
00:00:43,043 --> 00:00:47,043
实现了find_in_tmdb方法，可能会发生这样一件事，

14
00:00:47,047 --> 00:00:51,047
我们不再需要创建一个seam

15
00:00:51,051 --> 00:00:53,051
去“假装”这个方法还没有实现。

16
00:00:53,053 --> 00:00:56,053
因为代码其实已经都实现了。但其实，

17
00:00:56,056 --> 00:00:59,056
真正需要seam并不是因为一部分代码还没有实现，

18
00:00:59,059 --> 00:01:02,059
而是因为如果这段代码是不完整的，

19
00:01:02,062 --> 00:01:04,062
或者有人曾经修改过这段代码，那这个测试就可能失败。

20
00:01:04,064 --> 00:01:08,064
Seam真正的作用就是即使这段代码与其他有问题的代码相关联，

21
00:01:08,068 --> 00:01:10,068
我们仍可以通过加入seam将其独立出来。

22
00:01:10,070 --> 00:01:14,070
下面我们来看一个例子，

23
00:01:14,074 --> 00:01:18,074
Should_receive是一个方法，我们用Ruby中的开放类

24
00:01:18,078 --> 00:01:24,078
来创建一个seam将他独立出来。

25
00:01:24,084 --> 00:01:28,084
每次测试过后，Rspec都会重置所有的seam

26
00:01:28,088 --> 00:01:30,088
像我们之前做的一样，我们为了监控

27
00:01:30,090 --> 00:01:33,090
Movie类中并不存在的一个方法而临时创建了一个seam，

28
00:01:33,093 --> 00:01:37,093
假设这个方法已经实现但我仍然监控他。

29
00:01:37,097 --> 00:01:40,097
当下次在运行测试用例时，

30
00:01:40,100 --> 00:01:46,100
这个seam就会被移除掉。

31
00:01:46,106 --> 00:01:48,106
这意味着只要测试是希望实现监控，

32
00:01:48,108 --> 00:01:51,108
我都需要重新建立一个seam，这不困难。

33
00:01:51,111 --> 00:01:54,111
我们知道有办法可以在同一时间运行很多测试。

34
00:01:54,114 --> 00:01:57,114
重要的就是我们能通过这样的方式保持每个测试的部分都独立。

35
00:01:57,117 --> 00:02:00,117
在一个指定的测试中，我们可以指明

36
00:02:00,000 --> 00:02:03,120
“我需要替代那些有依赖性的部分”或

37
00:02:03,123 --> 00:02:06,123
“我需要一些可控的部分，

38
00:02:06,126 --> 00:02:08,126
因为这能够让我得测试结果可预测”

39
00:02:08,128 --> 00:02:10,128
这其实就是一些有独立性的

40
00:02:10,130 --> 00:02:15,130
并且可重复的对测试有利的东西。

41
00:02:15,135 --> 00:02:17,135
我们已经知道我们可以编写…我们编写的测试还不能通过，

42
00:02:17,137 --> 00:02:21,137
因为虽然我们描述了这个控制器相关的功能，

43
00:02:21,141 --> 00:02:23,141
但我们已经清空了控制器的方法。这里什么都没有，那么实现描述功能

44
00:02:23,143 --> 00:02:26,143
最少需要多少代码呢？我们要记得

45
00:02:26,146 --> 00:02:28,146
我们的目标是我们用尽量少的代码让测试通过，

46
00:02:28,148 --> 00:02:31,148
能够从状态“红”到状态“绿”

47
00:02:31,151 --> 00:02:34,151
我们认为控制器方法应该调用

48
00:02:34,154 --> 00:02:38,154
Movie类中的find_in_tmdb，

49
00:02:38,158 --> 00:02:42,158
那就让我们实现它。

50
00:02:42,162 --> 00:02:51,162
我是这样修改控制器方法的

51
00:02:51,171 --> 00:02:54,171
我在这里加了一行代码，实现测试用例描述的事

52
00:02:54,174 --> 00:02:59,174
他调用了find_in_tmdb方法，参数就是搜索词。

53
00:02:59,179 --> 00:03:01,179
现在可能有人会问“有什么实质的内容在这里进行了测试么？”

54
00:03:01,181 --> 00:03:05,181
是的。在这里我做了这样一个假设：

55
00:03:05,185 --> 00:03:09,185
搜索词中就包含了电影的名字，

56
00:03:09,189 --> 00:03:12,189
我们就把这个作为调用find_in_TMDb时传递的参数。

57
00:03:12,192 --> 00:03:15,192
如果我在测试用例中模拟的提交不符合这个，

58
00:03:15,195 --> 00:03:16,195
或者我误用了外部域的名字或类似错误，

59
00:03:16,196 --> 00:03:20,196
那么这样简单地测试可以帮助找到这些很明显的错误。

60
00:03:20,200 --> 00:03:23,200
即使我们没有实现movie中find_in_tmbd这个方法，这个测试还是可实现的。

61
00:03:23,203 --> 00:03:27,203
是的，我们还没有实现这个find_in_TMDb方法。

62
00:03:27,207 --> 00:03:29,207
但重要的是，我们验证了之前的一些想法。

63
00:03:29,209 --> 00:03:36,209
我们其实已经做了很多。

64
00:03:36,216 --> 00:03:40,216
我们学习了spec

65
00:03:40,220 --> 00:03:42,220
这个过程引导了我们去编写控制器的代码。

66
00:03:42,222 --> 00:03:44,222
他让我们去思考控制器需要去做些什么，

67
00:03:44,224 --> 00:03:48,224
让我们去思考控制器会和

68
00:03:48,228 --> 00:03:50,228
其他哪些方法有依赖关系。

69
00:03:50,230 --> 00:03:53,230
在这个例子中，他和其他的方法和模型都有联系，

70
00:03:53,233 --> 00:03:57,233
即使与他相关的其他的方法和模型都已经实现，

71
00:03:57,237 --> 00:03:59,237
为了进行测试，我们仍可以在控制器和模型之间

72
00:03:59,239 --> 00:04:01,239
找到一个衔接点，创建一个seam，

73
00:04:01,241 --> 00:04:05,241
把我们想要测试的代码部分

74
00:04:05,245 --> 00:04:08,245
从其他代码中独立出来。

75
00:04:08,248 --> 00:04:10,248
还有一点我们需要强调的就是，

76
00:04:10,250 --> 00:04:15,250
我们还没有实现find_in_tmdb这个方法，这个方法会有返回值。

77
00:04:15,255 --> 00:04:22,255
目前来说，我们只是调用它

78
00:04:22,262 --> 00:04:25,262
我们并没有明确调用它之后会返回什么

79
00:04:25,265 --> 00:04:27,265
我们想要用尽量少的代码让测试通过，

80
00:04:27,267 --> 00:04:30,267
但是现在我们还不是实际要编写代码。

81
00:04:30,270 --> 00:04:37,270
我们之后会再提到这一点。

82
00:04:37,277 --> 00:04:40,277
事实上，为了教学我举了一个非常简单的例子，

83
00:04:40,280 --> 00:04:42,280
因为我想让大家知道这么一点：

84
00:04:42,282 --> 00:04:46,282
一个测试和一个行为应该是一一对应的。

85
00:04:46,286 --> 00:04:48,286
在这个例子中这个行为就是控制器调用find_in_tmdb方法。

86
00:04:48,288 --> 00:04:53,288
问题就是，find_in_tmdb这个方法是不是应该有返回值呢？

87
00:04:53,293 --> 00:04:57,293
如果有返回值的话，那些数据会发生什么呢？

88
00:04:57,297 --> 00:04:58,297
我们还没有讨论过这个问题，但这并不代表find_in_tmdb方法的返回值不重要。

89
00:04:58,298 --> 00:05:02,298
而这些应该是在测试find_in_tmdb

90
00:05:02,302 --> 00:05:05,302
这部分代码中着重考虑的。

91
00:05:05,305 --> 00:05:08,305
如果确实有返回值那么会发生什么呢？

92
00:05:08,308 --> 00:05:11,308
也就是说当我们创建视图时会发生什么呢？

93
00:05:11,311 --> 00:05:14,311
调用模型的目的就是生成视图中需要展示的信息，

94
00:05:14,314 --> 00:05:17,314
我们一会就会来回答这个问题。

95
00:05:17,317 --> 00:05:20,317
现在先让我们会总结一下。

96
00:05:20,320 --> 00:05:24,320
我们将列举可以测试的内容：我们可以说

97
00:05:24,324 --> 00:05:29,324
“某些对象会被其他方法调用，”

98
00:05:29,329 --> 00:05:33,329
并且我们可以规定哪些参数应该传递进来。

99
00:05:33,333 --> 00:05:36,333
在这个例子中，这一点的确十分重要。

100
00:05:36,336 --> 00:05:38,336
关注这一点的原因是因为我们想要测试的是，

101
00:05:38,338 --> 00:05:41,338
控制器需要从用户获取到数据

102
00:05:41,341 --> 00:05:44,341
并将数据传递到对应的模型中去。

103
00:05:44,344 --> 00:05:47,344
在我们之前的例子中，我们不仅关注find_in_tmdb是否被调用

104
00:05:47,347 --> 00:05:51,347
我们还关注会传递什么参数

105
00:05:51,351 --> 00:05:54,351
这两点都和他调用的模型方法相关，

106
00:05:54,354 --> 00:05:57,354
之后模型方法会连接数据库并进行数据处理。

107
00:05:57,357 --> 00:06:00,357
还有一些其他的例子，我们只关注这两点中其中的一项

108
00:06:00,000 --> 00:06:03,360
例如，如果一个方法没有任何参数，

109
00:06:03,363 --> 00:06:07,363
那么我只关注这个方法是否被调用。

110
00:06:07,367 --> 00:06:09,367
或者因为其他的一些原因，这个测试用例就只关注控制流

111
00:06:09,369 --> 00:06:13,369
而不关注数据流，我们就不需要关注传递的参数。

112
00:06:13,373 --> 00:06:16,373
这意味着只要正确的方法被调用了，

113
00:06:16,376 --> 00:06:19,376
不论传递什么参数，测试都会通过。

114
00:06:19,379 --> 00:06:22,379
我们还有很多东西需要学习，

115
00:06:22,382 --> 00:06:26,382
关于测试中我们如何细化到具体的某一个点，

116
00:06:26,386 --> 00:06:29,386
什么时间应该发生，和如何实现代码

117
00:06:29,389 --> 00:06:34,389
最终通过我们的测试。

118
00:06:34,394 --> 00:06:36,394
现在我们都达成了共识。最终，

119
00:06:36,396 --> 00:06:40,396
我们会实现find_in_tmdb方法。

120
00:06:40,400 --> 00:06:43,400
实现之后呢？我们可以调用实际实现的

121
00:06:43,403 --> 00:06:46,403
find_in_TMDb方法，而不再需要调用should_recerive这个方法。

122
00:06:46,406 --> 00:06:50,406
我们只需要确保实际方法的调用接口和

123
00:06:50,410 --> 00:06:52,410
之前为了测试写的should_receive是一样的。

124
00:06:52,412 --> 00:06:56,412
我们还是需要seam，但是

125
00:06:56,416 --> 00:06:59,416
看起来会有些不同，因为当我们实际实现时

126
00:06:59,419 --> 00:07:02,419
他的调用接口会和之前有一些区别。

127
00:07:02,422 --> 00:07:05,422
或者我们可以直接删除整个的测试用例

128
00:07:05,425 --> 00:07:09,425
由于find_in_tmdb这个方法已经实现了，

129
00:07:09,429 --> 00:07:15,429
这个测试用例也就可以删除了

130
00:07:15,435 --> 00:07:17,435
好好思考一下吧

