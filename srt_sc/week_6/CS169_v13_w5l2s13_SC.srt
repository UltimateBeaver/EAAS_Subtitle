1
00:00:00,000 --> 00:00:02,000
回想起来，我曾想到本章叫“远大前程”会更有趣，

2
00:00:02,002 --> 00:00:05,002
跟经典小说的主题一样

3
00:00:05,005 --> 00:00:08,005
但我没这么做，那么，本章到底有怎样的前程预期呢。

4
00:00:08,008 --> 00:00:13,008
我们来快速回顾下， 

5
00:00:13,013 --> 00:00:16,013
我们学到了哪里，将要进一步深入学些什么。

6
00:00:16,016 --> 00:00:19,016
我们试着描画出预期，促进代码开发。

7
00:00:19,019 --> 00:00:22,019
我们已经展示了控制器方法相关的一个简单例子

8
00:00:22,022 --> 00:00:25,022
我们发现，即使当我们要用到

9
00:00:25,025 --> 00:00:28,025
其他模式和其他类，即使这些

10
00:00:28,028 --> 00:00:32,028
模式技术层面上不存在，我们也可以围绕它们设定预期，

11
00:00:32,032 --> 00:00:34,032
在实质地创建出一个要调用的stub（存根），

12
00:00:34,034 --> 00:00:38,034
满足控制器代码性能所需。

13
00:00:38,038 --> 00:00:41,038
我们现在要看些其他例子， 

14
00:00:41,041 --> 00:00:44,041
尝试打破我们正在测试的事物，

15
00:00:44,044 --> 00:00:47,044
和它所依赖或所共同运作的其他事物， 

16
00:00:47,047 --> 00:00:51,047
即一般所称的合作者，之间的依赖性

17
00:00:51,051 --> 00:00:54,051
我们对付依赖性的杀手锏，是一种程序框架，

18
00:00:54,054 --> 00:00:57,054
你可以通过它回应用程序运作， 

19
00:00:57,057 --> 00:01:01,057
而不用编辑该应用程序的源代码。我们如果继续讨论案例，我们会问， 

20
00:01:01,061 --> 00:01:04,061
“接收到搜索表单后，控制器方法怎样操作？”

21
00:01:04,064 --> 00:01:06,064
我们会说，“它应该调用一种我们未曾编写好的方法，

22
00:01:06,066 --> 00:01:10,066
呼入TMDb,并搜索电影。”

23
00:01:10,070 --> 00:01:12,070
很顺利，我们就这么通过了。需注意的是，我们用最少的工作量通过了。

24
00:01:12,072 --> 00:01:16,072
实际上，我们并没有编写该方法，

25
00:01:16,076 --> 00:01:18,076
我们只需验证，该方法如果存在，则控制器指令

26
00:01:18,078 --> 00:01:21,078
会调用它。让我们进入到下一个小节，这一段

27
00:01:21,081 --> 00:01:24,081
更有价值，内容这么说的，“假设找到了匹配项，

28
00:01:24,084 --> 00:01:28,084
它会选择一个名为‘搜索结果’的新视图以显示它找到的匹配项，

29
00:01:28,088 --> 00:01:31,088
而这个视图我们并未创建。 ”

30
00:01:31,091 --> 00:01:35,091
这种情况下该做什么？我们继续专注于

31
00:01:35,095 --> 00:01:38,095
程序主逻辑。Step3是令人沮丧的路径参数，

32
00:01:38,098 --> 00:01:44,098
但我们仍专注于主逻辑。

33
00:01:44,104 --> 00:01:46,104
它应该选择“搜索结果”视图来显示匹配项。

34
00:01:46,106 --> 00:01:50,106
这在实际操作中意味着什么？这实际上意味着两件不同的事。一件是，

35
00:01:50,110 --> 00:01:54,110
进行渲染的正确模板应该是

36
00:01:54,114 --> 00:01:58,114
搜索结果模板。记不记得上一次，我

37
00:01:58,118 --> 00:02:01,118
为搜索结果创建了一个空白视图，里面什么东西都没有，

38
00:02:01,121 --> 00:02:04,121
只是一个空的Haml文件。

39
00:02:04,124 --> 00:02:06,124
这样，程序在结束时，可以对一些视图进行渲染。

40
00:02:06,126 --> 00:02:10,126
你可能会想，在这种情况下，

41
00:02:10,130 --> 00:02:12,130
一个控制器动作结束时，去寻找一个有名字和内容的视图，

42
00:02:12,132 --> 00:02:15,132
这不就是Rails的一个内置功能嘛？

43
00:02:15,135 --> 00:02:17,135
为什么你会给某些好像只是框架组成部分的东西编写一个测试案例？

44
00:02:17,137 --> 00:02:20,137
事实上，这样做没问题。

45
00:02:20,140 --> 00:02:24,140
但是你们也知道，即使在前面讲座中我们提到的

46
00:02:24,144 --> 00:02:28,144
Rotten Potatoes这样简单案例中， 

47
00:02:28,148 --> 00:02:30,148
动作有时没有完成自身视图渲染，

48
00:02:30,150 --> 00:02:33,150
有时候它最后重定向到其他地方。

49
00:02:33,153 --> 00:02:37,153
一个指令，如果它成功了，很容易觉得它渲染了某视图，

50
00:02:37,157 --> 00:02:40,157
但如果它失败或者它所依赖的东西可能出了错，

51
00:02:40,160 --> 00:02:42,160
那它可能渲染了一个不同的视图，也可能重定向到另一个指令。

52
00:02:42,162 --> 00:02:45,162
对控制器模式，你要测试的是，

53
00:02:45,165 --> 00:02:49,165
它是否最终操作正确？

54
00:02:49,169 --> 00:02:52,169
想进行测试很合理。

55
00:02:52,172 --> 00:02:55,172
在这种情况下，我们现在只谈论主逻辑，

56
00:02:55,175 --> 00:02:57,175
程序主逻辑会代替Rails，

57
00:02:57,177 --> 00:03:00,177
去寻找一个视图。

58
00:03:00,000 --> 00:03:04,180
我们不需要反复讨论它会调用呢还是会选择正确模板，

59
00:03:04,184 --> 00:03:06,184
因为我们刚刚测试过程序框架。

60
00:03:06,186 --> 00:03:09,186
为什么要了解这些类型的测试在你们的应用程序中如何运作，

61
00:03:09,189 --> 00:03:11,189
理由通常很复杂。

62
00:03:11,191 --> 00:03:15,191
控制器动作根据其执行过程中发生的情况，可能选择

63
00:03:15,195 --> 00:03:18,195
多个模板中的一个来渲染。

64
00:03:18,198 --> 00:03:21,198
我们要说的是第二件事是，假设该模板存在，

65
00:03:21,201 --> 00:03:25,201
那么该模板应该有匹配的电影列表，

66
00:03:25,205 --> 00:03:27,205
这样它可以把这些电影通过某些方式显示给用户看。

67
00:03:27,207 --> 00:03:30,207
最终的目标是在TMDb中设法找到匹配电影。

68
00:03:30,210 --> 00:03:34,210
这实际上是两种不同的参数，我们可以

69
00:03:34,214 --> 00:03:37,214
采取我们之前同样的做法。每个参数可以获得各自的代码块，

70
00:03:37,217 --> 00:03:40,217
我们还要了解什么样的预期架构合适。

71
00:03:40,220 --> 00:03:43,220
这就像是，应该传达一个

72
00:03:43,223 --> 00:03:46,223
调用另一个类的某一方法的概念。

73
00:03:46,226 --> 00:03:48,226
现在我们就会使用新的名叫“should”的预期架构，

74
00:03:48,228 --> 00:03:51,228
这个架构是基本上...基于匹配程序。

75
00:03:51,231 --> 00:03:54,231
我会设定一个对象，而且我会保证

76
00:03:54,234 --> 00:03:57,234
目标对象具有一定的属性。

77
00:03:57,237 --> 00:04:00,237
我可以检查许多内置属性，

78
00:04:00,000 --> 00:04:03,240
你再看看测试案例所附的作业，

79
00:04:03,243 --> 00:04:06,243
简单的属性就是，对象应该等于什么。

80
00:04:06,246 --> 00:04:09,246
如果对象是一个字符串，你可以把它跟另一个字符串相比。

81
00:04:09,249 --> 00:04:11,249
如果对象是一个数字，你可以看它与其他一些数字相比是大还是小。

82
00:04:11,251 --> 00:04:14,251
这些都是简单的例子，说的是仅有一个属性的对象，

83
00:04:14,254 --> 00:04:17,254
但我们会发现，对象还可以有

84
00:04:17,257 --> 00:04:19,257
许多其他有趣的属性，你可以

85
00:04:19,259 --> 00:04:22,259
自定义匹配程序。这就像做Cucumber测试时，

86
00:04:22,262 --> 00:04:25,262
设定一个对针对你的应用程序的域语言。

87
00:04:25,265 --> 00:04:29,265
在做RSpec功能和单元测试时，你会发现

88
00:04:29,269 --> 00:04:33,269
你可以让你自己的匹配程序

89
00:04:33,273 --> 00:04:36,273
对应你的应用程序中的模型和控制器，

90
00:04:36,276 --> 00:04:39,276
整体上使你的测试案例更好处理和编写。

91
00:04:39,279 --> 00:04:42,279
让我们来看看“should(应该)”与“should not（不应该）”的案例。

92
00:04:42,282 --> 00:04:45,282
一个匹配程序将某一测试应用于接收端,

93
00:04:45,285 --> 00:04:50,285
我们可以看的案例很多，其中一些

94
00:04:50,290 --> 00:04:53,290
已经在作业里出现过。简单的例子比如， 

95
00:04:53,293 --> 00:04:56,293
我们获知了某一对象的计数。我们可以说， “计数应等于5”。

96
00:04:56,296 --> 00:05:00,296
Should实际上负责什么？它观察对象，

97
00:05:00,000 --> 00:05:04,300
将模块结果运用于对象，

98
00:05:04,304 --> 00:05:06,304
用5做参数，将计数发给equals方法。

99
00:05:06,306 --> 00:05:10,306
我们再看早先的一个例子，如果使用{语法糖衣}，

100
00:05:10,310 --> 00:05:14,310
如此次调用一样省去括号并提取{糖分}，

101
00:05:14,314 --> 00:05:18,314
使小于，我们可以输入， 

102
00:05:18,318 --> 00:05:23,318
“如此标注，5应小于7。” 5应是奇数。

103
00:05:23,323 --> 00:05:27,323
这怎么行得通？RSpec有个常规，

104
00:05:27,327 --> 00:05:32,327
如果匹配条件始于BE_ ，它会寻找一个

105
00:05:32,332 --> 00:05:35,332
可以被原始接收端调用的模式标注。

106
00:05:35,335 --> 00:05:39,335
一般在这种情况下，它会对“5”调用奇数问题标注方法，

107
00:05:39,339 --> 00:05:42,339
并期待结果为true(真)。

108
00:05:42,342 --> 00:05:46,342
这又是一个......一个“method missing (方法缺失)”的好用法

109
00:05:46,346 --> 00:05:50,346
因为它允许编写测试案例来表达实际预期,

110
00:05:50,350 --> 00:05:52,350
用准标准程序或英语都可以。 

111
00:05:52,352 --> 00:05:55,352
来自世界各地的你们可以自由使用

112
00:05:55,355 --> 00:05:58,355
准标准程序或选择一国语言。

113
00:05:58,358 --> 00:06:01,358
我用的是英语。我们也可以这样说， “结果应包含。”

114
00:06:01,361 --> 00:06:06,361
谁要调用include（包含）编辑？我们知道， 

115
00:06:06,366 --> 00:06:09,366
include（包含）是enumerable（枚举）模块提供给你的多种方法之一。

116
00:06:09,369 --> 00:06:13,369
一般程序员会预期经过enumerable处理，

117
00:06:13,373 --> 00:06:16,373
或者使用include函数得到结果。

118
00:06:16,376 --> 00:06:20,376
程序会将include?调用在任何接收端上。

119
00:06:20,380 --> 00:06:23,380
依据政府关门的精神，我觉得

120
00:06:23,383 --> 00:06:27,383
我不得不include这样一个例子。

121
00:06:27,387 --> 00:06:32,387
这在语法上可能是说得通的。如果我的应用程序真的参与了

122
00:06:32,392 --> 00:06:35,392
建模关系和合作，

123
00:06:35,395 --> 00:06:39,395
我可以自定义自己的RSpec匹配程序，

124
00:06:39,399 --> 00:06:42,399
让它可以应用于某一接收端，还可以携带一个参数， 

125
00:06:42,402 --> 00:06:46,402
还能做对我定义的合作进行任何所需的检测。

126
00:06:46,406 --> 00:06:48,406
在这种情况下，匹配程序将被调用......顺便说一下，

127
00:06:48,408 --> 00:06:51,408
它在这种情况下大概会失败。很遗憾，就是这么讽刺，

128
00:06:51,411 --> 00:06:56,411
但事实就是如此。我想传达的不仅是一些

129
00:06:56,416 --> 00:06:59,416
要测试的基本情况，我可以

130
00:06:59,419 --> 00:07:02,419
创建一个跟匹配程序协作的模块，汇总所有逻辑。

131
00:07:02,422 --> 00:07:05,422
为什么我要这样做？因为现在测试的目的是自我描述。

132
00:07:05,425 --> 00:07:08,425
我只要看看测试案例中的代码，

133
00:07:08,428 --> 00:07:11,428
就可以推断出开发者想做什么，

134
00:07:11,431 --> 00:07:16,431
他们正在努力创建的东西哪些是跟这些对象有关？

135
00:07:16,436 --> 00:07:18,436
这里有部分简单形式，如果你浏览过家庭作业说明，

136
00:07:18,438 --> 00:07:20,438
你会看到所有这些形式的例子。还有

137
00:07:20,440 --> 00:07:26,440
should not（不应该）的一个例子，它颠覆了测试的意义。我们知道，

138
00:07:26,446 --> 00:07:29,446
当你将它和Rail一起使用时，RSpec会增加额外的匹配程序。

139
00:07:29,449 --> 00:07:32,449
这里有基础匹配程序也有高端匹配程序。

140
00:07:32,452 --> 00:07:35,452
这些只是RSpec基本核心的部分，

141
00:07:35,455 --> 00:07:38,455
还有匹配程序，其中一个我们马上要要看到，

142
00:07:38,458 --> 00:07:41,458
专门简化Rails开发。

143
00:07:41,461 --> 00:07:44,461
其中，我们第一个将要看到的

144
00:07:44,464 --> 00:07:48,464
是这一个。

145
00:07:48,468 --> 00:07:53,468
结果应该渲染模板。这是什么意思？这意味着，如果你调用一个

146
00:07:53,473 --> 00:07:56,473
控制器指令，调用该控制器指令的结果是，

147
00:07:56,476 --> 00:08:00,476
程序会找到并选择一个叫“搜索TMDb”模板,

148
00:08:00,000 --> 00:08:03,480
并试图渲染该模板。

149
00:08:03,483 --> 00:08:06,483
我们有没有创建模板，都不要紧。再次强调，

150
00:08:06,486 --> 00:08:08,486
我们在此唯一关心的事就是控制器是否在运作，

151
00:08:08,488 --> 00:08:11,488
所以我们只在意控制器是否

152
00:08:11,491 --> 00:08:14,491
决定做出正确的选择。渲染操作是否正确，

153
00:08:14,494 --> 00:08:17,494
取决于视图子系统。

154
00:08:17,497 --> 00:08:20,497
这里的特殊测试不涉及这个。我们只检查

155
00:08:20,500 --> 00:08:23,500
控制器动作是否如预期操作。

156
00:08:23,503 --> 00:08:27,503
搜索TMDb之后，大家可以注意一下回应法（response method）， 

157
00:08:27,507 --> 00:08:31,507
这是安装RSpec时针对Rails附加的方法，

158
00:08:31,511 --> 00:08:34,511
用于返回控制器的回应对象。

159
00:08:34,514 --> 00:08:37,514
回应对象封装自己的内容，

160
00:08:37,517 --> 00:08:41,517
我要做什么来把回应传送给请求？

161
00:08:41,521 --> 00:08:44,521
你可以对回应对象调用模板渲染。

162
00:08:44,524 --> 00:08:47,524
这正是渲染模板匹配程序的目的。

163
00:08:47,527 --> 00:08:52,527
现在，我们有点跑题了。

164
00:08:52,532 --> 00:08:55,532
这是我们在之前的课堂中建立的第一个spec，

165
00:08:55,535 --> 00:08:57,535
而我们正在检查它是否调用了模型方法。在这里，

166
00:08:57,537 --> 00:09:03,537
我们还检查另外一件事，那就是， 

167
00:09:03,543 --> 00:09:06,543
是否应该选择“搜索结果”模板进行渲染。

168
00:09:06,546 --> 00:09:10,546
我在做什么？这个stub的用途是什么？令人困惑。之前，

169
00:09:10,550 --> 00:09:14,550
我谈到过在TMDb中调用movie should receive find。我肯定，

170
00:09:14,554 --> 00:09:19,554
如果该方法没有被调用，就会出错。到这里，

171
00:09:19,559 --> 00:09:21,559
stub实际上只是一种说法，“如果有人想要

172
00:09:21,561 --> 00:09:25,561
调用此模式，什么都不要做，返回nil（零），

173
00:09:25,565 --> 00:09:28,565
不要检查参数。不要提示错误。忽略它。

174
00:09:28,568 --> 00:09:31,568
假装什么都没有发生。“为什么在这个测试中，我觉得

175
00:09:31,571 --> 00:09:34,571
这样没问题，而在之前的测试中，

176
00:09:34,574 --> 00:09:38,574
我坚持认为，如果没有调用这个stub，就会产生错误？

177
00:09:38,578 --> 00:09:41,578
我又在有点夸张地证明一个教学观点，

178
00:09:41,581 --> 00:09:45,581
那就是，每一种测试案例，每个作为参数的IT码块，

179
00:09:45,585 --> 00:09:48,585
都应该仅测试一件事。

180
00:09:48,588 --> 00:09:51,588
我们测试的是它是否应该调用模型方法，我们已经这样做了。

181
00:09:51,591 --> 00:09:55,591
这个测试主要目的就是如此。在这个测试中， 

182
00:09:55,595 --> 00:09:57,595
我们检查它是否选择渲染搜索结果模板。

183
00:09:57,597 --> 00:10:01,597
尽管我们知道

184
00:10:01,601 --> 00:10:05,601
双引号中它确实需要在TMDb中调用find(查询)，从技术上讲， 

185
00:10:05,605 --> 00:10:09,605
这个测试并不在意这一事实。测试只关心这样的结果，

186
00:10:09,609 --> 00:10:12,609
即，我们顺利得到了回应之后， 

187
00:10:12,612 --> 00:10:15,612
回应应当表明我们会选对模板进行渲染。

188
00:10:15,615 --> 00:10:18,615
再次强调，对于每一个单独的测试，我们必须十分清楚什么是必须检查的

189
00:10:18,618 --> 00:10:22,618
还有什么是我们不必检查的， 

190
00:10:22,622 --> 00:10:24,622
一条很重要的基础概念是，一个行为要有一个针对性的测试。

191
00:10:24,624 --> 00:10:27,624
测试很简单。你可以

192
00:10:27,627 --> 00:10:30,627
对一个简单的应用程序进行成千上万次测试， 

193
00:10:30,630 --> 00:10:33,630
所以不要将不同类型行为的多个检查混在一起测试。

194
00:10:33,633 --> 00:10:42,633
这就是它的样子。在这种情况下， 

195
00:10:42,642 --> 00:10:45,642
视图至少是一个空文件，不能没有，可以没有内容。

196
00:10:45,645 --> 00:10:50,645
因为该视图必须至少...创建后它必须有一个

197
00:10:50,650 --> 00:10:53,650
占位符，这就是为什么

198
00:10:53,653 --> 00:10:56,653
我们把控制器测试当作功能测试。

199
00:10:56,656 --> 00:11:00,656
当你考虑时，当我们在测试中模拟传递时，

200
00:11:00,000 --> 00:11:03,660
这就在运用路由子系统，

201
00:11:03,663 --> 00:11:06,663
因为它会标好一个指令的路径。

202
00:11:06,666 --> 00:11:09,666
运用子系统，可以获取数据，并用于参数。

203
00:11:09,669 --> 00:11:12,669
这应该是Rails的部分功能。

204
00:11:12,672 --> 00:11:16,672
但依然要执行。由于控制器要求调用某一模型，

205
00:11:16,676 --> 00:11:19,676
这就要充分运用控制器方法，以确保

206
00:11:19,679 --> 00:11:22,679
其他的事物被调用，运用

207
00:11:22,682 --> 00:11:25,682
控制器功能去找出哪些视图要渲染。

208
00:11:25,685 --> 00:11:28,685
它实际上不只是一个单元测试。它实际上

209
00:11:28,688 --> 00:11:31,688
触及的不只是控制器指令中代码行数问题。

210
00:11:31,691 --> 00:11:34,691
我们认为它是一个功能测试，对一些模块进行测试，

211
00:11:34,694 --> 00:11:37,694
突破一些障碍，

212
00:11:37,697 --> 00:11:39,697
但一般还是局限于规定测试内容的范围。

213
00:11:39,699 --> 00:11:43,699
我们来补充一点，我们知道在测试中怎么操作。

214
00:11:43,703 --> 00:11:46,703
我们知道了should receive（应接收）。现在，我们懂了，

215
00:11:46,706 --> 00:11:49,706
一个对象应匹配一定的条件，

216
00:11:49,709 --> 00:11:52,709
一些内置于Rspec的条件， 

217
00:11:52,712 --> 00:11:55,712
还有一些Rail的具体条件，比如， 

218
00:11:55,715 --> 00:12:00,715
条件匹配的回应对象必须要有，比如说渲染模板。

219
00:12:00,000 --> 00:12:02,720
我们于是要问另一个问题，

220
00:12:02,722 --> 00:12:07,722
问完后我要做个游戏。

221
00:12:07,727 --> 00:12:11,727
这些其中哪一个“should（应该）”或“should not（不应该）”对其使用无效？

222
00:12:11,731 --> 00:12:14,731
我们可以说，诸如“结果不应该为空。”我们

223
00:12:14,734 --> 00:12:17,734
可以说，“五应该是space strip (空白删除)的结果。结果不应该

224
00:12:17,737 --> 00:12:20,737
匹配该正则表达式” ，或者难道

225
00:12:20,740 --> 00:12:25,740
这些都合理,均适用于调用“should”或“should not”?

226
00:12:25,745 --> 00:12:27,745
为了这个问题， 

227
00:12:27,747 --> 00:12:31,747
Should和 should not可以互换。

