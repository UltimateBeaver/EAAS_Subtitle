1
00:00:00,000 --> 00:00:15,000
让我们来投票吧，红色和橘色，票数不是很平均

2
00:00:15,015 --> 00:00:18,015
让我们再投一次，再投一次，再投一次，再投一次。好了。

3
00:00:18,018 --> 00:00:23,018
大部分的人选择了红色。

4
00:00:23,023 --> 00:00:27,023
让我们来看一下这个选项。

5
00:00:27,027 --> 00:00:30,027
我们是否可以直接调用实际的find_in_TMDb方法，而不是调用should_receive的方法呢？

6
00:00:30,030 --> 00:00:35,030
我们可以这样做，但这样的话我们就把控制器行为和最终find_in_TMDb运行的行为结合了起来。

7
00:00:35,035 --> 00:00:38,035


8
00:00:38,038 --> 00:00:41,038
这是一个双刃剑。

9
00:00:41,041 --> 00:00:42,041
有一种观点这样认为：如果有人修改了find_in_TMDb导致测试失败，这意味着我们的测试已经做过一些假定关于该如何调用实际的方法。

10
00:00:42,042 --> 00:00:46,042


11
00:00:46,046 --> 00:00:49,046


12
00:00:49,049 --> 00:00:52,049
如果有人修改了这个方法，那么之前的假设就不成立了。

13
00:00:52,052 --> 00:00:55,052
如果调用了真正使用的find_in_TMDb方法，那么我们立刻就会知道。

14
00:00:55,055 --> 00:00:59,055


15
00:00:59,059 --> 00:01:01,059
这个现象确实会发生，但是对于这个观点我想提出一个反例。

16
00:01:01,061 --> 00:01:04,061
那就是功能和集成测试的作用，现在我们来了解一下。 

17
00:01:04,064 --> 00:01:07,064


18
00:01:07,067 --> 00:01:11,067
单元测试的目标就是缩小测试的代码范围和规格，所以我们是在测试一小段代码的逻辑。

19
00:01:11,071 --> 00:01:14,071


20
00:01:14,074 --> 00:01:17,074
当不停的给每段代码做单元测试时，当测试的单元不断增加以后，我们就不应该再使用seam而开始做集成测试，

21
00:01:17,077 --> 00:01:21,077
并指明seam中的假设已经不成立了。

22
00:01:21,081 --> 00:01:25,081


23
00:01:25,085 --> 00:01:28,085
正如我们了解到的，我们必须做一个权衡。

24
00:01:28,088 --> 00:01:32,088


25
00:01:32,092 --> 00:01:35,092
单元测试和集成测试的一个不同就是测试代码的粒度。

26
00:01:35,095 --> 00:01:38,095


27
00:01:38,098 --> 00:01:41,098
单元测试更细致一些，我们可以做更多的边界测试，但是我们会发现为了做单元测试，

28
00:01:41,101 --> 00:01:44,101
我们不得不加更多的前提条件从而将代码独立出来。

29
00:01:44,104 --> 00:01:46,104


30
00:01:46,106 --> 00:01:49,106
只有通过这样的方法我们才能让测试可控，能测试到所有的可能性。

31
00:01:49,109 --> 00:01:53,109
但我们可能会因为这样而忽略了很多真正重要的东西。

32
00:01:53,113 --> 00:01:56,113
如果有人修改了接口，那么这就会影响到我们。

33
00:01:56,116 --> 00:01:59,116
我们需要专注于某一小部分代码的测试，而且我们会不断地返回头来进行修改。

34
00:01:59,119 --> 00:02:02,119


35
00:02:02,122 --> 00:02:03,122


36
00:02:03,123 --> 00:02:07,123
我们要确保最终实现方法的api和我们测试时的接口是一致的。

37
00:02:07,127 --> 00:02:10,127
尤其是当我们模拟测试的时候，或者当我们为了一段并不存在的代码创建了一个seam的时候，

38
00:02:10,130 --> 00:02:13,130


39
00:02:13,133 --> 00:02:16,133
我们必须想到这段代码是如何工作的和控制器是如何调用它的。

40
00:02:16,136 --> 00:02:19,136


41
00:02:19,139 --> 00:02:20,139


42
00:02:20,140 --> 00:02:23,140
大家需要想到这一点，

43
00:02:23,143 --> 00:02:25,143
但这并不能确保我们想到的就是正确的。

44
00:02:25,145 --> 00:02:27,145
当我们真正去实现这段代码的时候，我们可能会遇到各种各样的情况。

45
00:02:27,147 --> 00:02:30,147
这些都是以后会在应用中实际运行的代码，

46
00:02:30,150 --> 00:02:31,150
有时我们确实需要再返回头来修改我们的测试，因为当时我们做一些假设时是合理的，但这些假设并不能转化为实际的代码。

47
00:02:31,151 --> 00:02:34,151


48
00:02:34,154 --> 00:02:36,154


49
00:02:36,156 --> 00:02:40,156
这些都是非常常见的。

50
00:02:40,160 --> 00:02:43,160
我们还会用seam但我们需要修改他的描述，是他能够和真正的api对应起来。

51
00:02:43,163 --> 00:02:45,163
这才是我真正想要强调的。

52
00:02:45,165 --> 00:02:48,165
我建议删除那些描述因为他不再测试我们关注的内容。

53
00:02:48,168 --> 00:02:52,168
除非他测试的是一段从来不会被调用的死代码，或者这段代码没有任何接口和参数。

54
00:02:52,172 --> 00:02:56,172


55
00:02:56,176 --> 00:02:59,176
所有的测试都是有目的性的。

56
00:02:59,179 --> 00:03:02,179
在我周围写代码的朋友当中，

57
00:03:02,182 --> 00:03:07,182
有这样一句谚语：所有你不处理的或者自动消失的bug，早晚会让你付出代价的。

58
00:03:07,187 --> 00:03:10,187


59
00:03:10,190 --> 00:03:13,190
在测试时我们也要注意，不管测试的目的是想要发现bug或是修复bug，我们要保证这个bug是可复现的。

60
00:03:13,193 --> 00:03:16,193


61
00:03:16,196 --> 00:03:19,196


62
00:03:19,199 --> 00:03:21,199
大约20%左右可复现的bug都可以被回归测试发现并修复。

63
00:03:21,201 --> 00:03:24,201


64
00:03:24,204 --> 00:03:26,204
我们书中引用的一些研究就是专门讨论这点的。

65
00:03:26,206 --> 00:03:30,206
删除一个测试一般来说不是一个明智的选择，

66
00:03:30,210 --> 00:03:32,210
但是随着研发的深入，我们必须要不断回头来修改这些测试。

67
00:03:32,212 --> 00:03:35,212
我知道大家可能会觉得这有些奇怪，可能你们会说

68
00:03:35,215 --> 00:03:38,215
“我都通过了测试，完成了代码，现在我还要再修改代码，修改测试？我已经通过了测试啊”

69
00:03:38,218 --> 00:03:41,218


70
00:03:41,221 --> 00:03:43,221


71
00:03:43,223 --> 00:03:45,223


72
00:03:45,225 --> 00:03:47,225
这个想法是不对的。

73
00:03:47,227 --> 00:03:51,227
测试和代码是紧密相关的。开始我们要写测试，

74
00:03:51,231 --> 00:03:53,231
但当代码被修改后，测试同时也需要修改。

75
00:03:53,233 --> 00:03:57,233
首先我们要写测试用例，

76
00:03:57,237 --> 00:03:58,237
然后我们会实现代码通过所有的测试用例。

77
00:03:58,238 --> 00:04:00,238
这时我们意识到因为一些原因，我们需要修改一些代码，

78
00:04:00,000 --> 00:04:03,240
在这同时我们就需要修改测试用例直到他们匹配了你的代码。

79
00:04:03,243 --> 00:04:06,243


80
00:04:06,246 --> 00:04:09,246
这不仅仅是在测试上添加评论。

81
00:04:09,249 --> 00:04:11,249
也不仅仅是直接从测试上直接删除评论。

82
00:04:11,251 --> 00:04:14,251
我们这样做是有原因的，我们要根据自己的想法不断调整测试用例的功能，

83
00:04:14,254 --> 00:04:17,254


84
00:04:17,257 --> 00:04:19,257
所以不要背离了最初的想法。

