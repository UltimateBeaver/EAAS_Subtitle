1
00:00:00,000 --> 00:00:06,000
好的，来投票，投票表决。错误的说法是……

2
00:00:06,006 --> 00:00:09,006
我们这就来具体分析。大部分人都回答正确。

3
00:00:09,009 --> 00:00:13,009
我猜测有过相当编程经验的人

4
00:00:13,013 --> 00:00:16,013
当然不会选定第三种说法，

5
00:00:16,016 --> 00:00:19,016
即测试可以不必再使用调试器，

6
00:00:19,019 --> 00:00:21,019
当然这么选择是正确的。测试并非可以不再使用调试器。

7
00:00:21,021 --> 00:00:25,021
不过，我希望我告诉大家的是

8
00:00:25,025 --> 00:00:28,025
它可以免除许多对调试器的低效使用。

9
00:00:28,028 --> 00:00:31,028
有时，你的确会百思不得其解，

10
00:00:31,031 --> 00:00:33,031
为什么这么简单的代码不会依照设计意图发挥作用，

11
00:00:33,033 --> 00:00:35,033
这就是调试器一显身手的时候，

12
00:00:35,035 --> 00:00:38,035
不过不建议太频繁地使用调试器。

13
00:00:38,038 --> 00:00:40,038
实际上，大多数调试都应在编写测试失败的形式中进行。

14
00:00:40,040 --> 00:00:44,040
这就是你的漏洞所在。接下来，当你编写代码修复漏洞。

15
00:00:44,044 --> 00:00:47,044
正如我们即将看到的那样，当我们谈及如何修复他人编码的漏洞时，

16
00:00:47,047 --> 00:00:50,047
这实际上是同样的过程。

17
00:00:50,050 --> 00:00:53,050
当我们修复漏洞时，进行遗留代码重构时，

18
00:00:53,053 --> 00:00:56,053
所有这些内容，所有这些理念都会再次出现，其中会涉及你所掌握的测试用例中

19
00:00:56,056 --> 00:00:59,056
需要集中精力修复漏洞的努力目标。

20
00:00:59,059 --> 00:01:01,059
我们将反复看到这些

21
00:01:01,061 --> 00:01:02,061
内容。

