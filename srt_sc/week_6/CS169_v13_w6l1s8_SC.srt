1
00:00:00,000 --> 00:00:06,000
那么，哪些是属于不好的建议呢？来为不好的建议进行首次投票。

2
00:00:06,006 --> 00:00:10,006
好吧，人们要不是把真实想法埋在心里，

3
00:00:10,010 --> 00:00:14,010
要么就在Facebook上都写出来。

4
00:00:14,014 --> 00:00:18,014
我们来简要谈谈为什么在这个案例中蓝色的是正确答案。

5
00:00:18,018 --> 00:00:20,018
那么在单元测试中要尽早并经常做模拟和存根。

6
00:00:20,020 --> 00:00:23,020
这当然是好建议，因为单元测试的全部功能就是要隔离大家所真正关注的代码，

7
00:00:23,023 --> 00:00:26,023
模拟和存根是实现这一点的重要内容。

8
00:00:26,026 --> 00:00:30,026
要以获得较高的单元测试覆盖率为目标。

9
00:00:30,030 --> 00:00:32,030
单元测试的高覆盖率本身没有问题。

10
00:00:32,032 --> 00:00:35,032
可如果大家太看重这一点，以此为目标，那就太糟糕了。

11
00:00:35,035 --> 00:00:37,035
但就其本身而言，这还是个合理的目标，对不对？

12
00:00:37,037 --> 00:00:40,037
如果单元测试的覆盖率是90多的高分，那是值得高兴的事情。

13
00:00:40,040 --> 00:00:42,040
有时，可以在集成测试中，用到存根和模拟。

14
00:00:42,042 --> 00:00:44,042
我们见到过有时大家会这么做，对不对？

15
00:00:44,044 --> 00:00:47,044
如果大家在做测试……如果针对外部服务进行集成测试，

16
00:00:47,047 --> 00:00:50,047
那么这就是存根或者模拟非常合理的完美实例。

17
00:00:50,050 --> 00:00:52,050
大家不会希望

18
00:00:52,052 --> 00:00:55,052
每次运行cucumber场景时都提取TMDB数据库。

19
00:00:55,055 --> 00:00:59,055
提取一次，就会捕捉到结果，

20
00:00:59,059 --> 00:01:01,059
因为是基于运行的站点，所以这是个相当现实的重放功能。

21
00:01:01,061 --> 00:01:04,061
不过我们已经说过，要记住，同样的缺陷也适用于这里的常规测试用例。

22
00:01:04,064 --> 00:01:08,064
具体而言，例如，如果我有一个测试用例，

23
00:01:08,068 --> 00:01:11,068
是对模型存根的单元测试，所有测试都已通过。

24
00:01:11,071 --> 00:01:14,071
现在，有人改变了我存根的模型方法的行为。

25
00:01:14,074 --> 00:01:17,074
他们可以测试自己所做的改变，

26
00:01:17,077 --> 00:01:21,077
可如果我不知道API已经改变，

27
00:01:21,081 --> 00:01:24,081
我的测试中就会对一个不再存在的API作出假设。

28
00:01:24,084 --> 00:01:26,084
那么，我的测试依然会通过，因为我对方法进行了存根。

29
00:01:26,086 --> 00:01:29,086
可是一旦当我确实运行集成测试时，就会失败。

30
00:01:29,089 --> 00:01:32,089
因为现在，大家已经取消了存根，

31
00:01:32,092 --> 00:01:35,092
调用的真实方法和API不再匹配，于是就有了问题！

32
00:01:35,095 --> 00:01:37,095
那么在面向服务体系架构中也会发生同样的事情。

33
00:01:37,097 --> 00:01:41,097
我们会使用TMDB，会针对它提出部分真实的请求。

34
00:01:41,101 --> 00:01:44,101
我们捕捉到输出数据，并输入到虚拟网，

35
00:01:44,104 --> 00:01:47,104
现在TMDB就会改变自己返回输出的方法，

36
00:01:47,107 --> 00:01:51,107
或是它们会改变API的静止行为。

37
00:01:51,111 --> 00:01:53,111
除非大家知道这一情况，并改变了自己的测试以与之匹配，

38
00:01:53,113 --> 00:01:56,113
在这一场景中，所有测试似乎就会通过，

39
00:01:56,116 --> 00:01:58,116
而这是因为大家对最重要的内容进行了模拟。

40
00:01:58,118 --> 00:02:02,118
大家对界面进行了模拟。那么就可以在一定程度上让自己心中有底，

41
00:02:02,122 --> 00:02:04,122
到底该对模拟和存根投入多大精力，

42
00:02:04,124 --> 00:02:08,124
对集成测试该投入多少？当然会需要对此有些重视。

43
00:02:08,128 --> 00:02:10,128
那么，只剩下一条不好的建议，

44
00:02:10,130 --> 00:02:13,130
那就是单元测试会让大家对整体系统的正确性信心更强。

45
00:02:13,133 --> 00:02:15,133
这里不存在更强或不强的信心的问题。这是不同的正确性问题。

46
00:02:15,135 --> 00:02:19,135
是关于代码路径和特殊案例的正确性，

47
00:02:19,139 --> 00:02:22,139
与之相对的是涉及不同信息的跨界面或跨代码路径的正确性。

48
00:02:22,142 --> 00:02:24,142
二者大家都会需要。

