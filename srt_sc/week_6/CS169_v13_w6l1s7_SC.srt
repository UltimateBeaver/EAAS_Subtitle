1
00:00:00,000 --> 00:00:04,000
现在大家基本了解了我称之为测试编写机制的内容。

2
00:00:04,004 --> 00:00:08,004
掌握单元测试，

3
00:00:08,008 --> 00:00:11,008
仅对一种行为进行测试，

4
00:00:11,011 --> 00:00:14,011
对这些测试根据功能性和上下文进行分组，

5
00:00:14,014 --> 00:00:17,014
使用模拟和存根来真正将测试中的行为与合作类隔离，

6
00:00:17,017 --> 00:00:20,017
这些概念都非常不错，都是大家将要反复用到的基本测试概念和理念。

7
00:00:20,020 --> 00:00:23,020
我并不在意

8
00:00:23,023 --> 00:00:25,023
大家所用的语言和框架，

9
00:00:25,025 --> 00:00:28,025
这些都是同样的词汇，适用相同的概念。

10
00:00:28,028 --> 00:00:31,028
这里还有一个适用的概念，即“你何时完成的测试？”

11
00:00:31,031 --> 00:00:35,031
大家要了解何时完成的测试，有一种方法是找到释放时间。

12
00:00:35,035 --> 00:00:38,035
这并非是我确定测试完成时间的最喜欢的方法。

13
00:00:38,038 --> 00:00:42,038
有一种完全静态的粗略方法，

14
00:00:42,042 --> 00:00:45,042
是用测试行数除以代码行数。

15
00:00:45,045 --> 00:00:47,045
有些人可以能意外地发现，

16
00:00:47,047 --> 00:00:51,047
最后得出的结果常常会大于1，

17
00:00:51,051 --> 00:00:53,051
其实应该是比1大。因为测试行数多于编码行数。

18
00:00:53,053 --> 00:00:56,053
不应该过分意外，

19
00:00:56,056 --> 00:00:59,056
因为具体的一段代码……首先，

20
00:00:59,059 --> 00:01:01,059
大家准备测试的那段代码有很多行为。

21
00:01:01,061 --> 00:01:04,061
每个行为都有自己相应的测试。其次，通常一段代码正确的方式只有一种，

22
00:01:04,064 --> 00:01:07,064
而失败的方式却有很多。

23
00:01:07,067 --> 00:01:10,067
大家会想要对可能失败的方式都进行测试。

24
00:01:10,070 --> 00:01:12,070
把这些累计在一起，大家就会意识到

25
00:01:12,072 --> 00:01:15,072
如果测试行数大于代码行数其实也并不意外。

26
00:01:15,075 --> 00:01:17,075
我们需要以多种不同方式运行代码。

27
00:01:17,077 --> 00:01:21,077
对生产系统而言，这一数字……

28
00:01:21,081 --> 00:01:25,081
可以是10的倍数。有个极限示例中，SQLite的测试行数比代码行数 

29
00:01:25,085 --> 00:01:28,085
多1000。

30
00:01:28,088 --> 00:01:30,088
诚然，这是因为需要测试所有的跨平台的特殊情况。

31
00:01:30,090 --> 00:01:33,090
与其要问“我们何时完成测试？”

32
00:01:33,093 --> 00:01:35,093
不如说“我的测试彻底性如何？”

33
00:01:35,095 --> 00:01:37,095
这里有几种不同的观察方法。

34
00:01:37,097 --> 00:01:39,097
今天我们不会介绍正式的方法，这方面内容稍后再说。

35
00:01:39,099 --> 00:01:44,099
我们将说一说覆盖测量，

36
00:01:44,104 --> 00:01:47,104
那么无论大家使用哪些工具，这都依旧适用。

37
00:01:47,107 --> 00:01:51,107
正如学科中的所有工具一样，我们或者可以用出水平，

38
00:01:51,111 --> 00:01:54,111
或者是胡乱误用。来看测量覆盖。

39
00:01:54,114 --> 00:01:57,114
测量这个简单类的测试覆盖率是什么意思呢？

40
00:01:57,117 --> 00:02:01,117
我在这里有两种方法，分别是“fu”和“bar”。

41
00:02:01,121 --> 00:02:04,121
正如大家所见，fu有时会以不同参数调用bar。 

42
00:02:04,124 --> 00:02:09,124
对于本类的测试覆盖，

43
00:02:09,129 --> 00:02:12,129
我们可以使用怎样的不同语句呢？

44
00:02:12,132 --> 00:02:16,132
大家能想到的最简单方法就是调用每种方法。我们至少会调用fu 一次，

45
00:02:16,136 --> 00:02:19,136
我不知道我们会采用if 语句的哪一个分支，

46
00:02:19,139 --> 00:02:22,139
但是至少我们要调用它。

47
00:02:22,142 --> 00:02:26,142
fu 方法中的代码并不完全是死代码。

48
00:02:26,146 --> 00:02:29,146
再提高一个层次，就是我们从每个调用点进行调用。

49
00:02:29,149 --> 00:02:33,149
这是说，例如，我们在调用 bar……

50
00:02:33,153 --> 00:02:37,153
哎呀，这里的重点不大对头。我们需要从两种可能的位置调用bar方法，

51
00:02:37,157 --> 00:02:39,157
并在可能调用的位置调用fu方法。

52
00:02:39,159 --> 00:02:43,159
这就是S1级的覆盖率。

53
00:02:43,163 --> 00:02:47,163
现在来看更有趣的内容……我们来执行每个语句。

54
00:02:47,167 --> 00:02:49,167
执行每个语句会有些麻烦，因为条件语句也可能会按照一条语句计算，

55
00:02:49,169 --> 00:02:53,169
无论大家采用的是哪个分支都是如此。

56
00:02:53,173 --> 00:02:58,173
C0 覆盖至少会开始让大家了解

57
00:02:58,178 --> 00:03:00,178
我的应用行数中有多大比例在测试套件中实际得以执行?

58
00:03:00,000 --> 00:03:04,180
在Ruby中，有个简单的cov gem可以实现这一点，

59
00:03:04,184 --> 00:03:07,184
在后面的作业中大家会用到这一功能。

60
00:03:07,187 --> 00:03:10,187
C1是在此之后的更高一级。

61
00:03:10,190 --> 00:03:13,190
这意味着大家可以使用两个方向的所有分支。

62
00:03:13,193 --> 00:03:17,193
如果有if 语句, 那么大家就至少已经获得一个测试，

63
00:03:17,197 --> 00:03:20,197
这是根据每个if语句的两条路径所做测试。

64
00:03:20,200 --> 00:03:22,200
这样大家就可以看出我们不喜欢嵌套if语句的一个原因，

65
00:03:22,202 --> 00:03:26,202
因为这意味着路径数会出现平方式增加。

66
00:03:26,206 --> 00:03:29,206
这里还有增加判断覆盖的修改版本，

67
00:03:29,209 --> 00:03:32,209
也就是说，如果大家有取决于多于一种表达式的条件语句

68
00:03:32,212 --> 00:03:35,212
就以这个条件语句为例，

69
00:03:35,215 --> 00:03:40,215
如果Y和Z为真，

70
00:03:40,220 --> 00:03:44,220
C1就表示我们已经接受了if,一旦因为……基本上

71
00:03:44,224 --> 00:03:47,224
我们对Y和Z都做了调整，以确保它们实际会对条件的结果产生影响。

72
00:03:47,227 --> 00:03:51,227
这是条件覆盖中更具颗粒化的形式，

73
00:03:51,231 --> 00:03:53,231
因为我们还会关注评估条件的方法，

74
00:03:53,233 --> 00:03:56,233
并确保会导致行为差异的所有不同的评估方法，

75
00:03:56,236 --> 00:03:59,236
都会经过检查。

76
00:03:59,239 --> 00:04:04,239
那么C2就是每条代码路径。

77
00:04:04,244 --> 00:04:08,244
C2极难付诸实际，

78
00:04:08,248 --> 00:04:11,248
因为这意味着大家基本上必须进行充分分析，

79
00:04:11,251 --> 00:04:14,251
来指出哪些输入和条件的组合可以通过代码接触到所有可能的路径。

80
00:04:14,254 --> 00:04:17,254
一般来说，

81
00:04:17,257 --> 00:04:20,257
这比部分其他级别如C1会强多少并无定论，

82
00:04:20,260 --> 00:04:25,260
特别是当大家将单元级覆盖测试和其他种类覆盖相结合时更是如此

83
00:04:25,265 --> 00:04:28,265
大家可以将此应用于哪些测试呢？

84
00:04:28,268 --> 00:04:31,268
基本上可以应用于任何测试。

85
00:04:31,271 --> 00:04:35,271
来看这里的频谱。

86
00:04:35,275 --> 00:04:38,275
在一端，我们有模型规格说明文件，基本上可以对任何内容都进行存根。

87
00:04:38,278 --> 00:04:41,278
我们刚测试了少量的隔离代码，

88
00:04:41,281 --> 00:04:44,281
并准备处理相应的个体行为。

89
00:04:44,284 --> 00:04:46,284
在另一种极限情况下，我们会见到诸如Cucumber 场景等情况，

90
00:04:46,286 --> 00:04:50,286
其中会执行整个应用，但是它们只会触及少量代码路径。

91
00:04:50,290 --> 00:04:54,290
任何一个cucumber 场景都只会触及

92
00:04:54,294 --> 00:04:56,294
全部代码的极小一部分，

93
00:04:56,296 --> 00:05:00,296
并以最小数量的方法运行那部分代码。

94
00:05:00,000 --> 00:05:02,300
接着在其中，我们会有控制器规格说明文件，

95
00:05:02,302 --> 00:05:04,302
即便我们会激发控制器方法，知道它会与模型交互，

96
00:05:04,304 --> 00:05:06,304
知道某些内容可以用于视图。

97
00:05:06,306 --> 00:05:10,306
会有部分测试帮助确定这些非常简单的边界是否也会奏效。

98
00:05:10,310 --> 00:05:13,310
一般而言，在频谱的各端会发生什么呢？

99
00:05:13,313 --> 00:05:16,313
单元测试一般会以非常快的速度运行。

100
00:05:16,316 --> 00:05:20,316
大家也许已经注意到了，Cucumber 场景的速度并不那么快。

101
00:05:20,320 --> 00:05:23,320
单元测试可以有着极好的解析度，

102
00:05:23,323 --> 00:05:26,323
因为大家可以很好地控制模拟和存根，

103
00:05:26,326 --> 00:05:29,326
可以通过需要不常见的条件组的代码执行路径。

104
00:05:29,329 --> 00:05:32,329
大家可以通过模拟和存根对所有内容进行设置，

105
00:05:32,332 --> 00:05:36,332
然而集成级测试的解析度就会相当粗糙。

106
00:05:36,336 --> 00:05:39,336
大家是在就如何刺激应用，编写高级语句。

107
00:05:39,339 --> 00:05:41,339
也就是说大家在测试中设置控制测试进行的任何内容时，

108
00:05:41,341 --> 00:05:44,341
大家基本上

109
00:05:44,344 --> 00:05:47,344
要从黑盒测试的角度来设置，

110
00:05:47,347 --> 00:05:50,347
这一点的难度极大。

111
00:05:50,350 --> 00:05:53,350
那么，这也就说明还是通过低级测试提高覆盖率更为容易。

112
00:05:53,353 --> 00:05:56,353
如果大家发现有语句或方法并未得以执行，

113
00:05:56,356 --> 00:05:59,356
因为可以非常小心地使用模拟和存根，

114
00:05:59,359 --> 00:06:02,359
大家基本上可以手动测试，继续推进，应对这些死角，

115
00:06:02,362 --> 00:06:05,362
但在集成级测试时，这种做法的难度更大。

116
00:06:05,365 --> 00:06:10,365
一般性的规律是，

117
00:06:10,370 --> 00:06:13,370
这说明当大家走到这一步，会进行很多模拟。

118
00:06:13,373 --> 00:06:16,373
大家经常会对类之间的界面进行模拟。

119
00:06:16,376 --> 00:06:18,376
我们曾对控制器和模型类之间的界面进行模拟。

120
00:06:18,378 --> 00:06:21,378
我们曾对控制器和视图间的界面进行模拟，

121
00:06:21,381 --> 00:06:23,381
仅仅是提出这样的问题，“你是否给这个变量赋值？”

122
00:06:23,383 --> 00:06:27,383
相反，未进行到这一步时，大家用到的模拟就会极少，

123
00:06:27,387 --> 00:06:31,387
因此界面非常重要。

124
00:06:31,391 --> 00:06:33,391
真正重要的是大家需要全面地对测试进行思考。

125
00:06:33,393 --> 00:06:36,393
我不知道在美国东部的软件工程课程中是否使用这些词汇。

126
00:06:36,396 --> 00:06:39,396
这里是美国西部的加州，

127
00:06:39,399 --> 00:06:42,399
那么我们在谈到软件时，可以使用“全面”这样的词汇。

128
00:06:42,402 --> 00:06:46,402
有一种极限情况是，“我编过码，尝试过几种浏览器请求，也奏效了。”

129
00:06:46,406 --> 00:06:49,406
很遗憾，如今大多数人进行集成测试时基本也是在这么做。

130
00:06:49,409 --> 00:06:53,409
另一种极限情况也同样糟糕。

131
00:06:53,413 --> 00:06:56,413
“除非我具备100％的C0覆盖率，并全部通过，

132
00:06:56,416 --> 00:06:59,416
否则无法提交。”

133
00:06:59,419 --> 00:07:02,419
事实却是在二者之间存在一种会让大家感觉舒服的情况，

134
00:07:02,422 --> 00:07:04,422
因为覆盖率已经显示部分代码严重未通过测试或未经测试。

135
00:07:04,424 --> 00:07:09,424
与之相似，有些人过分看重单元测试，

136
00:07:09,429 --> 00:07:11,429
因为会得到更多细节，内容更全面。

137
00:07:11,431 --> 00:07:14,431
有些人是过分看重集成测试，

138
00:07:14,434 --> 00:07:16,434
因为这与客户真正要做的事情更相似。

139
00:07:16,436 --> 00:07:20,436
毕竟，大家是在为客户搭建程序。

140
00:07:20,440 --> 00:07:23,440
真正的意义在于每种测试都会发现其他测试漏检的问题。

141
00:07:23,443 --> 00:07:26,443
集成测试更容易发现之前未考虑到的界面间的漏洞或用户界面的差距。

142
00:07:26,446 --> 00:07:29,446
单元测试更容易发现特殊代码传递的漏洞，

143
00:07:29,449 --> 00:07:32,449
这在客户看来可能会较难执行。

144
00:07:32,452 --> 00:07:35,452
嗯

145
00:07:35,455 --> 00:07:37,455
当出现这些情况时，大家可能会想知道自己的应用程序会作何反应。

146
00:07:37,457 --> 00:07:41,457
考虑到这一点，我们可以这样提问，

147
00:07:41,461 --> 00:07:46,461
“对TDD开发人员来说，哪些属于不好的建议？”

148
00:07:46,466 --> 00:07:49,466
在进行单元测试时，要尽早并经常做模拟和存根。

149
00:07:49,469 --> 00:07:52,469
要以获得较高的单元测试覆盖率为目标。

150
00:07:52,472 --> 00:07:55,472
有时可以使用存根和模拟，即便是在集成测试时也是如此。

151
00:07:55,475 --> 00:07:58,475
单元测试比集成测试会让大家对整体系统的正确性信心更强。

152
00:07:58,478 --> 00:07:59,478


