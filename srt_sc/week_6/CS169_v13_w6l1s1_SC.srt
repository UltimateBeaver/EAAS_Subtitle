1
00:00:00,000 --> 00:00:02,000
上次TDD，我们已经初步深入了解了一个例子,

2
00:00:02,002 --> 00:00:06,002
很快你们就要编写测试案例。所以

3
00:00:06,006 --> 00:00:08,006
今天我们要浏览的大部分材料

4
00:00:08,008 --> 00:00:11,008
都跟编写测试案例密切相关，大多数人

5
00:00:11,011 --> 00:00:13,011
开始了解测试时并没有学如何编写测试案例，而且由于

6
00:00:13,013 --> 00:00:16,013
他们并不了解这些东西，他们想当然地认为

7
00:00:16,016 --> 00:00:19,016
测试是件痛苦、可怕的事情，是必输无疑的事。

8
00:00:19,019 --> 00:00:22,019
我们接下来要讨论的是mock和stub，

9
00:00:22,022 --> 00:00:25,022
当我真正能够灵活运用它们时，

10
00:00:25,025 --> 00:00:27,025
我恍然大悟，有点懂了如何进行有效测试。

11
00:00:27,027 --> 00:00:31,027
我们回到之前一直在深入研究的例子，

12
00:00:31,031 --> 00:00:35,031
我们谈论了查找远程数据库中资料的

13
00:00:35,035 --> 00:00:38,035
控制器模式。

14
00:00:38,038 --> 00:00:41,038
这是针对Rotten Potatoes应用程序的，

15
00:00:41,041 --> 00:00:44,041
我们深入观察两个参数，据参数，它应该调用模型中的方法，

16
00:00:44,044 --> 00:00:47,044
以达到实际效果。

17
00:00:47,047 --> 00:00:50,047
我们知道其中一个spec将确保我们渲染时，选对

18
00:00:50,050 --> 00:00:53,050
模板来渲染，剩下一个... 

19
00:00:53,053 --> 00:00:55,053
记得我们写了该控制器方法必须

20
00:00:55,055 --> 00:00:58,055
做的三件事。第三件事，我们还没有完成，那就是如果它

21
00:00:58,058 --> 00:01:00,058
从模型方法那获得了搜索结果，它应把那些

22
00:01:00,000 --> 00:01:03,060
结果用在模板上。现在，通过预览，我们已经

23
00:01:03,063 --> 00:01:07,063
知道如何在某控制器方法作用下，提供对模板有用的材料，

24
00:01:07,067 --> 00:01:09,067
方法就是，我们在控制器方法中

25
00:01:09,069 --> 00:01:11,069
设置实例变量，而这些实例

26
00:01:11,071 --> 00:01:15,071
变量可以在视图中使用。为了做到这一条，

27
00:01:15,075 --> 00:01:17,075
你们在考虑，好吧，好吧，你们领先我一步，

28
00:01:17,077 --> 00:01:20,077
接下来我们真要检查的是，我们要确保一点：

29
00:01:20,080 --> 00:01:24,080
假设模型方法返回了正确结果，

30
00:01:24,084 --> 00:01:27,084
我们就能将来自模型的信息用于视图。

31
00:01:27,087 --> 00:01:30,087
如果你们考虑得比我先一步，我希望

32
00:01:30,090 --> 00:01:32,090
你们如此，那意味着我们必须确定该控制器

33
00:01:32,092 --> 00:01:35,092
方法设置了实例变量，然后视图就可以

34
00:01:35,095 --> 00:01:38,095
读取其变量值。现在请注意我说过，假定

35
00:01:38,098 --> 00:01:40,098
该模型方法运作正确。我们上次谈到过的一件事，

36
00:01:40,100 --> 00:01:42,100
这件事我要不断重复，

37
00:01:42,102 --> 00:01:45,102
因为它十分重要，那就是， 

38
00:01:45,105 --> 00:01:48,105
每个测试仅测试一项。我们知道，

39
00:01:48,108 --> 00:01:51,108
我们必须单独对模型方法进行某些测试，所以

40
00:01:51,111 --> 00:01:54,111
现在我们隔离模型的运作， 

41
00:01:54,114 --> 00:01:56,114
我们假设它运作正确。

42
00:01:56,116 --> 00:01:57,116
我们会让它以一种可控的方式正确运作，因为我们想

43
00:01:57,117 --> 00:02:01,117
专注于控制器方法。因此，为了验证它有将结果用于模板，

44
00:02:01,121 --> 00:02:03,121
我们要观察

45
00:02:03,123 --> 00:02:06,123
RSpec的另一个附件。还记得我说过RSpec是一个

46
00:02:06,126 --> 00:02:09,126
基本的测试框架，但它也附带了一些插件，

47
00:02:09,129 --> 00:02:11,129
所以，如果你正在编写专门的Rails应用程序， 

48
00:02:11,131 --> 00:02:14,131
有一些种类的东西你想要测试

49
00:02:14,134 --> 00:02:16,134
而RSpec附带了额外的宏或库让你能这样做。

50
00:02:16,136 --> 00:02:19,136
我们来看看，

51
00:02:19,139 --> 00:02:22,139
一个被调用的赋值大体能够让你传递一个列出控制器实例变量的符号，

52
00:02:22,142 --> 00:02:27,142
并在视图尝试查看时，返回实际的变量。

53
00:02:27,147 --> 00:02:30,147
所以赋值会大体上让你明白

54
00:02:30,150 --> 00:02:34,150
一个实例变量对于视图的意义。现在，

55
00:02:34,154 --> 00:02:38,154
当然，在我们当前的代码中，我们正在做这样一个简单的测试案例，

56
00:02:38,158 --> 00:02:40,158
我们甚至没有设置实例变量。

57
00:02:40,160 --> 00:02:46,160
我们好好想想这到底是怎么回事。其实这就是我们一直使用至今的方法。

58
00:02:46,166 --> 00:02:49,166
请记住这样做有可能是

59
00:02:49,169 --> 00:02:51,169
传递参数的最简单办法，我们已经做得恰到好处。

60
00:02:51,171 --> 00:02:54,171
我们还没有确定好spec去核查：

61
00:02:54,174 --> 00:02:57,174
控制器方法是否设置了视图可以使用的实例变量。

62
00:02:57,177 --> 00:02:59,177
其实它从不设任何实例变量，所以

63
00:02:59,179 --> 00:03:07,179
这让人疑惑。让我们再次回到想要有的代码上。

64
00:03:07,187 --> 00:03:10,187
那么，首先，实例变量会是什么样子？

65
00:03:10,190 --> 00:03:13,190
我们说过，假定模型方法发挥作用，

66
00:03:13,193 --> 00:03:15,193
并返回正确的结果，那么按照主逻辑，什么是正确的结果？

67
00:03:15,195 --> 00:03:18,195
它可能会是

68
00:03:18,198 --> 00:03:20,198
类似一列电影对象的一列东西，对不对？

69
00:03:20,200 --> 00:03:23,200
因为我们已经有了一个类来表示电影有哪些，所以

70
00:03:23,203 --> 00:03:31,203
此处这个例子是关于代码是什么样子。

71
00:03:31,211 --> 00:03:34,211
那么，让我们来看看这里是怎么回事。我设立了一些假的结果，

72
00:03:34,214 --> 00:03:39,214
那么什么是mock？mock是假装为某一个类的对象。

73
00:03:39,219 --> 00:03:41,219
换句话说，如果你问它：“你是什么？ ”

74
00:03:41,221 --> 00:03:44,221
它会说“我是一部电影”，但它实际上并没有任何行为。

75
00:03:44,224 --> 00:03:47,224
它就像一个愚蠢的特技替身，只能担任

76
00:03:47,227 --> 00:03:49,227
任务的具体小段落，因为它不能像

77
00:03:49,229 --> 00:03:52,229
真正的演员一样。顺便说一句，对特技演员没有任何贬损之意; 

78
00:03:52,232 --> 00:03:56,232
特技演员的工作令人赞叹，只是打个比方。那么，我这是在做什么？

79
00:03:56,236 --> 00:04:00,236
我在大体构建我认为该电影模式会返回的结果，

80
00:04:00,000 --> 00:04:04,240
如果它存在的话，现在我要stub

81
00:04:04,244 --> 00:04:09,244
类方法find_in_tmdb并返回这些假结果。那么，

82
00:04:09,249 --> 00:04:11,249
我现在在做什么？再次，我设置了条件，以便

83
00:04:11,251 --> 00:04:14,251
在该测试的可控环境下，我们还未编写出的这个电影模式能够

84
00:04:14,254 --> 00:04:17,254
返回一个固定结果，表明它工作正常，

85
00:04:17,257 --> 00:04:19,257
因为我们没有测试这个。

86
00:04:19,259 --> 00:04:22,259
我们需要这些信息来做

87
00:04:22,262 --> 00:04:25,262
真正要测试的事，我们现在正在找，

88
00:04:25,265 --> 00:04:27,265
对不对？现在，我们要继续，并加快，启动

89
00:04:27,267 --> 00:04:30,267
控制器方法，我们在之前的测试中看过。

90
00:04:30,270 --> 00:04:33,270
这会导致控制器指令运行。

91
00:04:33,273 --> 00:04:37,273
我们现在正在寻找的仅仅是，看看视图是否尝试过取消引用

92
00:04:37,277 --> 00:04:41,277
调用电影的实例变量，我们希望

93
00:04:41,281 --> 00:04:44,281
它获取被设置为电影stub的变量值。来想想将要发生的整个流程。

94
00:04:44,284 --> 00:04:47,284
我们将调用控制器方法，

95
00:04:47,287 --> 00:04:48,287
控制器方法将会调用模型方法，模型方法并不存在，

96
00:04:48,288 --> 00:04:51,288
不过没关系，因为我们已经stub了它。

97
00:04:51,291 --> 00:04:54,291
这个stub会返回什么来？它将返回这些假结果。

98
00:04:54,294 --> 00:04:57,294
我们伪造的都是对于测试并非必要的行为，

99
00:04:57,297 --> 00:04:59,297
因为我们真正想要的是核查:

100
00:04:59,299 --> 00:05:02,299
这一结果返回时，我们能否将它用于视图。

101
00:05:02,302 --> 00:05:06,302
这就是赋值的作用。它向我们提供

102
00:05:06,306 --> 00:05:10,306
视图构想的实例变量，

103
00:05:10,310 --> 00:05:13,310
就这样，我们伪造的都是不想控制的测试部分。

104
00:05:13,313 --> 00:05:16,313
所以这真的......现在我们对seam有一些不同的理解。

105
00:05:16,316 --> 00:05:19,316
记得我们说过seam可以让你改变

106
00:05:19,319 --> 00:05:21,319
程序行为而不需改变源代码，

107
00:05:21,321 --> 00:05:24,321
它对测试特别有用，因为

108
00:05:24,324 --> 00:05:26,324
这是我们正在努力要做的，对不对？我们正在努力，

109
00:05:26,326 --> 00:05:29,326
以可控制的方式，运用程序的一小部分而不

110
00:05:29,329 --> 00:05:32,329
造成所依赖的程序其他部分的改变。

111
00:05:32,332 --> 00:05:35,332
在这个例子中，我们看到了两种不同的seam。我们

112
00:05:35,335 --> 00:05:38,335
看到一个stub，类似于我们上一次所看到的。上一次

113
00:05:38,338 --> 00:05:42,338
我们看到should_receive, should_receive意味着

114
00:05:42,342 --> 00:05:44,342
如果我没有对对象进行方法调用，那么就会显示错误，

115
00:05:44,344 --> 00:05:49,344
调用应该发生。stub放宽了要求。它规定，

116
00:05:49,349 --> 00:05:52,349
你可能对对象进行某个方法调用，如果你这样做了，

117
00:05:52,352 --> 00:05:54,352
你应该遵循的指令在此，但如果没有，它不会导致错误的结果。

118
00:05:54,354 --> 00:05:58,354
mock是某一对象的特技替身演员

119
00:05:58,358 --> 00:06:02,358
而你经常用它来进行行为验证。

120
00:06:02,362 --> 00:06:04,362
换句话来说，在这种情况下，我们想验证另一件事的行为。

121
00:06:04,364 --> 00:06:07,364
它需要电影或电影结果列表

122
00:06:07,367 --> 00:06:10,367
与之交互，但是我们不希望一定要费力去

123
00:06:10,370 --> 00:06:13,370
创建真正的电影对象，因为我们还没有实际

124
00:06:13,373 --> 00:06:15,373
打算对他们进行操作，对吧？在这种有限的情况下，

125
00:06:15,375 --> 00:06:18,375
影片对象要做唯一的事情就是

126
00:06:18,378 --> 00:06:22,378
扮演我们以固定方式返回的结果。

127
00:06:22,382 --> 00:06:25,382
话说到这，我们可以，例如，在对象上stub个别方法。

128
00:06:25,385 --> 00:06:28,385
例如，假设我们正在测试一个控制器指令，我们知道，

129
00:06:28,388 --> 00:06:31,388
当一个电影结果，比如，来自某一电影模型，

130
00:06:31,391 --> 00:06:33,391
它会检查下title属性。

131
00:06:33,393 --> 00:06:36,393
在这种情况下，我们可以做一些类似的事情，

132
00:06:36,396 --> 00:06:39,396
我们创建了影片对象的一个mock或double， 

133
00:06:39,399 --> 00:06:42,399
如果有人对你调用title方法，回应就好了。

134
00:06:42,402 --> 00:06:46,402
这有点...你可以固定极其少数的行为，

135
00:06:46,406 --> 00:06:49,406
这样就可以在非常有限的的情况下使用该对象。

136
00:06:49,409 --> 00:06:52,409
如果你看看最新RSpec说明，

137
00:06:52,412 --> 00:06:58,412
我想是2.14，大家现在轻视stub和mock等多项，

138
00:06:58,418 --> 00:07:01,418
支持单一一个项double，

139
00:07:01,421 --> 00:07:05,421
而测试double被当做类似于特技替身。一个

140
00:07:05,425 --> 00:07:08,425
替身，不是一个真正存在的对象，但可以承担真实对象

141
00:07:08,428 --> 00:07:11,428
在测试中的一部分作业。事实证明，

142
00:07:11,431 --> 00:07:14,431
stub和mock内部实现的方式是

143
00:07:14,434 --> 00:07:17,434
非常相似，使用单一一个项是有道理的。

144
00:07:17,437 --> 00:07:20,437
不过，我就我自己而言，我觉得

145
00:07:20,440 --> 00:07:23,440
在想法上对两个事物有所区分是有益处的。Mock扮演的是

146
00:07:23,443 --> 00:07:26,443
我们需要的一个对象，我们需要一个有活力的替身，

147
00:07:26,446 --> 00:07:28,446
它得能够做一或两件特定的事。

148
00:07:28,448 --> 00:07:32,448
stub更像是，当调用该方法时，

149
00:07:32,452 --> 00:07:35,452
因为我们不希望该方法实际在此发生作用，

150
00:07:35,455 --> 00:07:38,455
我们就提供一个固定回应。语义

151
00:07:38,458 --> 00:07:40,458
有微妙不同。两者其中之一更图方便，像是

152
00:07:40,460 --> 00:07:43,460
忽略了应用程序的其余部分。另一种内容就丰富些， 

153
00:07:43,463 --> 00:07:46,463
我会设置一些expectation(预期)，因为我需要对对象进行

154
00:07:46,466 --> 00:07:50,466
一定的操作。在每一种情况下，

155
00:07:50,470 --> 00:07:53,470
该seam在测试中为传递特定的行为发挥了充分的作用。

156
00:07:53,473 --> 00:07:56,473
因此，我们把这些东西放在一起，

157
00:07:56,476 --> 00:07:58,476
比较这两个我们上次所见的spec。

158
00:07:58,478 --> 00:08:02,478
在我们看来，怎样才算编写了一个的spec或是不错的测试案例？

159
00:08:02,482 --> 00:08:04,482
首先，它应该只测试某一个行为，

160
00:08:04,484 --> 00:08:08,484
这是不是真的太极端？即使是在我们的简单

161
00:08:08,488 --> 00:08:12,488
控制器模式中，我们看到,调用模型方法，

162
00:08:12,492 --> 00:08:14,492
传递正确的信息给模型方法， 

163
00:08:14,494 --> 00:08:17,494
从模型方法结果中获取正确信息，这实际上是

164
00:08:17,497 --> 00:08:19,497
三种不同的行为,我们为它们写了三个不同的spec。

165
00:08:19,499 --> 00:08:22,499
弄清楚你将需要

166
00:08:22,502 --> 00:08:25,502
怎样的seam去隔离想测试的行为跟它们所依靠的其他行为，

167
00:08:25,505 --> 00:08:28,505
但这不是测试的一部分，因此采用哪种

168
00:08:28,508 --> 00:08:31,508
预期合适呢。如果你不确定有些东西会被调用多少次， 

169
00:08:31,511 --> 00:08:33,511
或者你要调用的对测试并非必要关键，

170
00:08:33,513 --> 00:08:36,513
你可以使用stub。 

171
00:08:36,516 --> 00:08:39,516
如果你想建立一个方法并确保它真的被调用，

172
00:08:39,519 --> 00:08:42,519
你可以使用should receive预期， 

173
00:08:42,522 --> 00:08:44,522
如果你想确保某物不会被调用， 

174
00:08:44,524 --> 00:08:46,524
或可使用should not receive。比如，你可能

175
00:08:46,526 --> 00:08:49,526
在进行测试，如果客户不同意销售条款，

176
00:08:49,529 --> 00:08:52,529
信用卡支付的方法就不应被调用。

177
00:08:52,532 --> 00:08:56,532
这是一个完美的合法的代码路径。一旦你设置了

178
00:08:56,536 --> 00:08:59,536
前提条件，你设置了你的seam，确保测试会因正确的原因失败。

179
00:08:59,539 --> 00:09:01,539
换句话说，之所以

180
00:09:01,541 --> 00:09:05,541
你希望它失败的，是因为你已经正确表达

181
00:09:05,545 --> 00:09:07,545
代码应该做什么，但你未曾编写该代码。这是

182
00:09:07,547 --> 00:09:10,547
失败对应的原因，失败是因为

183
00:09:10,550 --> 00:09:12,550
语法错误或你拼写错了某个变量的名字或你

184
00:09:12,552 --> 00:09:14,552
对错的事情进行了stub，或者你没有意识到

185
00:09:14,554 --> 00:09:17,554
该方法期望调用的东西而且你没有对其进行stub，

186
00:09:17,557 --> 00:09:20,557
于是坏事就发生了。明白了失败是由于正确的原因，

187
00:09:20,560 --> 00:09:23,560
现在感觉更容易了，对不对？ 

188
00:09:23,563 --> 00:09:26,563
如果你还没有搞清楚这一点，编写代码实际上是最容易的。

189
00:09:26,566 --> 00:09:29,566
确定写什么代码，以及如何测试它，以及

190
00:09:29,569 --> 00:09:32,569
边界应该在哪，这实际上是较难的部分。

191
00:09:32,572 --> 00:09:34,572
其实这有点像要确保你先构建好最困难的部分，

192
00:09:34,574 --> 00:09:38,574
一旦你已经成功地测试失败，我们会发现

193
00:09:38,578 --> 00:09:40,578
Bug修复真的很雷同，对不对？

194
00:09:40,580 --> 00:09:43,580
修复一个bug最难的是找到并复制它。如果在一个测试中你能做到这个，

195
00:09:43,583 --> 00:09:46,583
一旦你回填代码去修复它，就容易多了。

196
00:09:46,586 --> 00:09:49,586
如果你通过测试， 

197
00:09:49,589 --> 00:09:52,589
你会寻找机会，重构你的代码，寻找空间

198
00:09:52,592 --> 00:09:55,592
使它漂亮。就像书写。你搞定粗糙的草图，

199
00:09:55,595 --> 00:09:57,595
这并不意味着你就大功告成了; 

200
00:09:57,597 --> 00:09:59,597
这意味着你有点明白自己的想法了，现在你可以回头去真正让它变漂亮。

201
00:09:59,599 --> 00:10:03,599
我们可以把看到的技术添加到测试的目录。

202
00:10:03,603 --> 00:10:06,603
我们看过should receive，我们看到

203
00:10:06,606 --> 00:10:09,606
你可以选择性地说明should receive应该收取的内容，

204
00:10:09,609 --> 00:10:12,609
参数是什么。你也可以选择性地说明它应返回的内容，

205
00:10:12,612 --> 00:10:15,612
如果你的测试案例需要。我们现在还看到

206
00:10:15,615 --> 00:10:20,615
你可以进行stub，和should receive一样，你可以stub某些事,

207
00:10:20,620 --> 00:10:24,620
并指定其返回的内容。现在你可能会问，

208
00:10:24,624 --> 00:10:26,624
你调用stub和say可否可以跟调用should receive一样操作。

209
00:10:26,626 --> 00:10:30,626
其实从语法上看，你可以这样做，但问题是

210
00:10:30,630 --> 00:10:34,630
它是否有意义。因为stub的重点是

211
00:10:34,634 --> 00:10:37,634
你沟通的是目的，但这不是我所测试功能的核心。

212
00:10:37,637 --> 00:10:41,637
而对于should receive, 核心功能的一部分

213
00:10:41,641 --> 00:10:43,641
就是要确保这个方法真正被调用。

214
00:10:43,643 --> 00:10:46,643
所以在这种情况下，你可能会想

215
00:10:46,646 --> 00:10:48,646
你也希望确保使用正确的参数调用它。

216
00:10:48,648 --> 00:10:51,648
你可以用参数stub某些东西， 

217
00:10:51,651 --> 00:10:54,651
但事实上，你一边在stub它，一边说我真的不是很在乎它是否被调用。

218
00:10:54,654 --> 00:10:58,654
这有点像是以防万一。

219
00:10:58,658 --> 00:11:01,658
你还可以创建mock，这是对象的替身。

220
00:11:01,661 --> 00:11:03,661
你说他们是哪个类，他们会就会像哪个类。

221
00:11:03,663 --> 00:11:06,663
他们会声称自己是，但如果你尝试真的将任何类方法

222
00:11:06,666 --> 00:11:08,666
调用于他们，他们会绝望地举起双手

223
00:11:08,668 --> 00:11:11,668
，不知道该怎么办。他们是非常、非常盲目的对象，

224
00:11:11,671 --> 00:11:14,671
你可以一次一个对他们stub具体方法。

225
00:11:14,674 --> 00:11:16,674
我们会立刻回答发生了什么，

226
00:11:16,676 --> 00:11:19,676
如果你stub这么多方法，你原来就该使用一个真正的对象。

227
00:11:19,679 --> 00:11:25,679
RSpec提供的另一个匹配程序 

228
00:11:25,685 --> 00:11:28,685
针对Rails， 

229
00:11:28,688 --> 00:11:32,688
主要是说明视图将获取的内容，

230
00:11:32,692 --> 00:11:36,692
我们看过其赋值，试过取消引用这个实例变量。

231
00:11:36,696 --> 00:11:38,696
通常它用于以下的情况， 

232
00:11:38,698 --> 00:11:40,698
你想确保所使用的控制器指令正确设置了一些实例变量的值

233
00:11:40,700 --> 00:11:45,700
视图会接着渲染这些实例变量。因此，问题来了： 

234
00:11:45,705 --> 00:11:49,705
Should receive结合了两样东西，而stub仅针对一个东西？

235
00:11:49,709 --> 00:11:54,709
你们可以看看书，我喝口水。

