1
00:00:00,000 --> 00:00:02,000
上次TDD，我们已经初步深入了解了一个例子,

2
00:00:02,002 --> 00:00:06,002
很快你们就要编写测试案例。所以

3
00:00:06,006 --> 00:00:08,006
今天我们要浏览的大部分材料

4
00:00:08,008 --> 00:00:11,008
都跟编写测试案例密切相关，大多数人

5
00:00:11,011 --> 00:00:13,011
开始了解测试时并没有学编写测试案例，而且由于

6
00:00:13,013 --> 00:00:16,013
他们并不了解这些东西，他们想当然地认为

7
00:00:16,016 --> 00:00:19,016
测试是件痛苦、可怕的事情，必输无疑。

8
00:00:19,019 --> 00:00:22,019
我们接下来要讨论的是mock和stub，

9
00:00:22,022 --> 00:00:25,022
当我真正能够灵活运用它们时，

10
00:00:25,025 --> 00:00:27,025
我恍然大悟，有点懂了如何进行有效测试。

11
00:00:27,027 --> 00:00:31,027
我们回到之前一直在深入研究的例子，

12
00:00:31,031 --> 00:00:35,031
我们谈论了查找远程数据库中资料的

13
00:00:35,035 --> 00:00:38,035
控制器模式。

14
00:00:38,038 --> 00:00:41,038
这是针对Rotten Potatoes应用程序的，

15
00:00:41,041 --> 00:00:44,041
我们深入观察两个参数，据参数，它应该调用模型中的方法，

16
00:00:44,044 --> 00:00:47,044
以达到实际效果。

17
00:00:47,047 --> 00:00:50,047
我们知道其中一个参数将确保我们渲染时，选对

18
00:00:50,050 --> 00:00:53,050
模板来渲染，剩下一个... 

19
00:00:53,053 --> 00:00:55,053
记得我们写了该控制器模式必须

20
00:00:55,055 --> 00:00:58,055
做的三件事。第三件事，我们还没有完成，那就是如果它

21
00:00:58,058 --> 00:01:00,058
从模型方法那获得了搜索结果，它应把那些

22
00:01:00,000 --> 00:01:03,060
结果用在模板上。现在，通过预览，我们已经

23
00:01:03,063 --> 00:01:07,063
知道如何在某控制器模式作用下，提供对模板有用的材料，

24
00:01:07,067 --> 00:01:09,067
方法就是，我们在控制器模式中

25
00:01:09,069 --> 00:01:11,069
设置实例变量，而这些实例

26
00:01:11,071 --> 00:01:15,071
变量可以在视图中使用。为了做到这一条，

27
00:01:15,075 --> 00:01:17,075
你们在考虑，好吧，好吧，你们领先我一步，

28
00:01:17,077 --> 00:01:20,077
接下来我们真要检查的是，我们要确保

29
00:01:20,080 --> 00:01:24,080
假设模型方法返回了正确结果，

30
00:01:24,084 --> 00:01:27,084
我们得将来自模型的信息用于视图，

31
00:01:27,087 --> 00:01:30,087
如果你们考虑得比我先一步，我希望

32
00:01:30,090 --> 00:01:32,090
你们如此，那意味着我们必须确定该控制器

33
00:01:32,092 --> 00:01:35,092
模式有设置实例变量，然后视图就可以

34
00:01:35,095 --> 00:01:38,095
读取其变量值。现在请注意我说过，假定

35
00:01:38,098 --> 00:01:40,098
该模型方法运作正确。我们上次谈到过的一件事，

36
00:01:40,100 --> 00:01:42,100
这件事我要不断重复，

37
00:01:42,102 --> 00:01:45,102
因为它十分重要，那就是， 

38
00:01:45,105 --> 00:01:48,105
每个测试仅测试一项。我们知道，

39
00:01:48,108 --> 00:01:51,108
我们必须单独对模型方法进行某些测试，所以

40
00:01:51,111 --> 00:01:54,111
现在我们隔离模型的运作， 

41
00:01:54,114 --> 00:01:56,114
我们假设它运作正确。

42
00:01:56,116 --> 00:01:57,116
我们会让它以一种可控的方式正确运作，因为我们想

43
00:01:57,117 --> 00:02:01,117
专注于控制器模式。因此，为了验证它有将结果用于模板，

44
00:02:01,121 --> 00:02:03,121
我们要观察

45
00:02:03,123 --> 00:02:06,123
RSpec的另一个附件。还记得我说过RSpec是一个

46
00:02:06,126 --> 00:02:09,126
基本的测试框架，但它也附带了一些插件，

47
00:02:09,129 --> 00:02:11,129
所以，如果你正在编写专门的Rails应用程序， 

48
00:02:11,131 --> 00:02:14,131
有一些种类的东西你想要测试

49
00:02:14,134 --> 00:02:16,134
而RSpec附带了额外的宏或库让你能这样做。

50
00:02:16,136 --> 00:02:19,136
我们来看看，

51
00:02:19,139 --> 00:02:22,139
一个被调用的赋值大体能够让你传递符号，列出控制器实例变量，

52
00:02:22,142 --> 00:02:27,142
并在视图尝试查看时，返回实际的变数。

53
00:02:27,147 --> 00:02:30,147
所以赋值会大体上让你明白

54
00:02:30,150 --> 00:02:34,150
一个实例变量对于视图的意义。现在，

55
00:02:34,154 --> 00:02:38,154
当然，在我们当前的代码中，我们正在做这样一个简单的测试案例，

56
00:02:38,158 --> 00:02:40,158
我们甚至没有设置实例变量。

57
00:02:40,160 --> 00:02:46,160
我们好好想想这到底是怎么回事。其实这就是我们一直使用至今的方法。

58
00:02:46,166 --> 00:02:49,166
请记住这样做有可能是

59
00:02:49,169 --> 00:02:51,169
传递参数的最简单办法，我们已经做得恰到好处。

60
00:02:51,171 --> 00:02:54,171
我们还没有确定好参数去核查：

61
00:02:54,174 --> 00:02:57,174
控制器模式是否设置了视图可以使用的实例变量。

62
00:02:57,177 --> 00:02:59,177
其实它从不设任何实例变量，所以

63
00:02:59,179 --> 00:03:07,179
这让人疑惑。让我们再次回到想要有的代码上。

64
00:03:07,187 --> 00:03:10,187
那么，首先，实例变量会是什么样子？

65
00:03:10,190 --> 00:03:13,190
我们说过，假定模型方法发挥作用，

66
00:03:13,193 --> 00:03:15,193
并返回正确的结果，那么按照主逻辑，什么是正确的结果？

67
00:03:15,195 --> 00:03:18,195
它可能会是

68
00:03:18,198 --> 00:03:20,198
类似一列电影对象的一列东西，对不对？

69
00:03:20,200 --> 00:03:23,200
因为我们已经有了一个类来表示电影有哪些，所以

70
00:03:23,203 --> 00:03:31,203
此处这个例子是关于代码是什么样子。

71
00:03:31,211 --> 00:03:34,211
那么，让我们来看看这里是怎么回事。我设立了一些假的结果，

72
00:03:34,214 --> 00:03:39,214
那么什么是mock？mock是假装为某一个类的对象。

73
00:03:39,219 --> 00:03:41,219
换句话说，如果你问它：“你是什么？ ”

74
00:03:41,221 --> 00:03:44,221
它会说“我是一部电影”，但它实际上并没有任何行为。

75
00:03:44,224 --> 00:03:47,224
它就像一个愚蠢的特技替身，只能担任

76
00:03:47,227 --> 00:03:49,227
任务的具体小段落，因为它不能像

77
00:03:49,229 --> 00:03:52,229
真正的演员一样。顺便说一句，对特技演员没有任何贬损之意; 

78
00:03:52,232 --> 00:03:56,232
特技演员的工作令人赞叹，只是打个比方。那么，我这是在做什么？

79
00:03:56,236 --> 00:04:00,236
我在大体构建我认为该电影模式会返回的结果，

80
00:04:00,000 --> 00:04:04,240
如果它存在的话，现在我要stub

81
00:04:04,244 --> 00:04:09,244
类方法find_in_tmdb并返回这些假结果。那么，

82
00:04:09,249 --> 00:04:11,249
我现在在做什么？再次，我设置了条件，以便

83
00:04:11,251 --> 00:04:14,251
在该测试的可控环境下，我们还未编写出的这个电影模式能够

84
00:04:14,254 --> 00:04:17,254
返回一个固定结果，表明它工作正常，

85
00:04:17,257 --> 00:04:19,257
因为我们没有测试这个。

86
00:04:19,259 --> 00:04:22,259
我们需要这些信息来做

87
00:04:22,262 --> 00:04:25,262
真正要测试的事，我们现在正在找，

88
00:04:25,265 --> 00:04:27,265
对不对？现在，我们要继续，并加快，启动

89
00:04:27,267 --> 00:04:30,267
控制器模式，我们在之前的测试中看过。

90
00:04:30,270 --> 00:04:33,270
这会导致控制器指令运行。

91
00:04:33,273 --> 00:04:37,273
我们现在正在寻找的仅仅是，看看视图是否尝试过取消引用

92
00:04:37,277 --> 00:04:41,277
调用电影的实例变量，我们希望

93
00:04:41,281 --> 00:04:44,281
它获取被设置为电影stub的变量值。来想想将要发生的整个流程。

94
00:04:44,284 --> 00:04:47,284
我们将调用控制器模式，

95
00:04:47,287 --> 00:04:48,287
控制器模式将会调用模型模式，模型方法并不存在，

96
00:04:48,288 --> 00:04:51,288
不过没关系，因为我们已经stub了它。

97
00:04:51,291 --> 00:04:54,291
这个stub会返回什么来？它将返回这些假结果。

98
00:04:54,294 --> 00:04:57,294
我们伪造的都是对于测试并非必要的行为，

99
00:04:57,297 --> 00:04:59,297
因为我们真正想要的是核查:

100
00:04:59,299 --> 00:05:02,299
这一结果返回时，我们能否将它用于视图。

101
00:05:02,302 --> 00:05:06,302
这就是赋值的作用。它向我们提供

102
00:05:06,306 --> 00:05:10,306
视图构想的实例变量，

103
00:05:10,310 --> 00:05:13,310
就这样，我们伪造的都是不想控制的测试部分。

104
00:05:13,313 --> 00:05:16,313
所以这真的......现在我们对seam有一些不同的理解。

105
00:05:16,316 --> 00:05:19,316
记得我们说过seam可以让你改变

106
00:05:19,319 --> 00:05:21,319
程序行为而不需改变源代码，

107
00:05:21,321 --> 00:05:24,321
它对测试特别有用，因为

108
00:05:24,324 --> 00:05:26,324
这是我们正在努力要做的，对不对？我们正在努力，

109
00:05:26,326 --> 00:05:29,326
以可控制的方式，运用程序的一小部分而不

110
00:05:29,329 --> 00:05:32,329
造成所依赖的程序其他部分的改变。

111
00:05:32,332 --> 00:05:35,332
在这个例子中，我们看到了两种不同的seam。我们

112
00:05:35,335 --> 00:05:38,335
看到一个stub，类似于我们上一次所看到的。上一次

113
00:05:38,338 --> 00:05:42,338
我们看到should_receive, should_receive意味着

114
00:05:42,342 --> 00:05:44,342
如果我没有对对象进行方法调用，那么就会显示错误，

115
00:05:44,344 --> 00:05:49,344
调用应该发生。stub放宽了要求。它规定，

116
00:05:49,349 --> 00:05:52,349
你可能对对象进行某个方法调用，如果你这样做了，

117
00:05:52,352 --> 00:05:54,352
你应该遵循的指令在此，但如果没有，它不会导致错误的结果。

118
00:05:54,354 --> 00:05:58,354
mock是某一对象的特技替身演员

119
00:05:58,358 --> 00:06:02,358
而你经常用它来进行行为验证。

120
00:06:02,362 --> 00:06:04,362
换句话来说，在这种情况下，我们想验证另一件事的行为。

121
00:06:04,364 --> 00:06:07,364
它需要电影或电影结果列表

122
00:06:07,367 --> 00:06:10,367
与之交互，但是我们不想一定要费力去

123
00:06:10,370 --> 00:06:13,370
创建真正的电影对象，因为我们还没有实际

124
00:06:13,373 --> 00:06:15,373
打算对他们进行操作，对吧？在这有限的情况下，

125
00:06:15,375 --> 00:06:18,375
影片对象要做唯一的事情就是

126
00:06:18,378 --> 00:06:22,378
扮演我们以固定方式返回的结果。

127
00:06:22,382 --> 00:06:25,382
话说到这，我们可以，例如，在对象上stub个别方法。

128
00:06:25,385 --> 00:06:28,385
例如，假设我们正在测试一个控制器指令，我们知道，

129
00:06:28,388 --> 00:06:31,388
当一个电影结果，比如，来自某一电影模型，

130
00:06:31,391 --> 00:06:33,391
它会检查下title属性。

131
00:06:33,393 --> 00:06:36,393
在这种情况下，我们可以做一些类似的事情，

132
00:06:36,396 --> 00:06:39,396
我们创建了影片对象的一个mock或double， 

133
00:06:39,399 --> 00:06:42,399
如果有人对你调用title方法，回应就好了。

134
00:06:42,402 --> 00:06:46,402
这有点...你可以固定极其少数的行为，

135
00:06:46,406 --> 00:06:49,406
这样就可以在非常有限的的情况下使用该对象。

136
00:06:49,409 --> 00:06:52,409
如果你看看最新RSpec说明，

137
00:06:52,412 --> 00:06:58,412
我想是2.14，大家现在轻视stub和mock等多项，

138
00:06:58,418 --> 00:07:01,418
支持单一一个项double，

139
00:07:01,421 --> 00:07:05,421
而测试double被当做类似于特技替身。一个

140
00:07:05,425 --> 00:07:08,425
替身，不是一个真正存在的对象，但可以承担真实对象

141
00:07:08,428 --> 00:07:11,428
在测试中的一部分作业。事实证明，

142
00:07:11,431 --> 00:07:14,431
stub和mock内部实现的方式是

143
00:07:14,434 --> 00:07:17,434
非常相似，使用单一一个项是有道理的。

144
00:07:17,437 --> 00:07:20,437
不过，我就我自己而言，我觉得

145
00:07:20,440 --> 00:07:23,440
在想法上对两个事物有所区分是有益处的。Mock扮演的是

146
00:07:23,443 --> 00:07:26,443
我们需要的一个对象，我们需要一个有活力的替身，

147
00:07:26,446 --> 00:07:28,446
它得能够做一或两件特定的事。

148
00:07:28,448 --> 00:07:32,448
stub更像是，当调用该方法时，

149
00:07:32,452 --> 00:07:35,452
因为我们不希望该方法实际在此发生作用，

150
00:07:35,455 --> 00:07:38,455
我们就提供一个固定回应。语义

151
00:07:38,458 --> 00:07:40,458
有微妙不同。两者其中之一更图方便，像是

152
00:07:40,460 --> 00:07:43,460
忽略了应用程序的其余部分。另一种内容就丰富些， 

153
00:07:43,463 --> 00:07:46,463
我会设置一些expectation(预期)，因为我需要对对象进行

154
00:07:46,466 --> 00:07:50,466
一定的操作。在每一种情况下，

155
00:07:50,470 --> 00:07:53,470
该seam在测试中为传递特定的行为发挥了充分的作用。

156
00:07:53,473 --> 00:07:56,473
因此，我们把这些东西放在一起，

157
00:07:56,476 --> 00:07:58,476
比较这两个我们上次所见的参数。

158
00:07:58,478 --> 00:08:02,478
在我们看来，怎样才算编写了一个好参数或是不错的测试案例？

159
00:08:02,482 --> 00:08:04,482
首先，它应该只测试某一个行为，

160
00:08:04,484 --> 00:08:08,484
这是不是真的太极端？即使是在我们的简单

161
00:08:08,488 --> 00:08:12,488
控制器模式中，我们看到,调用模型方法，

162
00:08:12,492 --> 00:08:14,492
传递正确的信息给模型方法， 

163
00:08:14,494 --> 00:08:17,494
从模型方法结果中获取正确信息，这实际上是

164
00:08:17,497 --> 00:08:19,497
三种不同的行为,我们为它们写了三个不同的参数。

165
00:08:19,499 --> 00:08:22,499
弄清楚你将需要

166
00:08:22,502 --> 00:08:25,502
怎样的seam去隔离想测试的行为跟它们所依靠的其他行为，

167
00:08:25,505 --> 00:08:28,505
但这不是测试的一部分，因此采用哪种

168
00:08:28,508 --> 00:08:31,508
预期合适呢。如果你不确定有些东西会被调用多少次， 

169
00:08:31,511 --> 00:08:33,511
或者你要调用的对测试并非必要关键，

170
00:08:33,513 --> 00:08:36,513
您可以使用stub。 

171
00:08:36,516 --> 00:08:39,516
如果你想建立一个方法并确保它真的被调用，

172
00:08:39,519 --> 00:08:42,519
你可以使用should receive预期， 

173
00:08:42,522 --> 00:08:44,522
如果你想确保某物不会被调用， 

174
00:08:44,524 --> 00:08:46,524
或可使用should not receive。比如，您可能

175
00:08:46,526 --> 00:08:49,526
在进行测试，如果客户不同意销售条款，

176
00:08:49,529 --> 00:08:52,529
信用卡支付的方法就不应被调用。

177
00:08:52,532 --> 00:08:56,532
这是一个完美的合法的代码路径。一旦你设置了

178
00:08:56,536 --> 00:08:59,536
前提条件，你设置了你的seam，确保测试会因正确的原因失败。

179
00:08:59,539 --> 00:09:01,539
换句话说，之所以

180
00:09:01,541 --> 00:09:05,541
你希望它失败的，是因为你已经正确表达

181
00:09:05,545 --> 00:09:07,545
代码应该做什么，但你未曾编写该代码。这是

182
00:09:07,547 --> 00:09:10,547
失败对应的原因，失败是因为

183
00:09:10,550 --> 00:09:12,550
语法错误或你拼写错了某个变量的名字或你

184
00:09:12,552 --> 00:09:14,552
对错的事情进行了stub，或者你没有意识到

185
00:09:14,554 --> 00:09:17,554
该方法期望调用的东西而且你没有对其进行stub，

186
00:09:17,557 --> 00:09:20,557
于是坏事就发生了。明白了失败是由于正确的原因，

187
00:09:20,560 --> 00:09:23,560
现在感觉更容易了，对不对？ 

188
00:09:23,563 --> 00:09:26,563
如果你还没有搞清楚这一点，编写代码实际上是最容易的。

189
00:09:26,566 --> 00:09:29,566
确定写什么代码，以及如何测试它，以及

190
00:09:29,569 --> 00:09:32,569
边界应该在哪，这实际上是较难的部分。

191
00:09:32,572 --> 00:09:34,572
其实这有点像要确保你先构建好最困难的部分，

192
00:09:34,574 --> 00:09:38,574
一旦你已经成功地测试失败，我们会发现

193
00:09:38,578 --> 00:09:40,578
Bug修复真的很雷同，对不对？

194
00:09:40,580 --> 00:09:43,580
修复一个bug最难的是找到并复制它。如果在一个测试中你能做到这个，

195
00:09:43,583 --> 00:09:46,583
一旦你回填代码去修复它，就容易多了。

196
00:09:46,586 --> 00:09:49,586
如果你通过测试， 

197
00:09:49,589 --> 00:09:52,589
你会寻找机会，重构你的代码，寻找空间

198
00:09:52,592 --> 00:09:55,592
使它漂亮。就像书写。你搞定粗糙的草图，

199
00:09:55,595 --> 00:09:57,595
这并不意味着你就大功告成了; 

200
00:09:57,597 --> 00:09:59,597
这意味着你有点明白自己的想法了，现在你可以回头去真正让它变漂亮。

201
00:09:59,599 --> 00:10:03,599
我们可以把看到的技术添加到测试的目录。

202
00:10:03,603 --> 00:10:06,603
我们看过should receive，我们看到

203
00:10:06,606 --> 00:10:09,606
你可以选择性地说明should receive应该收取的内容，

204
00:10:09,609 --> 00:10:12,609
参数几何，你也可以选择性地说明它应返回的内容，

205
00:10:12,612 --> 00:10:15,612
如果你的测试案例需要。我们现在还看到

206
00:10:15,615 --> 00:10:20,615
你可以进行stub，和should receive一样，你可以stub某些事,

207
00:10:20,620 --> 00:10:24,620
并指定其返回的内容。现在你可能会问，

208
00:10:24,624 --> 00:10:26,624
你调用stub和say可否可以跟调用should receive一样操作。

209
00:10:26,626 --> 00:10:30,626
其实从语法上看，你可以这样做，但问题是

210
00:10:30,630 --> 00:10:34,630
它是否有意义。因为stub的重点是

211
00:10:34,634 --> 00:10:37,634
你沟通的是目的，但这不是我所测试功能的核心。

212
00:10:37,637 --> 00:10:41,637
而对于should receive, 核心功能的一部分

213
00:10:41,641 --> 00:10:43,641
就是要确保这个方法真正被调用。

214
00:10:43,643 --> 00:10:46,643
所以在这种情况下，你可能会想

215
00:10:46,646 --> 00:10:48,646
你也希望确保使用正确的参数调用它。

216
00:10:48,648 --> 00:10:51,648
你可以用参数stub某些东西， 

217
00:10:51,651 --> 00:10:54,651
但事实上，你一边在stub它，一边说我真的不是很在乎它是否被调用。

218
00:10:54,654 --> 00:10:58,654
这有点像是以防万一。

219
00:10:58,658 --> 00:11:01,658
您还可以创建mock，这是对象的替身。

220
00:11:01,661 --> 00:11:03,661
你说他们是哪个类，他们会就会像哪个类。

221
00:11:03,663 --> 00:11:06,663
他们会声称自己是，但如果你尝试真的将任何类方法

222
00:11:06,666 --> 00:11:08,666
调用于他们，他们会绝望地举起双手

223
00:11:08,668 --> 00:11:11,668
，不知道该怎么办。他们是非常、非常盲目的对象，

224
00:11:11,671 --> 00:11:14,671
你可以一次一个对他们stub具体方法。

225
00:11:14,674 --> 00:11:16,674
我们会立刻回答发生了什么，

226
00:11:16,676 --> 00:11:19,676
如果你stub这么多方法，你原来就该使用一个真正的对象。

227
00:11:19,679 --> 00:11:25,679
RSpec提供的另一个匹配程序 

228
00:11:25,685 --> 00:11:28,685
针对Rails， 

229
00:11:28,688 --> 00:11:32,688
主要是说明视图将获取的内容，

230
00:11:32,692 --> 00:11:36,692
我们看过其赋值，试过取消引用这个实例变量。

231
00:11:36,696 --> 00:11:38,696
通常它用于以下的情况， 

232
00:11:38,698 --> 00:11:40,698
你想确保所使用的控制器指令正确设置了一些实例变量的值

233
00:11:40,700 --> 00:11:45,700
视图会接着渲染这些实例变量。因此，问题来了： 

234
00:11:45,705 --> 00:11:49,705
Should receive结合了两样东西，而stub仅针对一个东西？

235
00:11:49,709 --> 00:11:54,709
你们可以看看书，我喝口水。

