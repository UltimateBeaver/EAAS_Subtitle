1
00:00:00,000 --> 00:00:02,000
我准备将我们讲过的TDD相关内容进行总结，

2
00:00:02,002 --> 00:00:06,002
我想向大家说明的是即便是对于那些看似刚接触TDD的人而言，

3
00:00:06,006 --> 00:00:09,006
其实也都已经了解该怎样应对TDD，

4
00:00:09,009 --> 00:00:12,009
因为以前所做的都是同样内容，

5
00:00:12,012 --> 00:00:14,012
只是没有真正有效地完成这类任务。

6
00:00:14,014 --> 00:00:18,014
在大家开始动手之前，

7
00:00:18,018 --> 00:00:21,018
我来简要介绍一下可能会涉及的部分测试术语。

8
00:00:21,021 --> 00:00:23,021
我们谈到测试已有相当长的时间，

9
00:00:23,023 --> 00:00:27,023
在我们常用的概念术语之外，会有不同的词汇概念和术语出现。

10
00:00:27,027 --> 00:00:31,027
突变测试就是个非常有趣的理念，

11
00:00:31,031 --> 00:00:34,031
基本上是说如果我刻意在应用程序中引入一个错误，

12
00:00:34,034 --> 00:00:37,034
导致部分测试失败。

13
00:00:37,037 --> 00:00:40,037
因为如果不这样做，在测试覆盖中就可能会存在漏洞。

14
00:00:40,040 --> 00:00:45,040
预告一下，这基本上就是我们如何将进行测试的过程。

15
00:00:45,045 --> 00:00:47,045
我们会安排一个作业，

16
00:00:47,047 --> 00:00:49,047
要求同学们编写自己的cucumber场景，

17
00:00:49,049 --> 00:00:51,049
基本上我们就像这样测试。

18
00:00:51,051 --> 00:00:54,051
我们有一个应用程序，可以将漏洞插入其中，

19
00:00:54,054 --> 00:00:59,054
以确保有些场景步骤是因为这些漏洞而失败。

20
00:00:59,059 --> 00:01:02,059
模糊测试是一种叫做搞怪测试的场景，大家基本上是为自己的代码生成随机的输入数据。

21
00:01:02,062 --> 00:01:07,062
在模糊测试中，

22
00:01:07,067 --> 00:01:09,067
大家基本上是要在非预期的条件下执行代码。

23
00:01:09,069 --> 00:01:11,069
如果是个命令行程序，

24
00:01:11,071 --> 00:01:15,071
大家可以在SaaS应用程序的命令行中直接输入数据，

25
00:01:15,075 --> 00:01:18,075
这就像是提交随机数据、

26
00:01:18,078 --> 00:01:22,078
或是特别长的数据或是含非法字符的数据等。

27
00:01:22,082 --> 00:01:26,082
微软称约有20％的漏洞是通过这种方式发现的。

28
00:01:26,086 --> 00:01:29,086
模糊测试可以令高达25％的流行Unix命令行实用工具崩溃。

29
00:01:29,089 --> 00:01:33,089
一旦完成了基本测试后，这就是一种强大的技术，

30
00:01:33,093 --> 00:01:35,093
如果是在完成基本测试前

31
00:01:35,095 --> 00:01:38,095
进行模糊测试，

32
00:01:38,098 --> 00:01:41,098
那么大家会因为任何随机输入的数据都会损坏应用而倍感绝望，

33
00:01:41,101 --> 00:01:44,101
这是因为应用会非常脆弱。DU覆盖代表定义(D)和使用(U)的概念。

34
00:01:44,104 --> 00:01:48,104
这是衡量测试覆盖的另一种变量。

35
00:01:48,108 --> 00:01:51,108
先来看变量被定义的地方，

36
00:01:51,111 --> 00:01:54,111
即赋值，之后会有人使用这个值，

37
00:01:54,114 --> 00:02:00,114
相应的结对数量是使用次数的倍数，

38
00:02:00,000 --> 00:02:02,120
因为如果我定义了一个变量，

39
00:02:02,122 --> 00:02:05,122
而会有3个不同的代码路径

40
00:02:05,125 --> 00:02:08,125
使用我所设置的3个不同的DU结对。

41
00:02:08,128 --> 00:02:11,128
还有一种处理覆盖的办法是将所有可能的DU结对的一部分

42
00:02:11,131 --> 00:02:14,131
在我的测试集中的某个位置执行。

43
00:02:14,134 --> 00:02:18,134
最近大家可能会听到黑盒测试、白盒测试的说法，

44
00:02:18,138 --> 00:02:21,138
有时人们会称白盒测试为玻璃箱测试。

45
00:02:21,141 --> 00:02:25,141
黑盒测试的理念就是

46
00:02:25,145 --> 00:02:28,145
当大家对实现并未掌握太多信息，

47
00:02:28,148 --> 00:02:30,148
或者大家真正关注的是针对外部规格的测试时具体该怎么做，

48
00:02:30,150 --> 00:02:35,150
与之相对应，白盒测试则是大家对实现的内容比较了解，

49
00:02:35,155 --> 00:02:37,155
而设计测试用例要应对的问题大家也比较清楚。

50
00:02:37,157 --> 00:02:40,157
这其中的一个简单示例就是

51
00:02:40,160 --> 00:02:43,160
如果在对一个哈希表进行编码，哈希表的黑盒定义

52
00:02:43,163 --> 00:02:46,163
是将键映射到相应的值，

53
00:02:46,166 --> 00:02:49,166
可是如果大家对哈希表内部使用的哈希函数有所了解，

54
00:02:49,169 --> 00:02:52,169
则可以创建一个玻璃箱或白盒测试，

55
00:02:52,172 --> 00:02:54,172
刻意制造哈希冲突，

56
00:02:54,174 --> 00:02:58,174
因为大家知道具体的工作原理。

57
00:02:58,178 --> 00:03:01,178
还有些关于测试的新名词，不过如果大家听说了黑盒或白盒测试，

58
00:03:01,181 --> 00:03:04,181
其实是一样的。我想说明的是

59
00:03:04,184 --> 00:03:07,184
大家已经了解该如何处理TDD，可是操作方法的顺序存在问题。

60
00:03:07,187 --> 00:03:10,187
我是这样来编码的，我已经做了保存，希望大家也是如此。

61
00:03:10,190 --> 00:03:13,190
不过我以前会编写一堆自以为正确的语句，

62
00:03:13,193 --> 00:03:16,193
运行这些语句时当然会有漏洞，

63
00:03:16,196 --> 00:03:18,196
“哎呀，这个漏洞蠢透了。

64
00:03:18,198 --> 00:03:21,198
这不是我的问题，就是太愚蠢。”没问题。

65
00:03:21,201 --> 00:03:24,201
我会中断调试器，会检查各种值。

66
00:03:24,204 --> 00:03:28,204
我还会打印输出，确保自己找到问题代码在哪。

67
00:03:28,208 --> 00:03:31,208
一旦当我暂停了调试器后，就会进行微调，

68
00:03:31,211 --> 00:03:34,211
或是设置其他变量，以确保这次一切顺利。“好了，继续。结果又出现故障。”

69
00:03:34,214 --> 00:03:37,214
当故障解决后，我相当自信，觉得已经搞定，

70
00:03:37,217 --> 00:03:40,217
这次应该是最后一个漏洞，当然事实绝非如此。

71
00:03:40,220 --> 00:03:43,220
在TDD中，所有这些相同的步骤一再出现，只是顺序不同。

72
00:03:43,223 --> 00:03:46,223
大家先写了几行语句，但是刚开始编写测试时，大家立刻就会知道

73
00:03:46,226 --> 00:03:49,226
自己写下的东西实在愚蠢，不必等到编写出大量语句之后再说。

74
00:03:49,229 --> 00:03:51,229
“哎呀，我犯了个拼写错误，”现在就发现问题，

75
00:03:51,231 --> 00:03:56,231
而不要等到以后自己在考虑其他问题时再说。

76
00:03:56,236 --> 00:03:58,236
不必到处添加print语句，只要在自己想做调整的内容上做出标记或存根，

77
00:03:58,238 --> 00:04:02,238
并明确期望值，在这一点

78
00:04:02,242 --> 00:04:05,242
该值或该变量应该是这样的值。

79
00:04:05,245 --> 00:04:07,245
当谈到调用方法时，使用应该等效或收到的内容。

80
00:04:07,247 --> 00:04:11,247
我暂停交互调试器的那部分内容会怎样呢，

81
00:04:11,251 --> 00:04:13,251
接下来我会尽量小心进行设置，

82
00:04:13,253 --> 00:04:16,253
这样我就会了解接下来会是哪些代码路径，

83
00:04:16,256 --> 00:04:20,256
相应的标记和存根又是哪些。

84
00:04:20,260 --> 00:04:23,260
我们刻意调用方法和Seams返回固定值，

85
00:04:23,263 --> 00:04:27,263
这样我们就可以知道接下来会下移至哪个代码路径。

86
00:04:27,267 --> 00:04:30,267
最后当我回到自以为修复的部分时，结果发现自己大错特错，

87
00:04:30,270 --> 00:04:32,270
如果大家已经完成测试的这一步，那只需再次运行测试，

88
00:04:32,272 --> 00:04:35,272
可以自动运行测试，而大家只需继续微调，直至一切正常为止。

89
00:04:35,275 --> 00:04:38,275
大家实际上已经完成了TDD所要求的全部内容。

90
00:04:38,278 --> 00:04:41,278
即使按照不同的顺序完成这些内容，

91
00:04:41,281 --> 00:04:45,281
所需的也是同样的技能。

92
00:04:45,285 --> 00:04:48,285
在我看来，大家已经培养出了相同的技能，

93
00:04:48,288 --> 00:04:51,288
只是需要将之……变得更为有效。

94
00:04:51,291 --> 00:04:54,291
还有一个不太明显的经验就是要在代码前编写测试，

95
00:04:54,294 --> 00:04:57,294
感觉上提前编写测试会更耗费时间，

96
00:04:57,297 --> 00:05:00,297
其实的确如此，因为大家并未意识到这样做的好处是什么。

97
00:05:00,000 --> 00:05:02,300
这样可以强迫大家思考代码将会怎样使用。

98
00:05:02,302 --> 00:05:05,302
这一点相当普遍……我敢肯定如下情况至少会发生一次，

99
00:05:05,305 --> 00:05:07,305


100
00:05:07,307 --> 00:05:11,307
你会编写自己知道会用到的方法，

101
00:05:11,311 --> 00:05:13,311
也清楚会用到什么函数，了解应该会返回什么内容，

102
00:05:13,313 --> 00:05:15,313
你完成编码，对自己颇感自豪。

103
00:05:15,315 --> 00:05:18,315
现在再回到准备使用该方法的代码部分，准备进行调用，

104
00:05:18,318 --> 00:05:20,318
结果你发现具体的调用方法并不十分正确。

105
00:05:20,320 --> 00:05:22,320
其实还另有参数需要传递，

106
00:05:22,322 --> 00:05:25,322
只是你没有想到，

107
00:05:25,325 --> 00:05:27,325
或者返回值并非是你实际需要的。

108
00:05:27,327 --> 00:05:30,327
如果返回值不同，可能还更方便一些。

109
00:05:30,330 --> 00:05:33,330
当你在实现TDD时，它会迫使你提前考虑那些内容，这也是其耗时较长的原因。

110
00:05:33,333 --> 00:05:35,333
在花时间填回方法时，

111
00:05:35,335 --> 00:05:38,335
你其实已经完成了某些设计工作，

112
00:05:38,338 --> 00:05:41,338
正像我说过的那样，有难度的工作都做完了。你明确了代码的结构，

113
00:05:41,341 --> 00:05:44,341
对怎样测试也了然于胸。实际上，考虑到这些约束，

114
00:05:44,344 --> 00:05:48,344
编写代码是件很容易的工作。

115
00:05:48,348 --> 00:05:51,348
这就是我觉得我们已经掌握的TDD的相关内容。

116
00:05:51,351 --> 00:05:53,351
大家学会了红－绿－重构，知道了测试失败的正确原因，

117
00:05:53,353 --> 00:05:56,353
接下来填回代码，

118
00:05:56,356 --> 00:05:59,356
并一直找机会进行美化。你的目标是把大部分时间用在绿色部分。

119
00:05:59,359 --> 00:06:03,359
当需要增加新测试时，也得处理红色部分，

120
00:06:03,363 --> 00:06:05,363
只要增加了测试，编写了最低数量的代码后，这部分内容就会变绿。

121
00:06:05,365 --> 00:06:08,365
考虑到这一点，还要一直要努力回到稳定状态。

122
00:06:08,368 --> 00:06:12,368
一次测试一种行为，

123
00:06:12,372 --> 00:06:15,372
我们已经看到大家如何对每个测试用例中发生的情况进行Seams密切控制。

124
00:06:15,375 --> 00:06:19,375
使用占位。我们见过这样的示例，

125
00:06:19,379 --> 00:06:22,379
当我们开始开发这些测试时会说可以实现这样那样的功能，

126
00:06:22,382 --> 00:06:25,382
却并未填入测试代码，

127
00:06:25,385 --> 00:06:28,385
至少这会起到占位的作用，以便提醒你稍后可以返回该测试上来。

128
00:06:28,388 --> 00:06:31,388
你甚至还可以使用待决关键词，

129
00:06:31,391 --> 00:06:33,391
这样每次在规格说明文件中运行这一案例时，你就会看到有短小的黄色信息显示。

130
00:06:33,393 --> 00:06:37,393
来看覆盖报告。

131
00:06:37,397 --> 00:06:39,397
我们将让你运行简单的cup,作为全面测试覆盖的一部分。

132
00:06:39,399 --> 00:06:43,399
值得一试，而且不用过分追求一定要实现100％的覆盖率，

133
00:06:43,403 --> 00:06:46,403
但问题是该区域代码的部分测试结果正常。

134
00:06:46,406 --> 00:06:50,406
看似这是在着手进行对其他测试并无太大帮助的内容。

135
00:06:50,410 --> 00:06:52,410
有一个原因表明

136
00:06:52,412 --> 00:06:54,412
许多不同种类的测试随着时间的推移都在发展进化，

137
00:06:54,414 --> 00:06:58,414
还有一个原因是说不同类型的测试将捕捉到不同的错误。

138
00:06:58,418 --> 00:07:01,418
这里有个关于测试的简单问题。

139
00:07:01,421 --> 00:07:05,421
下列哪个非显而易见的说法是错误的？

140
00:07:05,425 --> 00:07:08,425
即便你想选择的度量是100％的测试覆盖率也不能保证不存在漏洞。

141
00:07:08,428 --> 00:07:11,428
如果你可以通过调试器刺激引发漏洞的条件，

142
00:07:11,431 --> 00:07:13,431
那就可以在测试中捕捉到这一漏洞。

143
00:07:13,433 --> 00:07:17,433
假设你已完成第二项内容，测试可以不必再使用调试器。

144
00:07:17,437 --> 00:07:20,437
当修改代码时，也需要相应改变测试。

145
00:07:20,440 --> 00:07:24,440
这四种说法哪些是错误的呢？

