1
00:00:00,000 --> 00:00:02,000
从测试的计划到文档对象的角度，再最后讲些内容。

2
00:00:02,002 --> 00:00:07,002
我们最近在书中从计划到文档对象角度增添了很多内容，

3
00:00:07,007 --> 00:00:09,007
因为我们想要确定

4
00:00:09,009 --> 00:00:12,009
我们不希望被人误以为在传递这样的信息，

5
00:00:12,012 --> 00:00:15,012
敏捷编程方法一贯正确，而且是唯一正确的方法。

6
00:00:15,015 --> 00:00:19,015
实际上，在计划和文档对象中，有很多测试工作。

7
00:00:19,019 --> 00:00:22,019
实际上，对教室环境下的计划和文档对象有着这样的批评意见，

8
00:00:22,022 --> 00:00:24,022
有人感到有太多内容在实际编写代码过程中

9
00:00:24,024 --> 00:00:27,024
不甚理解。

10
00:00:27,027 --> 00:00:32,027
我们在BDD/TDD 敏捷极限法中见过这样的情况。

11
00:00:32,032 --> 00:00:34,032
我们在代码前编写测试。我们从用户故事开始入手。

12
00:00:34,034 --> 00:00:37,034
一般而言，开发人员要负责编写与自己代码相匹配的测试内容。

13
00:00:37,037 --> 00:00:40,037
问题是在计划和文档对象环境下，

14
00:00:40,040 --> 00:00:44,040
完成同样的任务会发生什么？

15
00:00:44,044 --> 00:00:47,044
这在P＆D系列方法中发挥着重要作用。

16
00:00:47,047 --> 00:00:50,047
有位项目经理正在制定项目管理计划，

17
00:00:50,050 --> 00:00:56,050
其中包括软件要求的规格说明文件、SRS，以及（也许诸位会有些奇怪）对的，

18
00:00:56,056 --> 00:00:58,056
还要有该如何编写SRS的标准。

19
00:00:58,058 --> 00:01:03,058
这个标准本身就可以是几十页的篇幅。

20
00:01:03,063 --> 00:01:06,063
SRS 非常庞大，其理念是要捕捉相关要求。

21
00:01:06,066 --> 00:01:10,066
它捕捉到测试计划，接着你就有了整体计划，

22
00:01:10,070 --> 00:01:13,070
现在需要将整体计划分割为编程单元，

23
00:01:13,073 --> 00:01:16,073
并基本上要将各单元的工作分配给不同的小组。

24
00:01:16,076 --> 00:01:19,076
不同的开发人员小组会安排负责不同的单元。

25
00:01:19,079 --> 00:01:21,079
他们会完成自己所负责的单元测试，

26
00:01:21,081 --> 00:01:24,081
可当所有的内容汇总到一起

27
00:01:24,084 --> 00:01:27,084
并进行系统和集成测试时，会有单独的QA小组负责这部分工作。

28
00:01:27,087 --> 00:01:31,087
QA小组可以通过不同的方式完成自己的工作。

29
00:01:31,091 --> 00:01:34,091
一种是自上而下的集成测试。

30
00:01:34,094 --> 00:01:37,094
这更像是从用户故事角度考虑问题，大家是从顶层来看问题，

31
00:01:37,097 --> 00:01:40,097
或是从客户角度来看应用程序应该做些什么，

32
00:01:40,100 --> 00:01:42,100
并且会驱使你尽早运行部分面对客户的功能，

33
00:01:42,102 --> 00:01:45,102
因此可以开始对其进行测试。

34
00:01:45,105 --> 00:01:47,105
另一方面，这也意味着你需要在这一层下面做很多存根，

35
00:01:47,107 --> 00:01:51,107
这样面对客户的功能就可以发挥作用。

36
00:01:51,111 --> 00:01:55,111
这相当于是用编码完成线框。

37
00:01:55,115 --> 00:01:57,115
还可以采取其他方法，比如我们搭建好局部，

38
00:01:57,117 --> 00:02:00,117
边做边汇总，并进行测试，

39
00:02:00,000 --> 00:02:03,120
但是这就意味着面对客户的功能实际上在一段时间内无法测试。

40
00:02:03,123 --> 00:02:07,123
按照这样的方法，

41
00:02:07,127 --> 00:02:10,127
优点是你对存根的依赖会很小。

42
00:02:10,130 --> 00:02:13,130
正如我们所知，依赖存根的问题是

43
00:02:13,133 --> 00:02:16,133
如果存根并未和现实情况同步，那么存根测试也会全部通过，

44
00:02:16,136 --> 00:02:20,136
可现实情况也可能是出现失败。

45
00:02:20,140 --> 00:02:23,140
第二种方法的缺点是当你可以将局部汇总到一起，

46
00:02:23,143 --> 00:02:25,143
开始删除存根时，已经为时已晚。

47
00:02:25,145 --> 00:02:30,145
三明治集成方法则是设法同时从两端解决问题。

48
00:02:30,150 --> 00:02:33,150
你可以从面对客户的内容向下处理，在所需的位置进行存根。

49
00:02:33,153 --> 00:02:37,153
你还可以从单元测试向上处理，并可开始将各模块汇总在一起。

50
00:02:37,157 --> 00:02:40,157
这一思路是说在任何一个具体时间点，

51
00:02:40,160 --> 00:02:43,160
你都会至少有一些面对客户的内容在与实际的应用程序代码进行交流，

52
00:02:43,163 --> 00:02:46,163
其他内容进行存根，

53
00:02:46,166 --> 00:02:48,166
不过二者是在同时进行。

54
00:02:48,168 --> 00:02:51,168
就像是从隧道的两端同时挖掘，因此可以两种方法都能适用。

55
00:02:51,171 --> 00:02:55,171
当你准备好进行更严肃的测试时，则可将之交给QA小组。

56
00:02:55,175 --> 00:02:58,175
他们将负责系统测试，

57
00:02:58,178 --> 00:03:01,178
在这时，他们其实是在测试整个应用。

58
00:03:01,181 --> 00:03:03,181
他们也会对非功能性要求进行测试，

59
00:03:03,183 --> 00:03:06,183
这部分内容会在我们学习操作时具体介绍。

60
00:03:06,186 --> 00:03:09,186
比如像性能，需要满足的性能目标，

61
00:03:09,189 --> 00:03:12,189
必须要满足的稳健性目标，以便保护应用程序的数据不受恶意攻击。

62
00:03:12,192 --> 00:03:16,192
他们怎样知道何时完成这些内容了呢？

63
00:03:16,196 --> 00:03:19,196
这取决于具体项目。有些情况下，这也取决于覆盖率和度量。

64
00:03:19,199 --> 00:03:22,199
我们见过不同版本的覆盖率。

65
00:03:22,202 --> 00:03:25,202
这些不仅是关于采用的控制路径，

66
00:03:25,205 --> 00:03:27,205
而且还有诸如覆盖的定义和使用，

67
00:03:27,207 --> 00:03:30,207
其中会涉及数据生成和数据消费，让你对所有这些路径进行测试。

68
00:03:30,210 --> 00:03:35,210
一旦当QA小组结束工作，现在就该是客户来进行测试了。

69
00:03:35,215 --> 00:03:41,215
大家现在就会明白为什么敏捷方法常常会把客户置于第一位。

70
00:03:41,221 --> 00:03:44,221
在用户验收测试时

71
00:03:44,224 --> 00:03:47,224
所出现的工作量对项目而言非常重要。

72
00:03:47,227 --> 00:03:50,227
假设客户在项目完成时会对其表示喜欢，

73
00:03:50,230 --> 00:03:53,230
这就是验证与确认技术，

74
00:03:53,233 --> 00:03:55,233
“相当于我是否搭建了正确的内容和我是否搭建正确相对比？”

75
00:03:55,235 --> 00:03:59,235
也许会在用户验收测试中，

76
00:03:59,239 --> 00:04:02,239
客户会改变主意。

77
00:04:02,242 --> 00:04:06,242
那么再次重申，敏捷并非适用于所有的项目，

78
00:04:06,246 --> 00:04:08,246
涉及到任务时，与计划和文档对象相比，

79
00:04:08,248 --> 00:04:12,248
敏捷的工作方法并无本质区别，

80
00:04:12,252 --> 00:04:14,252
但是任务都被分解为不同的顺序，而且你可以将之拆分为更小的部分。

81
00:04:14,254 --> 00:04:17,254
你还是会用到模拟，也要编写单元测试，

82
00:04:17,257 --> 00:04:20,257
还要完成集成测试，要把产品放在客户面前，

83
00:04:20,260 --> 00:04:22,260
但你一次只完成一小部分内容，

84
00:04:22,262 --> 00:04:26,262
接下来再回来去做另一部分内容。

85
00:04:26,266 --> 00:04:29,266
正如我们所知，我们看到在很早期的时候，通过测试可以发现漏洞的存在，

86
00:04:29,269 --> 00:04:34,269
而且漏洞永远都不会完全消失。那么，当我们无法进行测试时，又该如何是好呢？

87
00:04:34,274 --> 00:04:39,274
正式的方法是……对，我知道，

88
00:04:39,279 --> 00:04:42,279
Dave 用这些幻灯片做了个动画。 

89
00:04:42,282 --> 00:04:45,282
我可不能把那个开心跳舞的机器人归功于自己。

90
00:04:45,285 --> 00:04:48,285
正式方法是通过截然不同的方式实现程序的正确性。

91
00:04:48,288 --> 00:04:51,288
基本而言，测试是与工程相关。测试就是你获得了这个代码工件，

92
00:04:51,291 --> 00:04:54,291
希望看看它有什么作用。

93
00:04:54,294 --> 00:04:57,294
正式方式实际上就是对程序进行正式的表达，

94
00:04:57,297 --> 00:05:00,297
他们试图仅仅根据正式规范证明某些内容。

95
00:05:00,000 --> 00:05:03,300
例如，你可能希望确保程序永远不会进入某种状态。

96
00:05:03,303 --> 00:05:07,303
实际上，这对软硬件行业都会带来推动。

97
00:05:07,307 --> 00:05:13,307
就以最近的上个十年来说，以英特尔为例，

98
00:05:13,313 --> 00:05:16,313
它就曾针对多处理器系统的总线协议模型的建立使用正式验证。

99
00:05:16,316 --> 00:05:18,316
举例而言，因为你是想证明

100
00:05:18,318 --> 00:05:21,318
自己永远不会在事件序列后出现导致总线死锁的情况。

101
00:05:21,321 --> 00:05:25,321
这是个大问题，

102
00:05:25,325 --> 00:05:28,325
其中正式规格说明文件常常不一定是你从中可以生成程序代码的东西。

103
00:05:28,328 --> 00:05:31,328
你也许已经证明了正式规格说明文件是正确的

104
00:05:31,331 --> 00:05:34,331
也就是说它从未进入这些不良状态，

105
00:05:34,334 --> 00:05:37,334
不过你还是要证明需要搭建的内容也依旧按照正式规格说明文件进行，

106
00:05:37,337 --> 00:05:39,337
而这是另一个不同的问题。

107
00:05:39,339 --> 00:05:44,339
人类可以做出这样的证明，

108
00:05:44,344 --> 00:05:47,344
但更为普遍的是计算机通过定理证实完成这样的工作。你也可使用模型检测，

109
00:05:47,347 --> 00:05:50,347
这是符号执行和检测和结合……怎样的状态序列可能可达，

110
00:05:50,350 --> 00:05:54,350
这取决于输入值和控制路径。

111
00:05:54,354 --> 00:05:58,354
这些的运算量都相当大。

112
00:05:58,358 --> 00:06:01,358
它们常常被用于小规模的系统，

113
00:06:01,361 --> 00:06:04,361
那些修理造价高的系统，

114
00:06:04,364 --> 00:06:06,364
因为，举例而言，它们可能是远在太空，或很难测试。

115
00:06:06,366 --> 00:06:10,366
安全关键软件系统通常是这类极好的候选版本。

116
00:06:10,370 --> 00:06:14,370
给大家一些度量值作为参考，

117
00:06:14,374 --> 00:06:17,374
据我所知，经正式验证的最大项目是

118
00:06:17,377 --> 00:06:20,377
L4操作系统核心程序，约有1万行代码，

119
00:06:20,380 --> 00:06:24,380
相关研究工作按照每行代码计算需要$500。

120
00:06:24,384 --> 00:06:27,384
美国航空航天局已经设法超过了这一水平。

121
00:06:27,387 --> 00:06:30,387
航天飞机软件每行代码每年的维护成本约为$80。

122
00:06:30,390 --> 00:06:33,390
这些程序都不会进行太大的改变，

123
00:06:33,393 --> 00:06:37,393
改变的过程相当繁琐，

124
00:06:37,397 --> 00:06:39,397
不过在航天飞机上从未真正出现过软件失败的情况。

125
00:06:39,399 --> 00:06:43,399
如果使用正确，方法就会正常发挥作用。

126
00:06:43,403 --> 00:06:46,403
因为我们制作软件是要相对容易变化，

127
00:06:46,406 --> 00:06:49,406
便于修复，易于测试，

128
00:06:49,409 --> 00:06:51,409
在正式方法方面我们不会花费太多力气，

129
00:06:51,411 --> 00:06:53,411
不过我想说的是如果你准备在5年内进入软件工程领域，

130
00:06:53,413 --> 00:06:58,413
那么就可以发现这些会在许多公司中得到广泛应用。

131
00:06:58,418 --> 00:07:03,418
总而言之，在计划和文档对象领域以及与之相对的敏捷领域，

132
00:07:03,423 --> 00:07:05,423
我们实际从事的是同样的工作内容。

133
00:07:05,425 --> 00:07:07,425
我们都在创建客户规格说明文件、用户故事等，

134
00:07:07,427 --> 00:07:10,427
但是我们的工作顺序则完全不同，

135
00:07:10,430 --> 00:07:14,430
是在于各小组如何分解任务。并非是按照自上而下的计划并安排一个项目经理来负责项目，

136
00:07:14,434 --> 00:07:16,434
我们是分块逐行完成项目。

137
00:07:16,436 --> 00:07:21,436
让我们以非常快的速度判断有关正式方法的说法的正误，

138
00:07:21,441 --> 00:07:24,441
我们有3分钟的时间，这会很有趣。

139
00:07:24,444 --> 00:07:27,444
关于测试哪种说法是错误的？正式方法造价不菲，但对重要应用非常必要。

140
00:07:27,447 --> 00:07:32,447
在P＆D开发工作中，

141
00:07:32,452 --> 00:07:35,452
开发人员会在编写测试前进行编码，这与敏捷方法恰恰相反。

142
00:07:35,455 --> 00:07:38,455
敏捷开发人员会亲自进行模块集成、系统验收测试等工作，

143
00:07:38,458 --> 00:07:41,458
可P＆D开发人员通常不会自己完成这些工作，

144
00:07:41,461 --> 00:07:44,461
三明治集成方法在试图充分发挥两种领域中的优点，

145
00:07:44,464 --> 00:07:46,464
在降低存根数量的同时，

146
00:07:46,466 --> 00:07:50,466
还在早期实现部分一般性功能。哪种说法是错误的呢？

