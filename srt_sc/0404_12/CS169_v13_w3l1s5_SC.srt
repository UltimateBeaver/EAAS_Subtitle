00:00:00,000 --> 00:00:04,000
既然我们已经知道怎样在现代软件开发环境下测试工程了，

2
00:00:04,004 --> 00:00:07,004
接下来我们要来学习Rspec这个工具，

3
00:00:07,007 --> 00:00:09,007
本节课我们会使用Rspec来处理大部分测试。

4
00:00:09,009 --> 00:00:12,009
在介绍它之前，我先要讲一个缩写词，帮大家记住

5
00:00:12,012 --> 00:00:16,012
编写测试时的一些原则。

6
00:00:16,016 --> 00:00:20,016
单元测试应该是FIRST。

7
00:00:20,020 --> 00:00:23,020
大家可以借助缩写词FIRST

8
00:00:23,023 --> 00:00:25,023
记住编写单元测试的下列期望性质。测试应该快速（首字母F）。他们应该独立（首字母I）。

9
00:00:25,025 --> 00:00:29,025
他们应具有可重复性（首字母R）。他们应可以自检（首字母S），同时还应及时（首字母T）。

10
00:00:29,029 --> 00:00:33,029
简言之，这里面每个首字母有什么含义，我们为什么

11
00:00:33,033 --> 00:00:37,033
要留意它呢？快速就表示

12
00:00:37,037 --> 00:00:40,037
测试运行不需要很长时间。正如我们即将看到的那样，典型的应用程序，甚至是

13
00:00:40,040 --> 00:00:43,040
一个简单程序都含有成百上千个测试案例，

14
00:00:43,043 --> 00:00:46,043
所以要是测试运行花费很长时间，你在运行测试、编写

15
00:00:46,046 --> 00:00:49,046
测试及编写代码间转换时就会干扰你的工作流程。

16
00:00:49,049 --> 00:00:53,049
独立性表示

17
00:00:53,053 --> 00:00:56,053
你可以运行测试中任一子集，

18
00:00:56,056 --> 00:00:58,056
预计他们可以独立运行。换言之，

19
00:00:58,058 --> 00:01:02,058
不会依赖多个测试的运行顺序。这同样因为，

20
00:01:02,062 --> 00:01:05,062
在较大的应用程序中，即便测试快速运行，

21
00:01:05,065 --> 00:01:08,065
每次做个改动都要将整个测试套件运行一次的话，成本太高不可行。

22
00:01:08,068 --> 00:01:11,068
独立测试表示，你可以只运行

23
00:01:11,071 --> 00:01:14,071
最近代码改动影响的测试子集。

24
00:01:14,074 --> 00:01:17,074
重复性表示你每次运行，测试都会做同样的事情。

25
00:01:17,077 --> 00:01:20,077
现在，这看起来好像很明显，

26
00:01:20,080 --> 00:01:23,080
不过，我们这节课处理自检问题时，

27
00:01:23,083 --> 00:01:26,083
就要看到这样的现象，程序试图测试本质

28
00:01:26,086 --> 00:01:28,086
尚不确定的代码时，你是否能重复进行测试并不明确，

29
00:01:28,088 --> 00:01:33,088
这就好像你在掷硬币一样。

30
00:01:33,093 --> 00:01:35,093
自测表示无需人为检查测试结果，

31
00:01:35,095 --> 00:01:38,095
就可判定是否通过，

32
00:01:38,098 --> 00:01:41,098
所以测试在完成执行后会需要足够的信息，

33
00:01:41,101 --> 00:01:44,101
他要知道发生的事件对不对。

34
00:01:44,104 --> 00:01:47,104
我们关注这一点的原因和关注其他类型自动操作的原因一样。

35
00:01:47,107 --> 00:01:50,107
我们使测试套件自动运行、结果自动汇总时，

36
00:01:50,110 --> 00:01:54,110
我们就可以始终在后台运行重复性的任务。

37
00:01:54,114 --> 00:01:57,114
事实上，

38
00:01:57,117 --> 00:02:00,117
这正是我们在本节课内主张的观点，而这种重复性就表示

39
00:02:00,000 --> 00:02:02,120
你每次运行他们都会发生同样的事。

40
00:02:02,122 --> 00:02:06,122
自检时，他们（测试）会知道他们（自检对象）是否合格。

41
00:02:06,126 --> 00:02:09,126
最后，{及时性表示应以极为接近待测代

42
00:02:09,129 --> 00:02:13,129
码的方式及时编写测试。}这在我们打算

43
00:02:13,133 --> 00:02:16,133
做测试驱动开发或TDD时就已经说过了。

44
00:02:16,136 --> 00:02:18,136
这表示多数情况下，我们会在编写代码前就着手编写测试。

45
00:02:18,138 --> 00:02:21,138
在课程稍后，我们会教大家怎样做，

46
00:02:21,141 --> 00:02:24,141
不过眼下，最开始的几次作业，我们会

47
00:02:24,144 --> 00:02:27,144
给大家测试案例。

48
00:02:27,147 --> 00:02:33,147
现在我们要说明RSpec的工作原理，从而帮助我们运行这些案例。

49
00:02:33,153 --> 00:02:37,153
RSpec是测试使用的的特定领域语言，

50
00:02:37,157 --> 00:02:40,157
特定领域语言或DSL表示

51
00:02:40,160 --> 00:02:44,160
在牺牲一般性或牺牲其他任务的条件下，

52
00:02:44,164 --> 00:02:46,164
专用于处理一些有限的任务组。你们已经看过这方面的

53
00:02:46,166 --> 00:02:50,166
例子了。比方说，正则表达式是一种特定领域语言，

54
00:02:50,170 --> 00:02:53,170
用于表达不同强度类型的匹配类型。

55
00:02:53,173 --> 00:02:55,173
如果大家熟悉基于数据的编程，SQL，

56
00:02:55,175 --> 00:02:58,175
结构化查询语言就是一种用于基于数据查询的特定领域语言。

57
00:02:58,178 --> 00:03:02,178
不同于RSpec的是，它是植入Ruby的

58
00:03:02,182 --> 00:03:06,182
特定领域语言。这就是说，

59
00:03:06,186 --> 00:03:09,186
每个RSpec程序实际上都是一个有效的Ruby代码，

60
00:03:09,189 --> 00:03:11,189
它可以利用像诗歌模式的Ruby特性，从而提高可读性。

61
00:03:11,191 --> 00:03:17,191
这看起来像什么呢？看看第一组测试，

62
00:03:17,197 --> 00:03:21,197
我们正在描述一个名为甜品的类，这就是下次

63
00:03:21,201 --> 00:03:24,201
作业中要求你们创建的部分内容。

64
00:03:24,204 --> 00:03:26,204
第一个测试片段是关于特定种类的甜点或蛋糕的，

65
00:03:26,206 --> 00:03:30,206
而我们说的是我们测试的

66
00:03:30,210 --> 00:03:34,210
对象是一种新型的甜点，我们规定这种甜品是种含有400卡路里的蛋糕。

67
00:03:34,214 --> 00:03:38,214
一旦我们创建了新对象实例，这些非常简单的测试

68
00:03:38,218 --> 00:03:41,218
就包括查看各种属性，然后确保

69
00:03:41,221 --> 00:03:44,221
这些属性值就是我们基于构造函数的预计值。

70
00:03:44,224 --> 00:03:48,224
我们还有个好吃又有益健康的苹果。

71
00:03:48,228 --> 00:03:51,228
随着我们进一步研究这一类，我们会教大家怎样更为详尽地解释这些规格，

72
00:03:51,231 --> 00:03:54,231
不过现在，

73
00:03:54,234 --> 00:03:58,234
要注意的是，{像甲虫与健康之类的问题需要使用方法}—

74
00:03:58,238 --> 00:04:01,238
忘了实际上在你们的类里将方法称为美味问号与健康问号。

75
00:04:01,241 --> 00:04:03,241
大家阅读家庭作业时，

76
00:04:03,243 --> 00:04:05,243
就会明白要求你们写下这些方法是为了

77
00:04:05,245 --> 00:04:08,245
就甜点是否有益健康提供信息。

78
00:04:08,248 --> 00:04:13,248
RSpec测试又称规格或示例。

79
00:04:13,253 --> 00:04:17,253
每个规格或示例测试一个行为，要运行测试文件，有个方法是针对特定文件名

80
00:04:17,257 --> 00:04:20,257
运行RSpec命令，像我们刚才看过的文件名。

81
00:04:20,260 --> 00:04:24,260
你们将看到的是

82
00:04:24,264 --> 00:04:26,264
对失败测试以红色显示错误消息。

83
00:04:26,266 --> 00:04:30,266
合格的测试会以绿色显示。

84
00:04:30,270 --> 00:04:33,270
尚未执行的测试或所谓的待决测试会

85
00:04:33,273 --> 00:04:36,273
以黄色显示。现在，正像我说的那样，一个大型项目可含有遍布数百个文件的

86
00:04:36,276 --> 00:04:40,276
上千个测试案例，而针对每个文件，甚或整个套件运行RSpec

87
00:04:40,280 --> 00:04:43,280
可能效率都不好。

88
00:04:43,283 --> 00:04:46,283
所以作为代替，我们更喜欢这一运用自动测试的其他技术，

89
00:04:46,286 --> 00:04:49,286
这是个好工具，不仅可以

90
00:04:49,289 --> 00:04:52,289
运行所有RSpec测试，还可在你随时更改测试代码

91
00:04:52,292 --> 00:04:55,292
或更改应用程序代码时，自动测试均会指出

92
00:04:55,295 --> 00:04:58,295
需要重新运行哪些测试。它还会自动运行相应测试。

93
00:04:58,298 --> 00:05:00,298
它始终在后台运行。

94
00:05:00,000 --> 00:05:04,300
我们接下来看我示范这是怎么工作的。我打算跳到……

95
00:05:04,304 --> 00:05:19,304
好，这基本上就是同

96
00:05:19,319 --> 00:05:27,319
学们第一次家庭作业拿到的目录内容。

97
00:05:27,327 --> 00:05:30,327
这里约有五六个满是测试的文件，

98
00:05:30,330 --> 00:05:34,330
都是我们为大家创建的。现在我从他们当中挑一个出来。

99
00:05:34,334 --> 00:05:38,334
这个名为“字符串的乐趣示例”。正如你们看到的这样，

100
00:05:38,338 --> 00:05:41,338
这儿有个惯例，{我使用强调规格遵循文件名的名称时，

101
00:05:41,341 --> 00:05:44,341
这表示该规格符合那一类。}

102
00:05:44,344 --> 00:05:47,344
我打算进入这个目录，然后运行自动测试。

103
00:05:47,347 --> 00:05:53,347
如果我向上移动经过这里，你们会看到许多黄色消息，都是等待处理的消息。

104
00:05:53,353 --> 00:05:56,353
这是说，“没给原因。他们就是黄色的，

105
00:05:56,356 --> 00:05:58,356
可我也不知道他们为什么是黄色的。“

106
00:05:58,358 --> 00:06:00,358
嗯，原因在我们一开始给你们的测试文件里，

107
00:06:00,000 --> 00:06:05,360
所有测试组均标记为待决真，这表示“因为代码还不在

108
00:06:05,365 --> 00:06:09,365
那儿，就别费事儿运行这些测试了”

109
00:06:09,369 --> 00:06:13,369
现在，假设我删除

110
00:06:13,373 --> 00:06:17,373
这些测试中一段的待决真，你们就能看到这儿有三个不同的测试。

111
00:06:17,377 --> 00:06:19,377
这应该用于简单的字符串。

112
00:06:19,379 --> 00:06:22,379
它应该不区分大小写。它应该忽视

113
00:06:22,382 --> 00:06:24,382
非文字的字符。现在我要保存这个文件，

114
00:06:24,384 --> 00:06:30,384
然后我不做任何事，我们就这么干，准备好了吗？来看文件。噢！它工作了。

115
00:06:30,390 --> 00:06:33,390
现在它显示，“三个失败示例，”事实上这三个示例就是我

116
00:06:33,393 --> 00:06:35,393
之前看的第5、9和12行，

117
00:06:35,395 --> 00:06:38,395
现在试着运行他们，然后重新分切器应该自己显示

118
00:06:38,398 --> 00:06:42,398
【无声00:06:38】，可它没有，

119
00:06:42,402 --> 00:06:44,402
所以家庭作业标识符的肉块需要编写代码实现这个操作，

120
00:06:44,404 --> 00:06:48,404
不过你们刚才看的是我更改了测试文件内的内容。

121
00:06:48,408 --> 00:06:50,408
自动测试立刻指出我做了哪些变化，然后只尝试重新运行那些测试。

122
00:06:50,410 --> 00:06:55,410
如果我改变我的代码文件，自动测试

123
00:06:55,415 --> 00:06:58,415
会指出过去哪些测试用过那个代码文件，

124
00:06:58,418 --> 00:07:01,418
所以它会针对我更新的代码运行测试，

125
00:07:01,421 --> 00:07:03,421
因此它只在后台运行自动测试，而随着你更改测试文件内的代码，

126
00:07:03,423 --> 00:07:06,423
如果你填回通过测试的必要代码，你会看到

127
00:07:06,426 --> 00:07:09,426
这些行全部一次性变成绿色。


