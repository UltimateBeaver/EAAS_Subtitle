00:00:00,000 --> 00:00:04,000
我们已讲过客户端与服务器期间的简单协议。

2
00:00:04,004 --> 00:00:09,004
也讲过你想要得到的URI与HTTP名称的想法。

3
00:00:09,009 --> 00:00:12,009
下面要讲的逻辑内容是

4
00:00:12,012 --> 00:00:15,012
你可以拿什么还给浏览器？我猜，大家或多或少都{潜移默化}看见过HTML。

5
00:00:15,015 --> 00:00:20,015
只是要提醒大家我们在这儿，

6
00:00:20,020 --> 00:00:23,020
我们仍处于第二层次，不过现在我们要看看

7
00:00:23,023 --> 00:00:25,023
客户那端发生了什么。到目前为止，

8
00:00:25,025 --> 00:00:27,025
我们大多关注这幅图的服务器端。

9
00:00:27,027 --> 00:00:33,027
HTML的目的是借助把这个加入像这个的东西里面，从这个里面得出结果。

10
00:00:33,033 --> 00:00:38,033
简单的HTML实际上是一种标记语言。这表示

11
00:00:38,038 --> 00:00:40,038
信不信由你，除非你能在其他网站上看过什么，否则它就用来描述

12
00:00:40,040 --> 00:00:44,040
网页上的文本结构，

13
00:00:44,044 --> 00:00:46,044
而不是文本的外观。这是另一项工作。

14
00:00:46,046 --> 00:00:50,046
超文字标记语言实际上拥有相当

15
00:00:50,050 --> 00:00:54,050
漫长而辉煌的历史，这我们不会提到，

16
00:00:54,054 --> 00:00:57,054
不过可以告诉你的是它源于IBM发明的一种标记语言，最初

17
00:00:57,057 --> 00:01:00,057
用于六十年代阅读商业文本使用，

18
00:01:00,000 --> 00:01:03,060
它可以制作出机器可读取的商业文本。

19
00:01:03,063 --> 00:01:06,063
HTML文本实际上是元素的层次结构。这表示

20
00:01:06,066 --> 00:01:11,066
一个元素可以包括其他的子元素。

21
00:01:11,071 --> 00:01:13,071
其中有些元素代表多多少少刚好内嵌于页面的内容，像

22
00:01:13,073 --> 00:01:18,073
文本、标题、表格、段落。

23
00:01:18,078 --> 00:01:21,078
有时标识符表示内嵌内容，虽脱离于页面本身，但

24
00:01:21,081 --> 00:01:23,081
可随页面一同加载，例如

25
00:01:23,083 --> 00:01:27,083
图片或JavaScript代码。有时标识符代表

26
00:01:27,087 --> 00:01:30,087
形式，向用户提供方法以便进行输入、点

27
00:01:30,090 --> 00:01:33,090
击按钮并填入文本，然后提供给服务器，

28
00:01:33,093 --> 00:01:37,093
这样让它做些事。标识符围绕或限制着HTML内的元素。

29
00:01:37,097 --> 00:01:40,097
标识符在尖括号内显示，

30
00:01:40,100 --> 00:01:45,100
结束标识符含有尖括号和斜杠。

31
00:01:45,105 --> 00:01:48,105
有些标识符含有内容。例如，这有一个段落或P标识符

32
00:01:48,108 --> 00:01:52,108
该标识符的内容是字符串“你好世界”。有些含有属性。

33
00:01:52,112 --> 00:01:55,112
例如，这儿是图片标识符，它包含的

34
00:01:55,115 --> 00:01:57,115
属性源会告诉浏览器

35
00:01:57,117 --> 00:02:02,117
图片的位置。有些标识符既有属性又有内容。

36
00:02:02,122 --> 00:02:05,122
鉴于它是元素的层次结构，标识符通常还含有其他标识符。

37
00:02:05,125 --> 00:02:09,125
现在，对于标识符可含有的各种属性，

38
00:02:09,129 --> 00:02:11,129
我们要格外关注两个属性，因为

39
00:02:11,131 --> 00:02:14,131
在描述页面结构时他们特别有用，

40
00:02:14,134 --> 00:02:18,134
借助这两个标识符，你可以轻松设置页面风格，他们就是ID与

41
00:02:18,138 --> 00:02:22,138
类属性。我们之所以这么关注，部分原因是我们想要控制网

42
00:02:22,142 --> 00:02:25,142
页的外观，想让他们看上去更美观。

43
00:02:25,145 --> 00:02:27,145
我们想要以符合页面结构的方式

44
00:02:27,147 --> 00:02:30,147
实现着一点。正如我们所看到的那样，

45
00:02:30,150 --> 00:02:33,150
要保持结构与外观问题完全独立有多个原因。

46
00:02:33,153 --> 00:02:37,153
层叠样式表或CSS可

47
00:02:37,157 --> 00:02:40,157
帮助我们实现这一点。我们使用层叠样式表的方法是

48
00:02:40,160 --> 00:02:44,160
我们会在页面顶部设置识别链接的元素。

49
00:02:44,164 --> 00:02:46,164
事实上，它会进入Head元素，Head的子元素之一

50
00:02:46,166 --> 00:02:50,166
会说明，“这是一个样式表，而这是您下载该样式表的来源URI”。

51
00:02:50,170 --> 00:02:54,170
样式表和其他的东西一样，不过是

52
00:02:54,174 --> 00:02:58,174
URI访问网络资源而已。我们讨论CSS时

53
00:02:58,178 --> 00:03:01,178
最常用的HTML元素是ID与类元素，

54
00:03:01,181 --> 00:03:04,181
这是因为借助他们，我们有了个非常简单的方法可以

55
00:03:04,184 --> 00:03:08,184
迅速识别目标元素或元素群，这样我们就能

56
00:03:08,188 --> 00:03:11,188
向目标元素或元素群运用共同的视觉样式组。举个简单的例子，

57
00:03:11,191 --> 00:03:15,191
我有Div元素，这是在结构上识别不同文件组成部分的方法，

58
00:03:15,195 --> 00:03:18,195
然后我给它一个“right”的ID与

59
00:03:18,198 --> 00:03:22,198
“content”类。这个ID在

60
00:03:22,202 --> 00:03:26,202
页面范围内是独一无二的，所以在这个页面内的任何地方，除了这个Div元素

61
00:03:26,206 --> 00:03:29,206
外，再没有任何类型的任何元素拥有相同的“right”ID。

62
00:03:29,209 --> 00:03:32,209
类可以依附于多个元素。

63
00:03:32,212 --> 00:03:34,212
甚至可以依附于不同类型的元素。

64
00:03:34,214 --> 00:03:37,214
在这个页面完全可以有多个其他元素共享这个内容类。

65
00:03:37,217 --> 00:03:42,217
我们怎样使用他们呢？

66
00:03:42,222 --> 00:03:46,222
一般说来，我们把CSS选择器当做识别要素的方法，

67
00:03:46,226 --> 00:03:49,226
借助它识别我们想要运用某一视觉造型的目标要素。

68
00:03:49,229 --> 00:03:52,229
我们可以举个非常简单的例子，以此为基础说明一些选择

69
00:03:52,232 --> 00:03:55,232
器的运行方式。要选定元素，最简单的方法是通过标识符的名称。

70
00:03:55,235 --> 00:03:59,235
这个选择器会说所有含H1标识符的元素，

71
00:03:59,239 --> 00:04:02,239
而不考虑他们的类或ID，这实在是宽泛的划分。

72
00:04:02,242 --> 00:04:04,242
通常远比大家需要的宽泛得多。

73
00:04:04,244 --> 00:04:09,244
我们还可以限制它，说只要含有某一类的元素，

74
00:04:09,249 --> 00:04:12,249
于是在此情况下在这里唯一符合此Div

75
00:04:12,252 --> 00:04:17,252
的就是类pageFrame，或者我们也可以用特有的ID匹配元素。

76
00:04:17,257 --> 00:04:21,257
要记住的是，我们说过报头，在此时

77
00:04:21,261 --> 00:04:24,261
ID在页面上是独一无二的。只有一个元素可以拥有报头ID，

78
00:04:24,264 --> 00:04:27,264
果然它就是相同的Div。此时，在此情况下我已经

79
00:04:27,267 --> 00:04:30,267
写了两个不同的选择器，它们都符合此

80
00:04:30,270 --> 00:04:33,270
外部Div。通常，你们要小心不要在CSS文件内

81
00:04:33,273 --> 00:04:35,273
做这样的事，因为你随后就要为复杂的规则大伤脑筋了，

82
00:04:35,275 --> 00:04:38,275
这里的规则指数条规则匹配时要选用何组规则。

83
00:04:38,278 --> 00:04:41,278
如果你正在使用不错的CSS编辑程序，

84
00:04:41,281 --> 00:04:43,281
通常就会提醒你是不是不小心

85
00:04:43,283 --> 00:04:47,283
做了类似这个的什么操作。我们还可使用结合类的标识符名称，

86
00:04:47,287 --> 00:04:51,287
所以这会匹配内含页框ID的所有Div元素，

87
00:04:51,291 --> 00:04:54,291
或者我们可使用识别符名称与ID，

88
00:04:54,294 --> 00:04:57,294
不过你毫无疑问已经意识到这通常是多余的，

89
00:04:57,297 --> 00:05:03,297
为什么呢？因为如果一个ID在页面上是独一无二的，那么

90
00:05:03,303 --> 00:05:05,303
只有一个元素拥有该ID，因此为什么要那么费事说元素识别符呢？

91
00:05:05,305 --> 00:05:09,305
你会那样做的原因实在让人大开眼界。

92
00:05:09,309 --> 00:05:12,309
对于查看CSS文件想要改动的设计者，

93
00:05:12,312 --> 00:05:15,312
这个符号等于特别告诉他们欢迎改动……

94
00:05:15,315 --> 00:05:18,315
ID是欢迎的元素通常都是图片元素。

95
00:05:18,318 --> 00:05:21,318
这很有用，因为有些

96
00:05:21,321 --> 00:05:24,321
样式只在适用于特定元素类型时才有意义。

97
00:05:24,324 --> 00:05:26,324
借助更有趣的选择器版本，你可以使用派生的关系。

98
00:05:26,326 --> 00:05:30,326
例如，我可以说，我想要匹配具有卡斯特

99
00:05:30,330 --> 00:05:34,330
名称类的任一元素，可只有在其内部元素符合Div时方才匹配。

100
00:05:34,334 --> 00:05:38,334
在我们的例子中，我们有一个Div

101
00:05:38,338 --> 00:05:41,338
元素在这儿，内部子元素中有一个确实有CSS类。

102
00:05:41,341 --> 00:05:47,341
在我们的案例中，这整个"Span"元素都是

103
00:05:47,347 --> 00:05:52,347
Div空格卡斯特名称匹配的对象。如果我们没有具体规定

104
00:05:52,352 --> 00:05:55,352
元素的任何式样，然后无论母元素得到什么，它都会

105
00:05:55,355 --> 00:05:59,355
默认继承这些属性。现在，

106
00:05:59,359 --> 00:06:02,359
圣杯，就是分离标记、结构标记的目标，

107
00:06:02,362 --> 00:06:06,362
像使用CSS从视觉表示中分离出HTML一样，这实际上可以使这两个完全分离。

108
00:06:06,366 --> 00:06:09,366
有个原因是，打个比方说

109
00:06:09,369 --> 00:06:13,369
残疾人也许会借助阅读软件

110
00:06:13,373 --> 00:06:16,373
获取HTML页面，然后为他们阅读内容，同时他们还可以借助该软件

111
00:06:16,376 --> 00:06:19,376
进行导航。如果你在样式信息内混入你的HTML结构内容，

112
00:06:19,379 --> 00:06:22,379
这就会给阅读器程序

113
00:06:22,382 --> 00:06:25,382
带来大麻烦。你也许会想

114
00:06:25,385 --> 00:06:27,385
如果你试图实实在在地从CSS分离出HTML标记，

115
00:06:27,387 --> 00:06:31,387
你可以进行到哪一步？

116
00:06:31,391 --> 00:06:36,391
就给大家举个例子吧，这儿有一个名为CSS Zen Garden的网站，

117
00:06:36,396 --> 00:06:39,396
实际上这只是CSS作用的图例。

118
00:06:39,399 --> 00:06:43,399
我现在正处于这儿的Safari浏览器，借助该浏览器我可以禁用

119
00:06:43,403 --> 00:06:46,403
样式表。如果未应用任何CSS样式，这个页面会成什么样子呢？

120
00:06:46,406 --> 00:06:52,406
它看上去会是这样，非常基础，

121
00:06:52,412 --> 00:06:54,412
但要注意的是页面的结构非常明晰。

122
00:06:54,414 --> 00:06:56,414
我们立刻知道标题、主副标题都在哪儿。

123
00:06:56,416 --> 00:06:59,416
我们可以看到明显用为符号项列表的东西。

124
00:06:59,419 --> 00:07:02,419
我们还可以看到这些东西的表示顺序。

125
00:07:02,422 --> 00:07:10,422
如果我们放回样式，最引人注意的就是

126
00:07:10,430 --> 00:07:13,430
我们可以选择不同的样式组。我们来点击底部这些里面的任意一项。

127
00:07:13,433 --> 00:07:20,433
在这儿有趣儿的是HTML文本没有任何变化。

128
00:07:20,440 --> 00:07:24,440
事实上，如果我返回去，再次禁用样式，

129
00:07:24,444 --> 00:07:29,444
大家看到的会是和前面我们看到的完全相同的HTML内容，

130
00:07:29,449 --> 00:07:37,449
不过页面看上去完全不同。

131
00:07:37,457 --> 00:07:40,457
这多少算是个极端的例子，事实上你可以

132
00:07:40,460 --> 00:07:45,460
通过这里点击查看其他样式，像名为“吉米”的机器人。

133
00:07:45,465 --> 00:07:48,465
这个例子旨在说明你可以单单使用CSS

134
00:07:48,468 --> 00:07:53,468
就可实现大量视觉样式，所以不要把样式信息与你的标记

135
00:07:53,473 --> 00:07:54,473
搅在一起。


