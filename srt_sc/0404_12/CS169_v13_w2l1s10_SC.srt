1
00:00:00,000 --> 00:00:03,000
现在来看教材。我们来谈谈代码。

2
00:00:03,003 --> 00:00:06,003
我们先快速介绍一下Ruby语言。

3
00:00:06,006 --> 00:00:09,006
当然，大家已经知道要学习一种计算机语言，

4
00:00:09,009 --> 00:00:13,009
最好的办法就是用它编程。我要从

5
00:00:13,013 --> 00:00:16,013
"这是循环语句，而这是字符串。"开始。

6
00:00:16,016 --> 00:00:19,016
这些你们都已经懂了。这是一种对Ruby语言的高层次的介绍，

7
00:00:19,019 --> 00:00:21,019
适用于学过JAVA的人。而且

8
00:00:21,021 --> 00:00:25,021
在加州大学伯克利分校，你们很多人还学过61A结构和

9
00:00:25,025 --> 00:00:27,025
计算机程序解释，这里你们会发现那些课程里面的概念将会很有用。

10
00:00:27,027 --> 00:00:31,027
至于社会听众，

11
00:00:31,031 --> 00:00:34,031
如果不熟悉这些概念也没关系，

12
00:00:34,034 --> 00:00:37,034
我们会讲到这些又酷又给力的概念的。

13
00:00:37,037 --> 00:00:42,037
先来看看这个清单。什么是Ruby语言？

14
00:00:42,042 --> 00:00:45,042
它是一种解释性语言，运行之前不需要编译。

15
00:00:45,045 --> 00:00:48,045
它是面向对象的语言，一会我们会看到，

16
00:00:48,048 --> 00:00:50,048
它将面向对象提升到最新的高度，

17
00:00:50,050 --> 00:00:54,050
这超过你们很多人习以为常的内容，因为在这种语言里，

18
00:00:54,054 --> 00:00:58,054
包括整数型在内的一切都是一个真正的对象。

19
00:00:58,058 --> 00:01:01,058
要想用这种语言完成一项任务，必须根据对象调用特定方法。

20
00:01:01,061 --> 00:01:03,061
听着有点奇怪，但一旦习惯了，就会发现这是

21
00:01:03,063 --> 00:01:07,063
一种非常强大的简化规则。它是一种动态类型语言。

22
00:01:07,067 --> 00:01:09,067
这是什么意思呢？就是说这种语言里有类型，

23
00:01:09,069 --> 00:01:13,069
但变量没有。有类型的是对象，

24
00:01:13,073 --> 00:01:16,073
但同样的变量有时可以是整数型，有时可以是其他东西。

25
00:01:16,076 --> 00:01:19,076
关于它是一种动态语言这一点，

26
00:01:19,079 --> 00:01:23,079
在接下来的几节课里，

27
00:01:23,083 --> 00:01:26,083
希望我们能碰到一些特定例子来解释这一点。

28
00:01:26,086 --> 00:01:30,086
书面意思就是，程序开始后，

29
00:01:30,090 --> 00:01:33,090
你可以在运行之中做任何事。

30
00:01:33,093 --> 00:01:36,093
可以添加或修改代码，

31
00:01:36,096 --> 00:01:39,096
可以在代码开始后改变现有方法的定义，

32
00:01:39,099 --> 00:01:43,099
可以向对象提出关于它们自己的问题，也可以根据那些属性创建新对象。

33
00:01:43,103 --> 00:01:47,103
这些之所以重要，是因为

34
00:01:47,107 --> 00:01:50,107
编程因此变得简单，

35
00:01:50,110 --> 00:01:53,110
代码也更容易维护。每次我举例时，

36
00:01:53,113 --> 00:01:56,113
我都重点介绍这种特性如何

37
00:01:56,116 --> 00:01:58,116
帮助你编写更好的代码。

38
00:01:58,118 --> 00:02:03,118
它如何使你的代码更易读？他如何...

39
00:02:03,123 --> 00:02:05,123
它如何让你感觉你的活儿干得更漂亮？

40
00:02:05,125 --> 00:02:07,125
就好像将一件高雅的雕塑重新打磨一样。

41
00:02:07,127 --> 00:02:13,127
它的意义就在此。我所讲的是代码之美。

42
00:02:13,133 --> 00:02:17,133
这些有些基本的起步原理。类名称。对，Ruby是有类的。

43
00:02:17,137 --> 00:02:19,137
你们会发现它们在这里

44
00:02:19,139 --> 00:02:21,139
不如在其他语言中那么重要。[elites 00:02:22]

45
00:02:21,141 --> 00:02:25,141
在其他语言中，比如JAVA，类取决于能做什么。

46
00:02:25,145 --> 00:02:28,145
你能做什么决定了你是什么类。

47
00:02:28,148 --> 00:02:31,148
Ruby不一样，它是一种“精英语言”。

48
00:02:31,151 --> 00:02:34,151
你能做什么只取决于你的能力。

49
00:02:34,154 --> 00:02:38,154
而类并没有那么重要。这是对的。

50
00:02:38,158 --> 00:02:40,158
类名称采取驼峰命法。如果你从没见过这个词，

51
00:02:40,160 --> 00:02:44,160
你也能猜出这个术语的来源。

52
00:02:44,164 --> 00:02:49,164
方法和变量通常调用下划线风格。

53
00:02:49,169 --> 00:02:52,169
至于方法名称，你会看到它们有时以问号结尾。

54
00:02:52,172 --> 00:02:55,172
对于以"true"或"false"返回的方法，这是很常见的。

55
00:02:55,175 --> 00:02:59,175
有些方法可以用来问关于对象的问题。

56
00:02:59,179 --> 00:03:02,179
有时你看到方法名称以bang结尾，

57
00:03:02,182 --> 00:03:05,182
不是说真的"嘭"地一声响，

58
00:03:05,185 --> 00:03:08,185
而是以感叹号结尾。[ ask 00:03:07] 

59
00:03:08,188 --> 00:03:10,188
Bang字符通常意味着这是一种危险方法。

60
00:03:10,190 --> 00:03:14,190
如果不小心，调用这种方法可能造成意外的副作用。

61
00:03:14,194 --> 00:03:17,194
后面会看到。还有常量，

62
00:03:17,197 --> 00:03:21,197
通常都是大写，大驼峰格式。还有GLOBALS，全局变量，

63
00:03:21,201 --> 00:03:24,201
但这种变量很讨厌，所以我们不用。

64
00:03:24,204 --> 00:03:27,204
还有符号。如果以前学过的语言中没有符号概念，

65
00:03:27,207 --> 00:03:29,207
那这可能是你们遇到的第一个障碍。

66
00:03:29,209 --> 00:03:33,209
什么是符号？从句法上解释，

67
00:03:33,213 --> 00:03:37,213
符号就是冒号后面跟着一串字母、下划线和数字。

68
00:03:37,217 --> 00:03:42,217
符号其实就是不变字符串，

69
00:03:42,222 --> 00:03:45,222
其值就是它本身。很多时候，

70
00:03:45,225 --> 00:03:49,225
你会发现Ruby和Rails框架中有些方法看起来

71
00:03:49,229 --> 00:03:52,229
好像用符号或字符串都可以。

72
00:03:52,232 --> 00:03:54,232
符号和字符串不同，二者很容易转换。

73
00:03:54,234 --> 00:03:58,234
There's methods two s and two [ sim 00:03:56]

74
00:03:58,238 --> 00:04:01,238
什么时候我们才会调用符号而不用字符串？它们为什么存在？

75
00:04:01,241 --> 00:04:04,241
通常我们会发现，一旦涉及符号，就意味着特殊性。

76
00:04:04,244 --> 00:04:08,244
如果我看到一个函数里面有符号、冒号和Rails，

77
00:04:08,248 --> 00:04:13,248
我的解释是：

78
00:04:13,253 --> 00:04:15,253
Rails是一小群特殊值中的一个，

79
00:04:15,255 --> 00:04:18,255
其函数应该理解。

80
00:04:18,258 --> 00:04:21,258
该函数不是要处理任意字符串。可能情况不总是如此，

81
00:04:21,261 --> 00:04:23,261
但一般都是这样，后面有很多例子。

82
00:04:23,263 --> 00:04:27,263
变量、数组和散列。

83
00:04:27,267 --> 00:04:30,267
你们都学过JAVA，这些应该很容易理解。

84
00:04:30,270 --> 00:04:33,270
没有声明，本学期都不用再学声明了。

85
00:04:33,273 --> 00:04:36,273
可以有局部变更，但使用前应先分配。

86
00:04:36,276 --> 00:04:39,276
我们会看到，在定义类和对象时，

87
00:04:39,279 --> 00:04:42,279
类变量的实例出现时是零值，

88
00:04:42,282 --> 00:04:45,282
在首次分配之前，这个值在Ruby中是"false"。

89
00:04:45,285 --> 00:04:49,285
记住，我说过

90
00:04:49,289 --> 00:04:52,289
变量没有类型，但对象有类型。

91
00:04:52,292 --> 00:04:55,292
这里是变量X，我将其分配给一个整数型，

92
00:04:55,295 --> 00:04:58,295
然后分配给一个字符串，这完全可以。

93
00:04:58,298 --> 00:05:02,298
整数型和字符串是不同的类型，不同的类。

94
00:05:02,302 --> 00:05:07,302
指代它们的变量不一定有类型。

95
00:05:07,307 --> 00:05:10,307
我们不能这么做，因为没有声明，对吧？

96
00:05:10,310 --> 00:05:12,310
有类整数型，但不能把类放在变量前，

97
00:05:12,312 --> 00:05:15,312
变量没有类。如果你一直从事JAVA，

98
00:05:15,315 --> 00:05:19,315
这里有些做法会突破你一直以来养成的习惯。

99
00:05:19,319 --> 00:05:24,319
有数组，老式的一维数组。

100
00:05:24,324 --> 00:05:27,324
从这个简单的例子可以看出，

101
00:05:27,327 --> 00:05:31,327
数组不一定要所有对象都一样。

102
00:05:31,331 --> 00:05:35,331
在JAVA里，你可以说一个数组事件或一个foo bar数组。Ruby就是一个数组，

103
00:05:35,335 --> 00:05:37,335
可以包括任何元素，

104
00:05:37,337 --> 00:05:40,337
而那些元素都可以不一样。我们可以用下标分配这些元素，

105
00:05:40,340 --> 00:05:44,340
下标为零基；也可以问数组有多长。

106
00:05:44,344 --> 00:05:46,344
我们会讲到更多有趣的数组方法，

107
00:05:46,346 --> 00:05:48,346
其运行模式你们是可以预见的。

108
00:05:48,348 --> 00:05:52,348
还有散列，在有些语言中，

109
00:05:52,352 --> 00:05:55,352
它们叫做关联数组。如果你有Pearl语言编过程，

110
00:05:55,355 --> 00:05:58,355
你可能比较习惯。Python也有，Python直接称之为

111
00:05:58,358 --> 00:06:01,358
dict或词典。

112
00:06:01,361 --> 00:06:04,361
这是散列表字面量，放在括号里。再问一次，什么是散列？

113
00:06:04,364 --> 00:06:08,364
是从键到值的映像。由于变量不一定要有类型，

114
00:06:08,368 --> 00:06:11,368
键和键值都可以是任何类型，

115
00:06:11,371 --> 00:06:15,371
而且类型不一定一致。

116
00:06:15,375 --> 00:06:18,375
这个散列有两个键，一个是单一字符串A，

117
00:06:18,378 --> 00:06:21,378
另一个是符号B。记住，

118
00:06:21,381 --> 00:06:27,381
那和字符串不一样。事实上，

119
00:06:27,387 --> 00:06:31,387
符号B的键值是一个数组。和数组中一样，

120
00:06:31,391 --> 00:06:34,391
我们可以混合键和值的类型；可以对数组解引用，

121
00:06:34,394 --> 00:06:39,394
将其设置为零。

122
00:06:39,399 --> 00:06:42,399
可以问散列，其键是什么，从而得到老式的数组，

123
00:06:42,402 --> 00:06:46,402
这个数组就是一份随意排列的散列键清单，

124
00:06:46,406 --> 00:06:50,406
有办法可以检查列出的键。

125
00:06:50,410 --> 00:06:54,410
方法，一切都靠引用，除了整数型之外。

126
00:06:54,414 --> 00:06:57,414
一会儿会讲到这个。我可以定义一个单独的...

127
00:06:57,417 --> 00:07:01,417
这是一个foo函数，有两个参数，

128
00:07:01,421 --> 00:07:06,421
可以返回数组或包括两项内容的列表。

129
00:07:06,426 --> 00:07:09,426
我可以定义含有可选值参数的函数。就是说，

130
00:07:09,429 --> 00:07:11,429
调用foo函数时，第二个参数是可选的，

131
00:07:11,431 --> 00:07:14,431
而我没有为第二个参数赋值，

132
00:07:14,434 --> 00:07:19,434
默认为零。当调用我定义的这种函数时，

133
00:07:19,439 --> 00:07:23,439
而这种函数可以返回列表，

134
00:07:23,443 --> 00:07:26,443
我可以将结果分配至一个数组然后解引用，

135
00:07:26,446 --> 00:07:30,446
也可以将结果分配至单独变量。

136
00:07:30,450 --> 00:07:33,450
很多内容都在引用手册及其他文件里。

137
00:07:33,453 --> 00:07:35,453
我这里想给大家从整体、宏观的层面介绍一下，

138
00:07:35,455 --> 00:07:38,455
快速了解一下这种语言，

139
00:07:38,458 --> 00:07:42,458
让你们习惯一种以前没见过的语言中的阅读代码。

140
00:07:42,462 --> 00:07:45,462
控制流和语句，直接看到这儿。语句以分号结尾，

141
00:07:45,465 --> 00:07:48,465
或换行结尾，换行更普遍。

142
00:07:48,468 --> 00:07:52,468
再回到代码美感。

143
00:07:52,472 --> 00:07:56,472
除了写Ruby代码和在伯克利教聪明学生之外，

144
00:07:56,476 --> 00:07:59,476
我还做其他的事，其中一项就是音乐。

145
00:07:59,479 --> 00:08:02,479
我涉及的音乐领域包括音乐剧、管弦乐编曲等，

146
00:08:02,482 --> 00:08:05,482
如果这里有人玩爵士乐，对于爵士乐手来说，

147
00:08:05,485 --> 00:08:08,485
谱写爵士乐的几大乐趣之一就是

148
00:08:08,488 --> 00:08:11,488
你想尽量减少乐谱上的符号，

149
00:08:11,491 --> 00:08:14,491
同时又能表达出乐手所有的情绪。

150
00:08:14,494 --> 00:08:16,494
我认为编程也是这样的。我甚至已经到了这样的地步，

151
00:08:16,496 --> 00:08:19,496
喜欢在字符串前后用单引号而不是双引号，

152
00:08:19,499 --> 00:08:22,499
这样屏幕像素会更低。我是认真的。

153
00:08:22,502 --> 00:08:27,502
这是一种强迫症。

154
00:08:27,507 --> 00:08:30,507
在Ruby语言中，即使可以用分号来结束语句，

155
00:08:30,510 --> 00:08:33,510
你却看不到。你把每个语句放在单独一行，

156
00:08:33,513 --> 00:08:38,513
因为那更简单，每行的内容也更少。

157
00:08:38,518 --> 00:08:41,518
这是不是说不能跨行拆开语句？

158
00:08:41,521 --> 00:08:44,521
这是说你得小心语法分析器。这里有两个语句的例子。

159
00:08:44,524 --> 00:08:47,524
例1的行在"unless"之后拆开，这在语法上是正确的。

160
00:08:47,527 --> 00:08:50,527
除非船稳定，否则我就要"raise a boom exception"。

161
00:08:50,530 --> 00:08:54,530
如果在"raise boom"之后拆开就不对了，

162
00:08:54,534 --> 00:08:59,534
因为"raise boom"这个语句本身

163
00:08:59,539 --> 00:09:01,539
就是Ruby语句。

164
00:09:01,541 --> 00:09:04,541
这里翻译就要糊涂了，

165
00:09:04,544 --> 00:09:07,544
因为在这里就停止了语法分析，而后面还有个"unless"，

166
00:09:07,547 --> 00:09:11,547
这到底什么意思？这里的基本比较运算符你们都见过。

167
00:09:11,551 --> 00:09:14,551
一会我们会看到，equal tweedle和bang tweedle

168
00:09:14,554 --> 00:09:17,554
也用于正则表达式等。

169
00:09:17,557 --> 00:09:21,557
有Boolean"true"和"false"，

170
00:09:21,561 --> 00:09:25,561
还有Boolean零，它是一个"false"值但又和"false"不一样。

171
00:09:25,565 --> 00:09:29,565
别担心，控制流架构是常规的。

172
00:09:29,569 --> 00:09:34,569
我们还有if, then, else along with else, ifs. 

173
00:09:34,574 --> 00:09:40,574
还有while和until，下面这些奇怪的东西是什么？从1到10或10次/倍。

174
00:09:40,580 --> 00:09:42,580
你们可以将它们理解是循环，但我真希望你们不要这样做。

175
00:09:42,582 --> 00:09:45,582
几节之后我们会讲到块和迭代器。

176
00:09:45,585 --> 00:09:48,585
这些是对迭代的完全不一样的理解。

177
00:09:48,588 --> 00:09:51,588
不要理解成循环，

178
00:09:51,591 --> 00:09:53,591
把它们理解成管理自己遍历的对象。

179
00:09:53,593 --> 00:09:57,593
我再重复一遍，对象可以管理自己的遍历。

180
00:09:57,597 --> 00:10:01,597
如果我是一个二叉树，

181
00:10:01,601 --> 00:10:04,601
我可以管理自己的元素遍历。如果我是数组，

182
00:10:04,604 --> 00:10:07,604
我可以管理自己的元素遍历，

183
00:10:07,607 --> 00:10:10,607
通常是以直线顺序。

184
00:10:10,610 --> 00:10:13,610
事实上，我可以定义任意对象或数据结构，如果它含有超过一个元素，

185
00:10:13,613 --> 00:10:17,613
它可以决定这些元素的遍历。

186
00:10:17,617 --> 00:10:21,617
我们会看到，这些包含"up to"和"times"的例子事实上表达的是：

187
00:10:21,621 --> 00:10:24,621
“我将就位，找到一个数字序列，

188
00:10:24,624 --> 00:10:27,624
它会管理自己的遍历。”

189
00:10:27,627 --> 00:10:31,627
这个一会儿还会讲到。字符串和正则表达式。

190
00:10:31,631 --> 00:10:35,631
正则表达式绝对是你们的好朋友。

191
00:10:35,635 --> 00:10:37,635
现在正好开始回顾一下正则表达式。

192
00:10:37,637 --> 00:10:41,637
我们来快速回顾一下。有个网站叫rubyler ，

193
00:10:41,641 --> 00:10:45,641
真的，rublyer. com，可以用它参照字符串

194
00:10:45,645 --> 00:10:48,645
测试正则表达式，确保它按你的要求运行。

195
00:10:48,648 --> 00:10:50,648
如何表示字符串？有双引号、单引号和% Q，

196
00:10:50,650 --> 00:10:55,650
后面这个的意思是这个字符串的处理和它在双引号中一样。

197
00:10:55,655 --> 00:10:58,655
为什么要用这个？

198
00:10:58,658 --> 00:11:02,658
第一，可以将双引号用在字符串中，同样地，

199
00:11:02,662 --> 00:11:06,662
%q 表示这个字符串就像位于双引号中一样。

200
00:11:06,666 --> 00:11:09,666
两者有什么区别？以双引号字符串为例，

201
00:11:09,669 --> 00:11:13,669
可以插入一个表达式。请注意，

202
00:11:13,673 --> 00:11:17,673
我说的是“表达式”。当双引号字符串里有井号架构时，

203
00:11:17,677 --> 00:11:20,677
可以把任意复杂性的Ruby表达式放在那儿。

204
00:11:20,680 --> 00:11:23,680
如果放入太复杂的东西，形式不好。

205
00:11:23,683 --> 00:11:25,683
你能做，不表示你要这么做。

206
00:11:25,685 --> 00:11:28,685
单引号字符串则不行，

207
00:11:28,688 --> 00:11:32,688
因为它是逐字逐句的。

208
00:11:32,692 --> 00:11:35,692
那正则表达式呢？

209
00:11:35,695 --> 00:11:38,695
等你们做过一些Ruby编程后，你们就会更理解，

210
00:11:38,698 --> 00:11:41,698
可以把字符串放在equal tweedle操作符的任一边，

211
00:11:41,701 --> 00:11:45,701
那是匹配操作符。

212
00:11:45,705 --> 00:11:48,705
现在我用字符fox@ berkley. edu

213
00:11:48,708 --> 00:11:52,708
与这个正则表达式进行匹配。

214
00:11:52,712 --> 00:11:54,712
你们都了解正则表达式，所以我来回顾一下。

215
00:11:54,714 --> 00:11:59,714
大家都知道这个正则表达式的意思是，

216
00:11:59,719 --> 00:12:03,719
“与结尾带@的零个或多个任何类型的字符匹配，

217
00:12:03,723 --> 00:12:08,723
后面是零个或多个任何类型的字符，后面是一点。 

218
00:12:08,728 --> 00:12:11,728
反斜杠表示这一点不是通配符，

219
00:12:11,731 --> 00:12:14,731
而仅仅是一点，后面是字母edu，

220
00:12:14,734 --> 00:12:17,734
再后面是字符串结尾。”这个情况下，正则表达式匹配就能成功。

221
00:12:17,737 --> 00:12:20,737
edu在左边是大写而在右边是小写，为什么？

222
00:12:20,740 --> 00:12:23,740
这没关系，

223
00:12:23,743 --> 00:12:26,743
因为该正则表达式的 trailing eye会说

224
00:12:26,746 --> 00:12:29,746
“忽略大小写”。如果你们用其他脚本语言编过程，

225
00:12:29,749 --> 00:12:32,749
比如Pearl或Python，这里有些句法和那些语言高度重合。

226
00:12:32,752 --> 00:12:36,752
我可以在equal tweedle两边随意调换顺序，

227
00:12:36,756 --> 00:12:39,756
完全没问题。

228
00:12:39,759 --> 00:12:44,759
此表达式的返回值是，

229
00:12:44,764 --> 00:12:47,764
如果有任何形式的匹配，我会得到”true”值。

230
00:12:47,767 --> 00:12:51,767
如果不匹配，就是”false”值。如果匹配，而表达式带有括弧组，

231
00:12:51,771 --> 00:12:55,771
变量＄1至＄

232
00:12:55,775 --> 00:12:58,775
但很多组都是部分匹配。

233
00:12:58,778 --> 00:13:02,778
在我举的这个简单例子中，

234
00:13:02,782 --> 00:13:05,782
＄1估值为fox，因为@前的第一组任意字符组

235
00:13:05,785 --> 00:13:08,785
与我名字中第一组字符匹配。

236
00:13:08,788 --> 00:13:13,788
＄2匹配Berkley，因为第二组括号

237
00:13:13,793 --> 00:13:17,793
与这组字符匹配，在.edu之前。

238
00:13:17,797 --> 00:13:24,797
学习它们，了解它们，热爱它们。

239
00:13:24,804 --> 00:13:27,804
最后讲讲其它写正则表达式的方法。

240
00:13:27,807 --> 00:13:30,807
斜杠是最常见的，包括Pearl和Python在内的很多语言都使用。

241
00:13:30,810 --> 00:13:33,810
也可以用比较长的形式来构建，

242
00:13:33,813 --> 00:13:38,813
比如说构建一个新的 [ rejects 00:13:35]。

243
00:13:38,818 --> 00:13:41,818
还有% R括号，这个不很常见，

244
00:13:41,821 --> 00:13:43,821
这里只是让你们知道这也是一种方法。


